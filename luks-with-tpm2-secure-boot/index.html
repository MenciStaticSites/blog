<!doctype html><html lang=zh-CN><head><title>基于 TPM 2.0 与 Secure Boot 的 LUKS 自动解密 - Menci&#39;s Blog</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=author content=Menci><meta name=description content="为了保护用户数据，现代设备与操作系统往往都支持全盘加密的功能，其中最为典型的是 Microsoft Windows..."><meta name=keywords content=""><link rel=alternate type=application/atom+xml title="ATOM 1.0" href=/atom.xml><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content=webkit><meta name=theme-color content=#ffffff><link rel="shortcut icon" type=image/x-icon href=//static.cdn.menci.xyz/menci-blog/avatar.6e993e78.png crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/KaTeX/0.15.2/katex.min.css crossorigin=anonymous><link rel=stylesheet href=//static.cdn.menci.xyz/menci-blog/css/journal.b205a034.css crossorigin=anonymous><link rel=stylesheet href="//cdn.menci.xyz/fonts/css2?family=Noto+Sans+SC:wght@300%3B400%3B600&family=Source+Sans+Pro:wght@400%3B600&family=Lato:wght@400%3B500&family=Hind+Vadodara:wght@300%3B400&family=Montserrat&family=Fira+Code&family=Material+Icons&display=block" crossorigin=anonymous><script async data-domain=blog.men.ci src=//stat.u.sb/js/plausible.js></script><meta name=generator content="Hexo 7.3.0"></head><body><div id=top></div><div id=app><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block false drawer-menu-item" href=https://blog.men.ci>首页 </a><a class="a-block false drawer-menu-item" href=/archives/ >归档 </a><a class="a-block false drawer-menu-item" href=/tags/ >标签 </a><a class="a-block false drawer-menu-item" href=/friends/ >朋友们 </a><a class="a-block false drawer-menu-item" href=/about-me/ >关于我</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar navbar-light single-column-nav-container sticky-top"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer><i class=material-icons>menu</i></button> <a ref=navTitle class=navbar-brand href=/ >Menci&#39;s Blog</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/ ><div class=single-column-header-title>Menci's Blog</div><div class=single-column-header-subtitle>念念不忘，必有回响</div></a></div><div ref=sideContainer class=side-container><a class="a-block false nav-head" href=/ ><div class=nav-title>Menci's Blog</div><div class=nav-subtitle>念念不忘，必有回响</div></a><div class=nav-link-list><a class="a-block false nav-link-item" href=/archives/ >归档 </a><a class="a-block false nav-link-item" href=/tags/ >标签 </a><a class="a-block false nav-link-item" href=/friends/ >朋友们 </a><a class="a-block false nav-link-item" href=/about-me/ >关于我</a></div><div class=nav-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="animated-visibility pagination-action" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image: url('')"><div class=post-title>基于 TPM 2.0 与 Secure Boot 的 LUKS 自动解密<div class=post-meta><time datetime=2022-12-02T16:27:00.000Z itemprop=datePublished>2022-12-03 </time>&nbsp; <i class=material-icons style="">label</i> <a href=/tags/SRE/ >SRE</a>, <a href=/tags/Linux/ >Linux</a>, <a href=/tags/安全/ >安全</a></div></div></div><div class=post-body-wrapper><div class=post-body><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86><span class=toc-number>1.</span> <span class=toc-text>前置知识</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#secure-boot><span class=toc-number>1.1.</span> <span class=toc-text>Secure Boot</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#tpm-2.0><span class=toc-number>1.2.</span> <span class=toc-text>TPM 2.0</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#luks><span class=toc-number>1.3.</span> <span class=toc-text>LUKS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%AE%9E%E8%B7%B5><span class=toc-number>2.</span> <span class=toc-text>实践</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E4%B8%8E%E5%8A%A0%E5%AF%86><span class=toc-number>2.1.</span> <span class=toc-text>准备分区与加密</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%85%8D%E7%BD%AE-secure-boot><span class=toc-number>2.2.</span> <span class=toc-text>配置 Secure Boot</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%94%9F%E6%88%90-mok-%E8%AF%81%E4%B9%A6><span class=toc-number>2.2.1.</span> <span class=toc-text>生成 MOK 证书</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E5%AE%89%E8%A3%85-shim><span class=toc-number>2.2.2.</span> <span class=toc-text>安装 shim</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AD%BE%E5%90%8D%E5%B9%B6%E5%AE%89%E8%A3%85-grub><span class=toc-number>2.2.3.</span> <span class=toc-text>签名并安装 GRUB</span></a></li><li class="toc-item toc-level-3"><a class=toc-link href=#%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8><span class=toc-number>2.2.4.</span> <span class=toc-text>签名内核</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%85%8D%E7%BD%AE-tpm><span class=toc-number>2.3.</span> <span class=toc-text>配置 TPM</span></a><ol class=toc-child><li class="toc-item toc-level-3"><a class=toc-link href=#%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86><span class=toc-number>2.3.1.</span> <span class=toc-text>自动解密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0><span class=toc-number>2.4.</span> <span class=toc-text>系统更新</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC><span class=toc-number>2.5.</span> <span class=toc-text>工具脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E6%94%BB%E5%87%BB%E9%9D%A2><span class=toc-number>3.</span> <span class=toc-text>攻击面</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB><span class=toc-number>3.1.</span> <span class=toc-text>冷启动攻击</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#evil-maid-%E6%94%BB%E5%87%BB><span class=toc-number>3.2.</span> <span class=toc-text>Evil Maid 攻击</span></a></li></ol></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99><span class=toc-number>4.</span> <span class=toc-text>参考资料</span></a></li></ol><p>为了保护用户数据，现代设备与操作系统往往都支持全盘加密的功能，其中最为典型的是 Microsoft Windows 的 BitLocker。它既可以对系统分区进行加密，又可以在确认引导过程可信的情况下，不需要用户交互即可自动解密，这利用到了 TPM 和 Secure Boot。而在 GNU/Linux 系统下，如果用常用的 LUKS 加密方案进行全盘加密，则需要在每次开机时输入密码。</p><p>本篇文章将参考 BitLocker 的做法，利用 Secure Boot 和 TPM 2.0 来实现 LUKS 全盘加密的自动解密。</p><span id=more></span><h1 id=%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86 tabindex=-1>前置知识 <a class=headerlink href=#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86></a></h1><h2 id=secure-boot tabindex=-1>Secure Boot <a class=headerlink href=#secure-boot></a></h2><p>Secure Boot（安全启动）是 Microsoft 在 UEFI 中引入的一项安全功能，旨在防止恶意代码在进入操作系统之前被加载，破坏操作系统的安全。</p><p>Secure Boot 的原理是信任链，其信任根是 UEFI 中的 CA 证书，这里 CA 证书可以内置在 UEFI 固件中，也可以由机器所有者手动设置。在开启 Secure Boot 时，UEFI 固件在加载 EFI 可执行文件前，会首先检验其签名，如果其签名不是来自于 CA，则会拒绝加载。一般主板的 UEFI 固件均内置 Microsoft 的两个 CA 证书，分别为：</p><ul><li><strong>Microsoft Windows Production PCA 2011</strong>，为 Windows 引导程序签名</li><li><strong>Microsoft Corporation UEFI CA 2011</strong>，为 Linux 相关的引导程序签名</li></ul><p>Microsoft 为多个 Linux 发行版的引导程序提供了签名，如 Ubuntu、Debian 和 Fedora 等。除此之外，Microsoft 也为 PreLoader 和 shim 两个特殊的引导程序提供了签名，他们的作用是在不修改设备 CA 的情况下，让用户通过安装自己的证书来加载由用户自己签名的其他引导程序。这种证书叫做 MOK（Machine Owner Key）证书。有了 PreLoader / shim 与 MOK，用户可以方便地让系统信任用户自己的引导程序。</p><p>Secure Boot 仅提供对第一阶段引导程序的签名检验，而之后的代码检验则交给被加载的引导器，以及被引导器加载的系统内核所完成。在 Secure Boot 开启时，UEFI 会提供一个接口来获得当前设备上的可信证书列表，包含 CA 证书和（由 PreLoader / shim 管理的）MOK 证书，以便后续的检验过程使用。例如，默认情况下，GRUB 在 Secure Boot 开启时，会使用 UEFI 提供的证书列表检验其所加载的内核的代码签名。内核也可以被配置为检验其加载的 <code>.ko</code> 模块文件的签名。</p><div class=flex-wrapper><blockquote><p><strong>提示</strong></p><p>除第一步 UEFI 固件对第一阶段引导程序的签名检验强制使用 UEFI 中的 Secure Boot CA 证书外，之后的过程如何校验均不是受 UEFI 所控制的。即使 UEFI 提供了通用的接口来允许引导程序或操作系统获得其信任的证书列表（包括 CA 和 MOK），第一阶段之后的引导程序仍然可以不使用这些证书，或者使用这些证书外加其自身信任的证书来进行代码签名检验。例如，UEFI 本身不信任 MOK，但被 UEFI 信任的 PreLoader / shim 信任 MOK，所以使用 MOK 签名的引导程序可以被 PreLoader / shim 加载。</p><p>另一个典型的例子是，Linux 内核在编译时，可以使用一个自有的证书对随内核编译的模块进行签名，并将该证书内置在编译好的内核中，自动信任这些一同编译的模块，而同时也会信任用户自行编译并使用 UEFI CA / MOK 签名的模块。</p></blockquote></div><h2 id=tpm-2.0 tabindex=-1>TPM 2.0 <a class=headerlink href=#tpm-2.0></a></h2><p>TPM（Trusted Platform Module，可信平台模块）是一种安全芯片，提供了硬件级别的一些安全相关的功能。TPM 可以在内部实现不受恶意软件干扰的密码学操作。早年的 TPM 一般作为独立的模块，插入到计算机主板上的专用接口上，而近年的 CPU 往往内置了 TPM 的功能（如 Intel PTT 与 AMD fTPM），不再需要独立硬件。TPM 的规范由 TCG（Trusted Computing Group，可信计算组织）制定，目前最为广泛使用的版本是 2.0。</p><p>本文中，我们主要用到 TPM 2.0 的<b>完整性测量（Integrity Measurement）</b>的功能。TPM 中定义了一些 PCR（Platform Configuration Register，平台配置寄存器），用于在系统引导过程中记录相关的配置。在 GRUB + Linux 的环境中，常用的一些 PCR 的所测量的值如下：</p><table><thead><tr><th style=text-align:center>PCR 编号</th><th style=text-align:center>测量值</th><th style=text-align:center>备注</th></tr></thead><tbody><tr><td style=text-align:center>0</td><td style=text-align:center>UEFI BIOS 固件代码</td><td style=text-align:center>当升级 BIOS 固件时变化</td></tr><tr><td style=text-align:center>1</td><td style=text-align:center>UEFI BIOS 固件配置</td><td style=text-align:center>当修改 BIOS 设置时变化，改回后会恢复</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>Option ROM 固件代码</td><td style=text-align:center>一些硬件设备（如 PCIe 设备）在启动时执行的代码</td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>Option ROM 固件配置</td><td style=text-align:center></td></tr><tr><td style=text-align:center>4</td><td style=text-align:center>UEFI 引导程序代码</td><td style=text-align:center>即引导过程中加载的 <code>.efi</code> 可执行文件<br>（由 UEFI 设置，<a target=_blank rel=noopener href=https://github.com/rhboot/shim/blob/ea4911c2f3ce8f8f703a1476febac86bb16b00fd/shim.c#L993>shim 也会设置</a>）</td></tr><tr><td style=text-align:center>5</td><td style=text-align:center>GPT 分区表</td><td style=text-align:center></td></tr><tr><td style=text-align:center>6</td><td style=text-align:center>S4/S5 挂起恢复状态</td><td style=text-align:center></td></tr><tr><td style=text-align:center>7</td><td style=text-align:center>Secure Boot 配置</td><td style=text-align:center>关闭 Secure Boot 或修改 MOK 后会变化</td></tr><tr><td style=text-align:center>8</td><td style=text-align:center>GRUB 命令与内核参数</td><td style=text-align:center><a target=_blank rel=noopener href=https://github.com/rhboot/grub2/blob/87399901aafe63adeb88b7e58c8fea51c915e627/docs/grub.texi#L6198>由 GRUB 设置</a></td></tr><tr><td style=text-align:center>9</td><td style=text-align:center>GRUB 读取的所有文件<br>（包括 <code>vmlinuz</code> 与 <code class=punctuation-r>initrd</code>）</td><td style=text-align:center><a target=_blank rel=noopener href=https://github.com/rhboot/grub2/blob/87399901aafe63adeb88b7e58c8fea51c915e627/docs/grub.texi#L6198>由 GRUB 设置</a></td></tr></tbody></table><p>由于这些值均是在引导过程中由固件/引导器/操作系统的代码所设置，为了确保这些值不被篡改，TPM 所定义的唯一修改 PCR 的接口是 <span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.8333em;vertical-align:-0.15em;></span><span class=mord><span class=mord><span class="mord mathrm">PCR</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3117em;><span style=top:-2.55em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="mtight reset-size6 size3 sizing"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>←</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">Extend</span></span><span class=mopen>(</span><span class=mord><span class=mord><span class="mord mathrm">PCR</span></span><span class=msupsub><span class="vlist-t vlist-t2"><span class=vlist-r><span class=vlist style=height:0.3117em;><span style=top:-2.55em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="mtight reset-size6 size3 sizing"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:0.15em;><span></span></span></span></span></span></span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord><span class="mord mathrm">data</span></span><span class=mclose>)</span></span></span></span>，其中：</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">Extend</span></span><span class=mopen>(</span><span class="mord mathnormal">x</span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord><span class="mord mathrm">data</span></span><span class=mclose>)</span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">hash</span></span><span class=mopen>(</span><span class="mord mathnormal">x</span><span class=mspace style=margin-right:0.2222em;></span><span class=mbin><span class=mrel>∣</span></span><span class=mspace style=margin-right:0.2222em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathrm">hash</span></span><span class=mopen>(</span><span class=mord><span class="mord mathrm">data</span></span><span class=mclose>))</span></span></span></span></span><p>其中 <span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class=mrel>∣</span></span></span></span></span> 表示二进制或，哈希函数目前可选 SHA-1 与 SHA-256。这种算法使得 PCR 中的测量值的变化是不可预测且不可逆的，在可信的引导组件将测量值正确地传递给 TPM 后，恶意代码即使已知期望的 PCR 测量值，也无法将其写入 TPM，从而无法欺骗 TPM 的完整性测量。</p><p>在这样的前提下，TPM 提供了安全存储密钥的功能。操作系统可以指定一系列 PCR 寄存器的编号，令 TPM 通过这些 PCR 目前的测量值计算出检验值，并将检验值和密钥持久化存储。在之后的引导中，操作系统可以再次告知 TPM 所检验的 PCR 值列表，当 TPM 验证这些 PCR 的当前测量值的校验和与之前保存的一致时，才会向 CPU 输出密钥，否则不会输出密钥。这样一来，当攻击者植入恶意代码，或者修改固件配置，导致引导阶段的完整性被破坏时，处于安全威胁中的操作系统将无法获得密钥。</p><h2 id=luks tabindex=-1>LUKS <a class=headerlink href=#luks></a></h2><p>LUKS（Linux Unified Key Setup，Linux 统一密钥设置）是 Linux 下最常用的磁盘加密方案。LUKS 基于 DM（Device Mapper，设备映射器）的 <code>dm-crypt</code> 功能，将<strong>被加密块设备</strong>解密后的内容映射为<strong>虚拟块设备</strong>，对文件系统透明。LUKS 提供了多种加密算法与密钥派生函数，目前的默认值是 <a target=_blank rel=noopener href=https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_(XTS)>AES-XTS-512</a> 和 <a target=_blank rel=noopener href=https://en.wikipedia.org/wiki/Argon2>Argon2i</a>。LUKS 有 8 个密钥槽，即可以分别设置 8 个解密密码。</p><div class=flex-wrapper><blockquote><p><strong>密钥派生</strong></p><p>PBKDF（Password-Based Key Derivation Function，基于密码的密钥派生函数）是一种哈希函数，被用于将用户设置的便于记忆的密码转换为加密算法接受的固定长度密钥。</p><span class=katex-display><span class=katex><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.8889em;vertical-align:-0.1944em;></span><span class=mord><span class="mord mathrm" style=margin-right:0.01389em;>key</span></span><span class=mspace style=margin-right:0.2778em;></span><span class=mrel>=</span><span class=mspace style=margin-right:0.2778em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class="mord mathnormal" style=margin-right:0.10764em;>f</span><span class=mopen>(</span><span class=mord><span class="mord mathrm">password</span></span><span class=mpunct>,</span><span class=mspace style=margin-right:0.1667em;></span><span class=mord><span class="mord mathrm">salt</span></span><span class=mclose>)</span></span></span></span></span><p>加密算法一般接受长度为 256 或 512 位的密钥，而用户设置的密码复杂度一般在 10 个可见字符左右，包含的信息熵远低于加密算法所接受的密钥长度。如果使用一般的哈希函数（如 SHA-512），由于其计算速度较快，穷举密码的复杂度远远小于穷举密钥，将会降低整个加密系统的安全性。所以，为了抵抗穷举密码攻击，密钥派生函数往往被设计为单次计算需要消耗较多时间。于此同时，一些密钥派生函数会被设计为计算时需要占用较大的内存，来加大并行计算的难度。</p><p>当密码的信息熵足够大时（如直接使用随机生成的 512 字节密钥文件作为密码），密码与派生后密钥的穷举空间相同，此时不需要使用密钥派生函数。但在 LUKS 中无法关闭密钥派生这一步骤，只能使用相关参数降低密钥派生的计算复杂度。</p></blockquote></div><p>为了实现包括根分区在内的全盘加密，常用的各个发行版均在 <code>initrd</code> 中加入了在引导过程中进行解密的支持。<code class=punctuation-l>initrd</code> 中的脚本会解析 <code>/etc/crypttab</code> 文件，加载其中的加密分区，用户可以设置解密时要求输入密码，或通过命令读取密码。本文将会实现在引导时使用储存在 TPM 中的密钥作为密码进行解密，并同时支持输入由用户设置的密码进行解密。</p><h1 id=%E5%AE%9E%E8%B7%B5 tabindex=-1>实践 <a class=headerlink href=#%E5%AE%9E%E8%B7%B5></a></h1><p>本文的实践部分基于 Debian 11，其他发行版可能需要修改一些命令和软件包名称。</p><p>在进行系统外的离线操作时，推荐使用 Arch Linux 安装镜像，其中包含了大部分维护工具和 <code>arch-chroot</code> 命令。</p><div class=flex-wrapper><blockquote><p><strong>注意</strong></p><p>由于 Arch Linux 不使用 <code>/usr/sbin</code> 目录，所以该路径不会包含在 Arch Linux 安装镜像中的默认 <code>$PATH</code> 中。所以使用 <code>chroot</code> 进入一个 Debian / Ubuntu 根文件系统后，一些命令会找不到，此时需要将该路径手动添加到 <code>$PATH</code> 中：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#24292E>PATH</span><span style=color:#D73A49>=</span><span style=color:#24292E>$PATH</span><span style=color:#032F62>:/usr/sbin</span></span>
</code></pre></div><p>如果目标文件系统是 ZFS，则需要安装 <a target=_blank rel=noopener href=https://github.com/eoli3n/archiso-zfs><code>archiso-zfs</code></a>。</p></blockquote></div><h2 id=%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E4%B8%8E%E5%8A%A0%E5%AF%86 tabindex=-1>准备分区与加密 <a class=headerlink href=#%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E4%B8%8E%E5%8A%A0%E5%AF%86></a></h2><p>在一个加密的系统上，硬盘分区分为两部分：加密的部分和未加密的部分。加密的部分的分区是可信的，而未加密的部分分区是不可信的，需要在引导过程中被检验。我们可以将硬盘分为三个分区（按顺序）：EFI 引导分区，<code class=punctuation-l>/boot</code> 分区和需要加密的数据分区（下简称数据分区），并在加密数据分区上使用 LVM（Logical volume Manager，逻辑卷管理）来管理逻辑分区。当然，LVM 不是必须的，如果不需要对加密部分进行分区，可以直接将加密空间作为一个根分区来使用。如果原本没有 EFI 分区，说明是使用 CSM 引导，此时需要参考其他教程迁移到 EFI 引导。如果原本没有 <code>/boot</code> 分区，则需要调整分区后手动创建，将原本 <code>/boot</code> 内容移动进去，并加入到 <code>/etc/fstab</code> 中。</p><div class=flex-wrapper><blockquote><p><strong>注意</strong></p><p>一些教程会将 <code>/boot</code> 分区一并加密，这会使得配置过程更加繁琐。在我们的设置中，保持 <code>/boot</code> 未被加密并不会降低安全性，因为在调用 TPM 获取密钥进行自动解密时，TPM 会确保启动链未被篡改。而即使加密了 <code class=punctuation-r>/boot</code>，在启动链未被验证的系统上，恶意代码仍然能够被通过 EFI 注入。</p></blockquote></div><p>对于已安装的系统，我们需要将现有的数据分区备份，最简单的方式是使用 <code>dd</code> 命令复制块设备。注意 LUKS 加密会占用一部分空间用于存储元数据，所以备份原分区前需要先将其缩小，推荐的步骤是：</p><ol><li>将原分区的文件系统缩小 2 GiB（使用 <code class=punctuation-r>pvresize</code>、<code class="punctuation-r punctuation-l">btrfs filesystem resize</code>、<code class=punctuation-l>resize2fs</code> 等命令）</li><li>将原分区的分区删除，并在原位置重建，重建时大小缩小 1 GiB（使用 <code>cfdisk</code> 等管理工具）</li><li>将新分区的大小自动扩大到文件系统大小（使用第一步相同的命令，通常默认参数会自动扩大到文件系统大小）</li></ol><p>这种方式可以避免计算和在命令中填写具体大小，同时留有一定的余量，方便调整/创建 EFI 和 <code>/boot</code> 分区。</p><p>将原有的 EFI 和 <code>/boot</code> 中的数据备份（如果没有多系统引导则不需要备份 EFI 分区），并将缩小后的数据分区备份，之后对硬盘进行安全擦除，防止加密前的数据被恢复。擦除后重新建立分区表，推荐为 EFI 分配 128 MiB（如果不使用 EFISTUB），为 <code>/boot</code> 分配至少 1 GiB，剩余的空间作为加密数据分区。</p><p>假设为加密数据准备的分区是 <code class=punctuation-r>/dev/sda3</code>，执行以下命令创建 LUKS 加密分区（注意输入大写的 <code class=punctuation-r>YES</code>）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cryptsetup</span><span style=color:#032F62> luksFormat</span><span style=color:#032F62> /dev/sda3</span></span>

WARNING!
========
This will overwrite data on /dev/sda3 irrevocably.

Are you sure? (Type &#039;yes&#039; in capital letters): YES
Enter passphrase for /dev/sda3:
Verify passphrase:
</code></pre></div><p>创建加密分区后，将加密分区打开。打开加密分区时需要指定一个名称。成功打开后，系统将在 <code>/dev/mapper/</code> 下创建解密后的块设备，例如指定名称为 <code class=punctuation-r>lvm-encrypted</code>：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cryptsetup</span><span style=color:#032F62> open</span><span style=color:#032F62> /dev/sda3</span><span style=color:#032F62> lvm-encrypted</span></span>
Enter passphrase for /dev/sda3:
</code></pre></div><div class=flex-wrapper><blockquote><p><strong>提示</strong></p><p>为了提高加密后 SSD 的 I/O 性能，可以<a target=_blank rel=noopener href=https://wiki.archlinux.org/title/Dm-crypt/Specialties#Disable_workqueue_for_increased_solid_state_drive_(SSD)_performance>禁用工作队列</a>，执行以下命令（选项将保存在 LUKS 元数据中）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cryptsetup</span><span style=color:#005CC5> --perf-no_read_workqueue</span><span style=color:#005CC5> --perf-no_write_workqueue</span><span style=color:#005CC5> --persistent</span><span style=color:#032F62> refresh</span><span style=color:#032F62> lvm-encrypted</span></span>
</code></pre></div></blockquote></div><p>将备份好的数据分区使用 <code>dd</code> 恢复到该块设备中：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>dd</span><span style=color:#032F62> if=/path/to/backup/drive/bak.img</span><span style=color:#032F62> of=/dev/mapper/lvm-encrypted</span><span style=color:#032F62> status=progress</span><span style=color:#032F62> bs=128M</span></span>
</code></pre></div><p>此时，对于 LVM，可以使用 <code>vgscan</code> 命令识别原有的卷组，并使用 <code>vgchange -ay &lt;vgname&gt;</code> 激活。</p><p>由于我们缩减文件系统时留下了较大的空闲空间，此时可以将文件系统大小调整到到 LUKS 创建的块设备的大小上限。同理使用 <code class=punctuation-r>pvresize</code>、<code class="punctuation-r punctuation-l">btrfs filesystem resize</code>、<code class=punctuation-l>resize2fs</code> 等命令即可完成。</p><p>将根文件系统挂载。如果 <code>/boot</code> 分区是新创建的，需要从原有的根分区中将原有的文件移动过去。重新创建的 EFI 和 <code>/boot</code> 分区的 UUID 会与原有的不同，需要添加或者修改 <code>/etc/fstab</code> 中的条目。最简单的方式是将 <code>/mnt/boot</code> 和 <code>/mnt/boot/efi</code> 挂载后，使用 <code>genfstab -U /mnt</code> 命令生成（对于加密分区或者 LVM 分区，建议不使用 UUID，而是使用 <code>/dev/mapper/&lt;name&gt;</code> 挂载）。</p><p>之后执行 <code class=punctuation-r>arch-chroot /mnt</code>，进入加密系统的根文件系统中执行。要使得加密后的系统能够正常引导，需要告知系统在 <code>initrd</code> 中打开加密分区。在根文件系统中创建 <code>/etc/crypttab</code> 文件：</p><div class=flex-wrapper><pre><code><span class=line><span>lvm-encrypted UUID=72fa928c-4df7-6448-ae04-11c909ff071e none luks,discard</span></span>
<span class=line><span></span></span></code></pre></div><p>文件的每一行共有四列，分别表示名称、块设备（请将 UUID 替换为加密分区的文件系统 UUID）、密钥文件（<code class=punctuation-l>none</code> 表示不使用固定的密钥解密）和选项。选项中的 <code>discard</code> 表示<a target=_blank rel=noopener href=https://wiki.archlinux.org/title/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)>启用 SSD TRIM</a>，启用后可能会导致一些测信道信息泄露，例如其中文件系统的类型和用量可能能够被从被丢弃块的特征中推算出来，但这通常不被认为是一个安全威胁。</p><div class=flex-wrapper><blockquote><p><strong>ZFS 注意事项</strong></p><p>在构建 <code>initrd</code> 时，<code class=punctuation-l>cryptsetup</code> 的脚本会通过 <code>/proc/mounts</code> 中的信息判断当前系统的根目录属于哪一个加密块设备，进而将对应的 <code>/etc/crypttab</code> 条目放入 <code>initrd</code> 中，在引导时进行解密。但由于 ZFS 根目录不是通过块设备挂载的，所以 <code>update-initramfs</code> 会提示找不到根目录所对应的加密设备条目。</p><p>此时需要手动在 <code>/etc/crypttab</code> 的对应条目中加入 <code>initramfs</code> 选项，将其指定为在引导时进行解密（即改为 <code class=punctuation-r>luks,initramfs,discard</code>）。</p></blockquote></div><p>如果 <code>cryptsetup</code> 命令不存在，则需要手动安装 <code>cryptsetup</code> 包，否则直接运行 <code>update-initramfs -u -k all</code> 重建 <code>initrd</code> 即可。</p><p>如果原有的引导方式为 EFI GRUB，则此时重建 GRUB 后即可正常引导原有系统，系统会在开机时提示输入密码解密 LUKS 分区。接下来的步骤可以在 <code>chroot</code> 中完成，也可以在成功引导的系统中完成。</p><h2 id=%E9%85%8D%E7%BD%AE-secure-boot tabindex=-1>配置 Secure Boot <a class=headerlink href=#%E9%85%8D%E7%BD%AE-secure-boot></a></h2><p>首先，安装 <code class=punctuation-r>shim-signed</code>，<code class=punctuation-l>sbsigntool</code> 和 <code>mokutil</code> 包，前者包含带有 Microsoft 签名的 shim 二进制文件，后两者是用于签名和管理设备上的 MOK 证书。</p><h3 id=%E7%94%9F%E6%88%90-mok-%E8%AF%81%E4%B9%A6 tabindex=-1>生成 MOK 证书 <a class=headerlink href=#%E7%94%9F%E6%88%90-mok-%E8%AF%81%E4%B9%A6></a></h3><p>创建一个目录，为安全起见设为仅 root 可访问，使用 <code>openssl</code> 命令生成自签名 MOK 的证书与私钥（其中 <code>CN=</code> 之后的名字可以自定义）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>mkdir</span><span style=color:#005CC5> -p</span><span style=color:#032F62> /var/lib/shim-signed/mok/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>chmod</span><span style=color:#005CC5> 700</span><span style=color:#032F62> /var/lib/shim-signed/mok/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#005CC5>cd</span><span style=color:#032F62> /var/lib/shim-signed/mok/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>openssl</span><span style=color:#032F62> req</span><span style=color:#005CC5> -nodes</span><span style=color:#005CC5> -new</span><span style=color:#005CC5> -x509</span><span style=color:#005CC5> -newkey</span><span style=color:#032F62> rsa:2048</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>              -keyout</span><span style=color:#032F62> MOK.key</span><span style=color:#005CC5> -outform</span><span style=color:#032F62> DER</span><span style=color:#005CC5> -out</span><span style=color:#032F62> MOK.der</span><span style=color:#005CC5> -days</span><span style=color:#005CC5> 36500</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>              -subj</span><span style=color:#032F62> "/CN=My Secure Boot MOK/"</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>openssl</span><span style=color:#032F62> x509</span><span style=color:#005CC5> -inform</span><span style=color:#032F62> der</span><span style=color:#005CC5> -in</span><span style=color:#032F62> MOK.der</span><span style=color:#005CC5> -out</span><span style=color:#032F62> MOK.pem</span></span>
</code></pre></div><p>上述命令生成了 DER 格式的证书，以及 PEM 格式的私钥和证书，因为 <code>mokutil</code> 需要 DER 格式，而 <code>sbsign</code> 需要 PEM 格式。</p><p>使用 <code>mokutil</code> 请求将 MOK 证书导入到系统 PKI 中，这里需要设置一个一次性的密码，以便于 shim 在启动时能够验证证书是由可信的管理员所请求添加的（注意，只有在 shim 被加载时，MOK 与 MOK 安装请求才会生效）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>mokutil</span><span style=color:#005CC5> --import</span><span style=color:#032F62> MOK.der</span></span>
input password:
input password again:
</code></pre></div><h3 id=%E5%AE%89%E8%A3%85-shim tabindex=-1>安装 shim <a class=headerlink href=#%E5%AE%89%E8%A3%85-shim></a></h3><p>将 shim 安装到 EFI 分区中：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>rm</span><span style=color:#005CC5> -rf</span><span style=color:#032F62> /boot/efi/EFI/BOOT</span><span style=color:#24292E> &#x26;&#x26; </span><span style=color:#6F42C1>mkdir</span><span style=color:#005CC5> -p</span><span style=color:#032F62> /boot/efi/EFI/BOOT</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cp</span><span style=color:#032F62> /usr/lib/shim/shimx64.efi.signed</span><span style=color:#032F62> /boot/efi/EFI/BOOT/BOOTx64.EFI</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cp</span><span style=color:#032F62> /usr/lib/shim/mmx64.efi.signed</span><span style=color:#032F62> /boot/efi/EFI/BOOT/mmx64.efi</span></span>
</code></pre></div><p>为 shim 创建 EFI 引导条目，并设为默认（假设 EFI 分区是 <code class=punctuation-r>/dev/sda1</code>）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>efibootmgr</span><span style=color:#005CC5> --unicode</span><span style=color:#005CC5> --disk</span><span style=color:#032F62> /dev/sda</span><span style=color:#005CC5> --part</span><span style=color:#005CC5> 1</span><span style=color:#005CC5> --create</span><span style=color:#005CC5> --label</span><span style=color:#032F62> "Shim"</span><span style=color:#005CC5> --loader</span><span style=color:#032F62> /EFI/BOOT/BOOTx64.EFI</span></span>
</code></pre></div><p>此时，开机时将首先加载 <code class=punctuation-r>BOOTx64.EFI</code>，该文件是 shim 的主程序，它会检测是否有 MOK 安装请求，如果是则会调用 MOK 管理界面 <code>mmx64.efi</code> 进行处理，否则会<a target=_blank rel=noopener href=https://github.com/rhboot/shim/blob/6402f1fec4c9b19f8d570791827b13b9cad98827/BUILDING#L23>默认引导 <code>grubx64.efi</code> 程序</a>。接下来我们需要安装 GRUB 到 <code class=punctuation-r>grubx64.efi</code>，来让 shim 能够找到它。</p><h3 id=%E7%AD%BE%E5%90%8D%E5%B9%B6%E5%AE%89%E8%A3%85-grub tabindex=-1>签名并安装 GRUB <a class=headerlink href=#%E7%AD%BE%E5%90%8D%E5%B9%B6%E5%AE%89%E8%A3%85-grub></a></h3><p>如果没有安装 GRUB（或未安装 EFI 版的 GRUB），需要先安装。Debian 下的包名为 <code class=punctuation-r>grub-efi-amd64-bin</code>。</p><p>由于在 Secure Boot 开启时，GRUB 不允加载文件系统上的任何模块，所以所有需要的模块都要被打包进 <code>grubx64.efi</code> 中。Ubuntu 提供了一个<a target=_blank rel=noopener href="https://git.launchpad.net/~ubuntu-core-dev/grub/+git/ubuntu/tree/debian/build-efi-images?h=debian/2.06-2ubuntu12">列表</a>，默认情况下，将列表中的模块全部加入即可（找不到的模块可以删除）。假设 GRUB 模块列表在 <code>GRUB_MODULES</code> 环境变量中。</p><p>另一方面，shim 要求其加载的 EFI 程序具有 <a target=_blank rel=noopener href=https://github.com/rhboot/shim/blob/main/SBAT.md>SBAT 段</a>。GRUB 安装器可以在生成 EFI 程序时直接指定 SBAT 文件，创建 <code>/tmp/sbat.csv</code> 保存为以下内容：</p><div class=flex-wrapper><pre><code class=language-csv><span class=line><span style=color:#24292E>sbat,</span><span style=color:#D73A49>1,</span><span style=color:#6F42C1>SBAT Version,</span><span style=color:#6A737D>sbat,</span><span style=color:#032F62>1,</span><span style=color:#E36209>https://github.com/rhboot/shim/blob/main/SBAT.md</span></span>
<span class=line><span style=color:#24292E>grub,</span><span style=color:#D73A49>1,</span><span style=color:#6F42C1>Free Software Foundation,</span><span style=color:#6A737D>grub,</span><span style=color:#032F62>2.04,</span><span style=color:#E36209>https://www.gnu.org/software/grub/</span></span>
<span class=line></span></code></pre></div><p>然后安装 GRUB 到目标位置（安装时不需要修改 EFI 设置）并使用 <code>sbsign</code> 对其进行签名：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>grub-install</span><span style=color:#005CC5> --efi-directory=/boot/efi/</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --sbat=/tmp/sbat.csv</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --modules=</span><span style=color:#032F62>"</span><span style=color:#24292E>$GRUB_MODULES</span><span style=color:#032F62>"</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --no-nvram</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --no-bootsector</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --no-uefi-secure-boot</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>               --bootloader-id=BOOT</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>update-grub</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>sbsign</span><span style=color:#005CC5> --key</span><span style=color:#032F62> MOK.key</span><span style=color:#005CC5> --cert</span><span style=color:#032F62> MOK.pem</span><span style=color:#005CC5> --output</span><span style=color:#032F62> /boot/efi/EFI/BOOT/grubx64.efi</span><span style=color:#032F62> /boot/efi/EFI/BOOT/grubx64.efi</span></span>
</code></pre></div><h3 id=%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8 tabindex=-1>签名内核 <a class=headerlink href=#%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8></a></h3><p>由于 GRUB 也会验证内核的签名，我们同样也需要对内核进行签名：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#D73A49>for</span><span style=color:#24292E> KERNEL </span><span style=color:#D73A49>in</span><span style=color:#032F62> /boot/vmlinuz*</span><span style=color:#24292E>; </span><span style=color:#D73A49>do</span><span style=color:#6F42C1> sbsign</span><span style=color:#005CC5> --key</span><span style=color:#032F62> MOK.key</span><span style=color:#005CC5> --cert</span><span style=color:#032F62> MOK.pem</span><span style=color:#005CC5> --output</span><span style=color:#032F62> "</span><span style=color:#24292E>$KERNEL</span><span style=color:#032F62>"</span><span style=color:#032F62> "</span><span style=color:#24292E>$KERNEL</span><span style=color:#032F62>"</span><span style=color:#24292E>; </span><span style=color:#D73A49>done</span></span>
</code></pre></div><p>重启并开启 Secure Boot，此时 shim 应当会被加载，并出现 MOK 管理界面。安装 MOK 后再次启动，shim 会加载带有签名的 GRUB，并由 GRUB 加载带有签名的内核。</p><div class=flex-wrapper><blockquote><p><strong>内核模块签名</strong></p><p>对于开启了<a target=_blank rel=noopener href=https://www.kernel.org/doc/html/v4.15/admin-guide/module-signing.html#configuring-module-signing>模块签名检验</a>（<code class="punctuation-r punctuation-l">CONFIG_MODULE_SIG</code>）的内核，在开启 Secure Boot 的平台上引导时，仅允许加载带有有效签名的模块。内核在检验模块签名时，会同时信任内核编译时使用的证书和 UEFI 提供的可信证书（包含 MOK 证书）。所以，一般来说，随内核提供的模块不需要手动进行签名（由 <code>CONFIG_MODULE_SIG_ALL</code> 控制，编译内核时自动对模块签名）。对于手动编译的内核模块，常见的实践是使用 dkms 的 <code>SIGN_TOOL</code> 选项指定一个脚本来<a target=_blank rel=noopener href=https://gist.github.com/lijikun/22be09ec9b178e745758a29c7a147cc9>实现自动签名</a>。</p><p>在 <code>CONFIG_MODULE_SIG</code> 开启的前提下，Secure Boot 被关闭时，开启选项 <code>CONFIG_MODULE_SIG_FORCE</code> 或者内核参数 <code>module.sig_enforce</code> 也可以实现仅允许加载带有有效签名的模块的功能。</p></blockquote></div><h2 id=%E9%85%8D%E7%BD%AE-tpm tabindex=-1>配置 TPM <a class=headerlink href=#%E9%85%8D%E7%BD%AE-tpm></a></h2><p>首先安装用于操作 TPM 2.0 的软件包 <code>tpm2-tools</code> 和 <code class=punctuation-r>tpm2-initramfs-tool</code>。</p><p>使用 TPM 安全地生成一个 64 字节（512 位）的密钥，以十六进制形式保存（注意设为仅 <code>root</code> 可读写）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#24292E>(</span><span style=color:#6F42C1>tpm2_getrandom</span><span style=color:#005CC5> --hex</span><span style=color:#005CC5> 32</span><span style=color:#24292E>; </span><span style=color:#6F42C1>tpm2_getrandom</span><span style=color:#005CC5> --hex</span><span style=color:#005CC5> 32</span><span style=color:#24292E>) </span><span style=color:#D73A49>></span><span style=color:#6F42C1> /luks-key</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>chmod</span><span style=color:#005CC5> 600</span><span style=color:#032F62> /luks-key</span></span>
</code></pre></div><p>将密钥添加到 LUKS 中（由于 512 位密钥包含的信息熵已经足够大，PBKDF 相关参数通过减少密钥派生函数的复杂度来提升性能）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>cryptsetup</span><span style=color:#032F62> luksAddKey</span><span style=color:#032F62> /dev/sda3</span><span style=color:#032F62> /luks-key</span><span style=color:#005CC5> --pbkdf-force-iterations=4</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>                                            --pbkdf-parallel=1</span><span style=color:#005CC5> \</span></span>
<span class=line><span style=color:#005CC5>                                            --pbkdf-memory=32</span></span>
Enter any existing passphrase:
</code></pre></div><p>将 TPM 清除（只有第一次写入时需要先清除），并将密钥写入 TPM：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>tpm2_clear</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>tpm2-initramfs-tool</span><span style=color:#032F62> seal</span><span style=color:#005CC5> --data</span><span style=color:#032F62> "$(</span><span style=color:#6F42C1>cat</span><span style=color:#032F62> /luks-key)"</span><span style=color:#005CC5> --pcrs</span><span style=color:#032F62> 0,1,2,3,4,5,6,7,8,9</span></span>
</code></pre></div><p>命令表示将密钥的文本数据写入到 TPM 中，以当前 PCR 0 - 9 的所有度量值进行认证。注意，<code class=punctuation-l>tpm2-initramfs-tool</code> 会默认将写入 TPM 的数据输出到标准输出，如果在脚本中运行，建议 <code>&gt; /dev/null</code> 以防密钥泄露到日志中。</p><p>执行完成后，即可使用 <code>unseal</code> 操作读取 TPM 中的值。在重启后，如果被选定的任一 PCR 的度量值与写入时的值不符，则读取将会失败。</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>tpm2-initramfs-tool</span><span style=color:#032F62> unseal</span><span style=color:#005CC5> --pcrs</span><span style=color:#032F62> 0,1,2,3,4,5,6,7,8,9</span></span>
</code></pre></div><h3 id=%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86 tabindex=-1>自动解密 <a class=headerlink href=#%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86></a></h3><p>要使得开机时系统能够自动从 TPM 中获取密钥并解密，我们需要将 <code>tpm2-initramfs-tool</code> 放入 <code>initrd</code> 中，并编写解密脚本。</p><p><code>/etc/crypttab</code> 提供了 <code>keyscript=</code> 选项来支持通过脚本获取解密密钥：</p><div class=flex-wrapper><pre><code><span class=line><span>lvm-encrypted UUID=72fa928c-4df7-6448-ae04-11c909ff071e none luks,discard,keyscript=/etc/initramfs-tools/tpm2-cryptsetup</span></span>
<span class=line><span></span></span></code></pre></div><p>编写 <code>/etc/initramfs-tools/tpm2-cryptsetup</code> 脚本（并添加执行权限）：</p><div class=flex-wrapper><pre><code class=language-bash><span class=line><span style=color:#6A737D>#!/bin/sh</span></span>
<span class=line></span>
<span class=line><span style=color:#6F42C1>unseal_tpm</span><span style=color:#24292E>() {</span></span>
<span class=line><span style=color:#6F42C1>    tpm2-initramfs-tool</span><span style=color:#032F62> unseal</span><span style=color:#005CC5> --pcrs</span><span style=color:#032F62> 0,1,2,3,4,5,6,7,8,9</span></span>
<span class=line><span style=color:#24292E>}</span></span>
<span class=line></span>
<span class=line><span style=color:#6F42C1>ask_password</span><span style=color:#24292E>() {</span></span>
<span class=line><span style=color:#6F42C1>    stty</span><span style=color:#005CC5> -echo</span></span>
<span class=line><span style=color:#005CC5>    echo</span><span style=color:#005CC5> -n</span><span style=color:#032F62> "Please enter the passphrase for </span><span style=color:#24292E>$CRYPTTAB_NAME</span><span style=color:#032F62> (</span><span style=color:#24292E>$CRYPTTAB_SOURCE</span><span style=color:#032F62>): "</span><span style=color:#D73A49> >&#x26;2</span></span>
<span class=line><span style=color:#005CC5>    read</span><span style=color:#032F62> pass</span></span>
<span class=line><span style=color:#005CC5>    echo</span><span style=color:#D73A49> >&#x26;2</span></span>
<span class=line><span style=color:#6F42C1>    stty</span><span style=color:#032F62> echo</span></span>
<span class=line><span style=color:#005CC5>    echo</span><span style=color:#005CC5> -n</span><span style=color:#24292E> $pass</span></span>
<span class=line><span style=color:#24292E>}</span></span>
<span class=line></span>
<span class=line><span style=color:#D73A49>if</span><span style=color:#24292E> KEY</span><span style=color:#D73A49>=</span><span style=color:#032F62>"$(</span><span style=color:#6F42C1>unseal_tpm</span><span style=color:#032F62>)"</span><span style=color:#24292E>; </span><span style=color:#D73A49>then</span></span>
<span class=line><span style=color:#005CC5>    echo</span><span style=color:#005CC5> -n</span><span style=color:#032F62> "</span><span style=color:#24292E>$KEY</span><span style=color:#032F62>"</span></span>
<span class=line><span style=color:#D73A49>else</span></span>
<span class=line><span style=color:#6F42C1>    ask_password</span></span>
<span class=line><span style=color:#D73A49>fi</span></span>
<span class=line></span></code></pre></div><p>该脚本会首先尝试从 TPM 中读取密钥，如果失败则会回退到提示用户手动输入密钥。根据 <code>keyscript</code> 的要求，密钥被输出到标准输出中。</p><p>编写一个 initramfs Hook，如 <code class=punctuation-r>/etc/initramfs-tools/hooks/tpm2-cryptsetup-setup</code>，来将 <code>tpm2-initramfs-tool</code> 工具和加密脚本加入到 intiramfs 中：</p><div class=flex-wrapper><pre><code class=language-bash><span class=line><span style=color:#005CC5>.</span><span style=color:#032F62> /usr/share/initramfs-tools/hook-functions</span></span>
<span class=line></span>
<span class=line><span style=color:#6F42C1>copy_exec</span><span style=color:#032F62> /usr/lib/x86_64-linux-gnu/libtss2-tcti-device.so.0</span></span>
<span class=line><span style=color:#6F42C1>copy_exec</span><span style=color:#032F62> /usr/bin/tpm2-initramfs-tool</span></span>
<span class=line></span></code></pre></div><p>最后执行 <code>update-initramfs -u -k all</code> 来重建 <code class=punctuation-r>initrd</code>，成功后重启，应该会先看到从 TPM 读取密钥的错误信息，再看到输入密码的提示，这是由于 <code>initrd</code> 改变使得 GRUB 写入的 PCR 9 的度量值改变，导致 TPM 拒绝输出密钥。进入系统后重新执行上述 <code>tpm2-initramfs-tool seal</code> 命令，再次重启后即可自动解密。</p><h2 id=%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0 tabindex=-1>系统更新 <a class=headerlink href=#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0></a></h2><p>当内核更新时，我们需要对新安装的内核进行签名。而对于 <code class=punctuation-r>initrd</code>，由于它的哈希值是 TPM 测量值的一部分，所以更新 <code>initrd</code> 一定会使 TPM 解锁失败。对于可以直接控制的设备，可以通过输入密码解决，而对于没有显示的服务器设备，我们可以暂时生成一个新的密钥，添加到 LUKS 中，并明文存储在硬盘上，在确保安全的情况下重启计算机，使计算机通过临时密钥解密。再次进入系统后，TPM 的测量值成为新值，此时将临时密钥从 LUKS 删除，并将原有的密钥再次存入 TPM 即可。这种方式与 BitLocker 的解决方案类似。</p><div class=flex-wrapper><blockquote><p><strong>注意</strong></p><p>当临时密钥存在时，请务必确保计算机重启过程是安全的。此时攻击者可以轻易获得明文密钥进行解密。对于开启 BitLocker 的 Windows 系统的系统更新也是如此。</p></blockquote></div><h2 id=%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC tabindex=-1>工具脚本 <a class=headerlink href=#%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC></a></h2><p>我编写了一个用于自动化处理 TPM 2 解密设置的脚本 <a target=_blank rel=noopener href=https://github.com/Menci/tpm2-luks-helper>tpm2-luks-helper</a>，具有以下功能：</p><ul><li>在更新内核时自动进行签名（通过 initramfs 的 post-update 来实现）</li><li>在更新 GRUB 时自动重新签名并安装 GRUB 到 EFI 分区（通过 APT Hook 来实现）</li><li>使用临时密钥来在更新系统后 TPM 不可用时自动解密，并通过检查内核参数 / <code>initrd</code> / GRUB EFI 是否变化来提示是否需要开启临时密钥（称之为 <code class=punctuation-r>trusted-boot</code>）</li></ul><p>将仓库下载到 <code class=punctuation-r>/opt/tpm2-luks-helper</code>（在 <code>config.sh</code> 中更改配置）并安装脚本主程序和 systemd 服务：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>git</span><span style=color:#032F62> clone</span><span style=color:#032F62> https://github.com/Menci/tpm2-luks-helper</span><span style=color:#032F62> /opt/tpm2-luks-helper</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>vim</span><span style=color:#032F62> /opt/tpm2-luks-helper/config.sh</span><span style=color:#6A737D> # 修改配置</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>ln</span><span style=color:#005CC5> -sf</span><span style=color:#032F62> /opt/tpm2-luks-helper/script.sh</span><span style=color:#032F62> /usr/local/bin/tpm2-luks-helper</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>ln</span><span style=color:#005CC5> -sf</span><span style=color:#032F62> /opt/tpm2-luks-helper/tpm2-luks-helper-on-boot.service</span><span style=color:#032F62> /etc/systemd/system/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>systemctl</span><span style=color:#032F62> enable</span><span style=color:#005CC5> --now</span><span style=color:#032F62> tpm2-luks-helper-on-boot</span></span>
</code></pre></div><p>该 systemd 服务会在开机时记录内核参数以及 <code>initrd</code> 和 GRUB EFI 的哈希值，用于判断是否需要使用临时密钥，并自动删除使用后的临时密钥。</p><p>安装 initramfs post-update 脚本，来实现自动对新内核进行签名：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>ln</span><span style=color:#005CC5> -sf</span><span style=color:#032F62> /opt/tpm2-luks-helper/initramfs/post-update-sign-kernels</span><span style=color:#032F62> /etc/initramfs/post-update.d/</span></span>
</code></pre></div><p>将 <code>/etc/crypttab</code> 中的 <code>keyscript</code> 改为仓库中的脚本，并添加 initramfs Hook（注意，仓库中的脚本增加了 <code>trusted-boot</code> 使用临时密钥解密的功能，与上述脚本不同）：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>vim</span><span style=color:#032F62> /etc/crypttab</span><span style=color:#6A737D> # 改为 keyscript=/opt/tpm2-luks-helper/initramfs/tpm2-cryptsetup</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>ln</span><span style=color:#005CC5> -sf</span><span style=color:#032F62> /opt/tpm2-luks-helper/initramfs/tpm2-cryptsetup-setup</span><span style=color:#032F62> /etc/initramfs-tools/hooks/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>update-initramfs</span><span style=color:#005CC5> -u</span><span style=color:#005CC5> -k</span><span style=color:#032F62> all</span></span>
</code></pre></div><p>安装 APT Hook，在 GRUB 更新时自动重新安装 GRUB：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>ln</span><span style=color:#005CC5> -sf</span><span style=color:#032F62> /opt/tpm2-luks-helper/grub/99update-and-sign-grub</span><span style=color:#032F62> /etc/apt/apt.conf.d/</span></span>
<span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6A737D># 执行 apt install --reinstall grub-efi-amd64-bin 来确认</span></span>
</code></pre></div><p>修改 <code class=punctuation-r>.bashrc</code>，在执行重启 / 关机命令时检查下次启动是否可以正常解密：</p><div class=flex-wrapper><pre><code class=language-bash><span class=line><span style=color:#D73A49>alias</span><span style=color:#24292E> reboot</span><span style=color:#D73A49>=</span><span style=color:#032F62>"tpm2-luks-helper check-next-boot &#x26;&#x26; reboot"</span></span>
<span class=line><span style=color:#D73A49>alias</span><span style=color:#24292E> shutdown</span><span style=color:#D73A49>=</span><span style=color:#032F62>"tpm2-luks-helper check-next-boot &#x26;&#x26; shutdown"</span></span>
<span class=line></span></code></pre></div><p>如果检查到不满足自动解密的条件，脚本会提示：</p><div class=flex-wrapper><pre><code class=language-bash-prompt><span class=hl-sh-prompt data-prompt="# "></span><span class=line><span style=color:#6F42C1>reboot</span></span>
Check failed: initramfs changed
  -   Current: &quot;/boot//initrd.img-5.15.30-2-pve:a47803f6bbe1430a3d6fb50f75002c8c&quot;
  - Next boot: &quot;/boot//initrd.img-5.15.30-2-pve:06cae583f012d98371d34f3fd379e161&quot;
Please run &quot;tpm2-luks-helper trust-next-boot&quot; and do a *attended* reboot.
</code></pre></div><p>此时运行 <code>tpm2-luks-helper trust-next-boot</code> 生成临时密钥，在下次引导时脚本将会自动从临时密钥解密。成功启动后临时密钥将被自动删除，之后继续使用 TPM 中的密钥解密。</p><h1 id=%E6%94%BB%E5%87%BB%E9%9D%A2 tabindex=-1>攻击面 <a class=headerlink href=#%E6%94%BB%E5%87%BB%E9%9D%A2></a></h1><p>一般来说，存储在 TPM 中的密钥足够安全，难以被攻击者直接获得，而 Secure Boot 和 TPM 测量的存在也使得密钥在引导过程被篡改时无法获得密钥。但在常见的设备上，仍然有一些方式可以攻击使用 TPM 的硬盘加密。</p><h2 id=%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB tabindex=-1>冷启动攻击 <a class=headerlink href=#%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB></a></h2><p>用于加解密磁盘数据的密钥往往被存储在内存中。在通常条件下，DRAM 内存中的数据会在断电后迅速消失，而在低温条件下，DRAM 内存中的数据可以保持很久。攻击者可以启动计算机，等待系统从 TPM 中读取密钥并解密，然后使用制冷剂对内存冷冻，并从外部设备引导计算机，或将冷冻的内存移动到另一台计算机上，进入特制的操作系统读取数据。</p><p>一些现代 CPU 具有<strong>内存加密</strong>功能，可以在 CPU 读写内存时透明地对 DRAM 中的数据进行加解密，以抵御冷启动攻击。在纯软件的层面上，可以通过将密钥保持在 CPU 寄存器中而不写入内存的方式来阻止攻击者从内存中取得密钥，但内存中的其他敏感信息仍然能够被取得。</p><h2 id=evil-maid-%E6%94%BB%E5%87%BB tabindex=-1>Evil Maid 攻击 <a class=headerlink href=#evil-maid-%E6%94%BB%E5%87%BB></a></h2><p>在攻击者能够在计算机拥有者者不知情时物理接触到计算机的情况下，攻击者可以对计算机进行一些修改，制作一个假的输入密码界面，欺骗拥有者 TPM 解密失败，从而诱惑拥有者输入密码解密。对于纯软件层面的修改，拥有者可以通过检查 BIOS 设置、检查 Secure Boot 证书、检查未加密部分文件来识别这种攻击行为。对于硬件层面上的修改，拥有者无法检查，但一些安全设备可以通过物理熔断的方式来检测其是否被拆卸，从来识别这种攻击。</p><h1 id=%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 tabindex=-1>参考资料 <a class=headerlink href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99></a></h1><ul><li><a target=_blank rel=noopener href=https://superuser.com/a/1417510>StackExchange: Migrating from unencrypted Ubuntu 16.04 to LUKS Encrypted install of 16.04</a>（<a target=_blank rel=noopener href=https://archive.is/wip/diu8h>存档</a>）</li><li><a target=_blank rel=noopener href=https://blastrock.github.io/fde-tpm-sb.html>Philippe Daouadi: The ultimate guide to Full Disk Encryption with TPM and Secure Boot</a>（<a target=_blank rel=noopener href=https://archive.is/1QZtK>存档</a>）</li><li><a target=_blank rel=noopener href=https://wiki.debian.org/SecureBoot>Debian Wiki: SecureBoot</a>（<a target=_blank rel=noopener href=https://archive.is/DP0KH>存档</a>）</li><li><a target=_blank rel=noopener href=https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface/Secure_Boot>ArchWiki: Unified Extensible Firmware Interface/Secure Boot</a>（<a target=_blank rel=noopener href=https://archive.md/ouOEE>存档</a>）</li><li><a target=_blank rel=noopener href=https://wiki.archlinux.org/title/Trusted_Platform_Module>ArchWiki: Trusted Platform Module</a>（<a target=_blank rel=noopener href=https://archive.is/cp5oj>存档</a>）</li><li><a target=_blank rel=noopener href=https://wiki.archlinux.org/title/Dm-crypt/Specialties>ArchWiki: dm-crypt/Specialties</a>（<a target=_blank rel=noopener href=https://archive.is/05h4j>存档</a>）</li></ul></div></div><nav class=post-pagination><a class=newer-posts href=../ipv6-slaac-relay-and-bridge/ >上一篇<br>SLAAC 环境下的 IPv6 桥接与中继 </a><span class=page-number></span> <a class=older-posts href=../backup-pve-with-pbs/ >下一篇<br>使用 Proxmox Backup Server 备份 Proxmox VE 的客户机与宿主机</a></nav><div class=post-comment-wrapper-giscus><div class=giscus></div></div></div></div><div class=single-column-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div></div><script src=//cdnjs.baoshuo.ren/ajax/libs/jquery/3.3.1/jquery.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/popper.js/1.14.4/umd/popper.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/vue/2.5.17/vue.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/smooth-scroll/14.2.1/smooth-scroll.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js crossorigin=anonymous></script><script src=//static.cdn.menci.xyz/menci-blog/js/journal.bde01167.min.js crossorigin=anonymous></script><script src=//giscus.api.menci.xyz/client.js data-repo=Menci/blog data-repo-id=R_kgDOGsK5nA data-category=Comments data-category-id=DIC_kwDOGsK5nM4CAulO data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=menci-blog data-lang=zh-CN async></script><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js?t=https%3A%2F%2Fstatic.cdn.menci.xyz%2Fmenci-blog%2F")}));</script></body></html>