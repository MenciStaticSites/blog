<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Menci&#39;s Blog</title>
  
  <subtitle>念念不忘，必有回响</subtitle>
  <link href="https://blog.men.ci/atom.xml" rel="self"/>
  
  <link href="https://blog.men.ci/"/>
  <updated>2024-12-03T06:23:57.973Z</updated>
  <id>https://blog.men.ci/</id>
  
  <author>
    <name>Menci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>被加密的移动光猫 PPPoE 密码</title>
    <link href="https://blog.men.ci/cmcc-encrypted-pppoe-password/"/>
    <id>https://blog.men.ci/cmcc-encrypted-pppoe-password/</id>
    <published>2024-11-27T16:00:00.000Z</published>
    <updated>2024-12-03T06:23:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>最近帮朋友家新装的宽带配网时，登录超级管理员 CMCCAdmin 后，发现光猫管理页面上的 PPPoE 密码是 6 个 <code>*</code> 星号 —— 好在这台光猫不需要拆机就可以开启 Telnet，不需要大动干戈地拆机拿示波器去找 TTL 了。然而高兴了没多久，登录进 Telnet 之后才发现，虽然是熟悉的 <code>pppd</code> 拨号，但配置里的拨号密码被加密了……</p><span id="more"></span><p>光猫的型号是 ZXHN F7005MV3，可以使用 <a href="https://github.com/Septrum101/zteOnu">zteOnu</a> 工具开启 Telnet：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">./zteOnu</span><span style="color:#005CC5"> --ip</span><span style="color:#032F62"> "192.168.1.1"</span><span style="color:#005CC5"> --new</span><span style="color:#005CC5"> --user</span><span style="color:#032F62"> "CMCCAdmin"</span><span style="color:#005CC5"> --pass</span><span style="color:#032F62"> "CMCCAdminXXXXXXXX"</span><span style="color:#005CC5"> --port</span><span style="color:#005CC5"> 80</span><span style="color:#005CC5"> --tp</span><span style="color:#005CC5"> 23</span></span>ZteONU dev, built at unknownsource: https://github.com/thank243/zteOnu-----------------------------------step [0] reset factory: okstep [1] request factory mode: okstep [2] send sq: okstep [3] check login auth: okstep [4] enter factory mode: ok-----------------------------------user: aaaaaaaapass: bbbbbbbb</code></pre></div><p>登录 Telnet 后，使用 <code>ps</code> 命令看到光猫使用 <code>pppd</code> 进行 PPPoE 拨号：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ps</span><span style="color:#D73A49"> |</span><span style="color:#6F42C1"> grep</span><span style="color:#032F62"> pppd</span></span> 5718  user      7568    2376  S    &lt;1&gt;  pppd 0 oe normal file /var/tmp/ppp/options.oe0 nbif1 6187  root      6276     948  S    &lt;1&gt;  grep pppd</code></pre></div><p>查看 <code>pppd</code> 的配置文件 <code class="punctuation-r">/var/tmp/ppp/options.oe0</code>（其中地址/用户名/密码已被替换为样例）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cat</span><span style="color:#032F62"> /var/tmp/ppp/options.oe0</span></span>plugin rp-pppoe.so+ipv6ipv6 ::d2dd:ffff:ffff:ffff,user 11111111111plugin passpppoe.soencrypasswd 5876a52b309edc013d37d8c857e11db1encrypasswdlen 16lcp-echo-failure 3lcp-echo-interval 10mru 1480mtu 1480dscp -1priority -1queuenum 15padi-nterval 5usepeerdns</code></pre></div><p>可见拨号密码加密为 <code>encrypasswd</code> 字段，注意到可疑的 <code>passpppoe.so</code> 插件，猜测和处理解密有关，在 <code>/lib</code> 找到了这个文件（<a href="cmcc-encrypted-pppoe-password/passpppoe.so">下载</a>），使用 curl 提取出来：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">file</span><span style="color:#032F62"> passpppoe.so</span></span>passpppoe.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, BuildID[sha1]=6bd5fa48300fa20933647df62747c97128e52e70, stripped</code></pre></div><p>使用 IDA 打开，找到 <code>plugin_init</code> 函数：</p><div class="flex-wrapper"><pre><code class="language-cpp"><span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> plugin_init</span><span style="color:#24292E">()</span></span><span class="line"><span style="color:#24292E">{</span></span><span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> result;</span><span style="color:#6A737D"> // r0</span></span><span class="line"></span><span class="line"><span style="color:#24292E">  result </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> add_options</span><span style="color:#24292E">(</span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">off_11170);</span></span><span class="line"><span style="color:#24292E">  pap_check_hook </span><span style="color:#D73A49">=</span><span style="color:#24292E"> sub_978;</span></span><span class="line"><span style="color:#24292E">  pap_passwd_hook </span><span style="color:#D73A49">=</span><span style="color:#24292E"> sub_AB0;</span></span><span class="line"><span style="color:#24292E">  chap_check_hook </span><span style="color:#D73A49">=</span><span style="color:#24292E"> sub_978;</span></span><span class="line"><span style="color:#24292E">  chap_passwd_hook </span><span style="color:#D73A49">=</span><span style="color:#24292E"> sub_AB0;</span></span><span class="line"><span style="color:#D73A49">  return</span><span style="color:#24292E"> result;</span></span><span class="line"><span style="color:#24292E">}</span></span><span class="line"></span></code></pre></div><p>解密逻辑在 <code>pap_passwd_hook</code> 和 <code>chap_passwd_hook</code> 所指向的 <code>sub_AB0</code> 函数中，对变量名进行还原后的逻辑如下：</p><div class="flex-wrapper"><pre><code class="language-cpp"><span class="line"><span style="color:#D73A49">int</span><span style="color:#D73A49"> __fastcall</span><span style="color:#6F42C1"> sub_AB0</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> a1</span><span style="color:#24292E">, </span><span style="color:#D73A49">char</span><span style="color:#D73A49"> *</span><span style="color:#E36209">result</span><span style="color:#24292E">)</span></span><span class="line"><span style="color:#24292E">{</span></span><span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> dec_len;</span><span style="color:#6A737D"> // r4</span></span><span class="line"><span style="color:#D73A49">  size_t</span><span style="color:#24292E"> s_len;</span><span style="color:#6A737D"> // r0</span></span><span class="line"><span style="color:#D73A49">  bool</span><span style="color:#24292E"> has_extra_block;</span><span style="color:#6A737D"> // zf</span></span><span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> i;</span><span style="color:#6A737D"> // r9</span></span><span class="line"><span style="color:#D73A49">  unsigned</span><span style="color:#D73A49"> int</span><span style="color:#24292E"> dec_len_;</span><span style="color:#6A737D"> // r4</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#D73A49"> *</span><span style="color:#24292E">decrypted_block;</span><span style="color:#6A737D"> // r1</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#D73A49"> *</span><span style="color:#24292E">decoded_block;</span><span style="color:#6A737D"> // r0</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#24292E"> s_sha256[</span><span style="color:#005CC5">32</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // [sp+10h] [bp-2E4h] BYREF</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#24292E"> s[</span><span style="color:#005CC5">36</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // [sp+30h] [bp-2C4h] BYREF</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#24292E"> decoded[</span><span style="color:#005CC5">196</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // [sp+54h] [bp-2A0h] BYREF</span></span><span class="line"><span style="color:#D73A49">  char</span><span style="color:#24292E"> decrypted[</span><span style="color:#005CC5">196</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // [sp+118h] [bp-1DCh] BYREF</span></span><span class="line"><span style="color:#24292E">  _BYTE aes_key[</span><span style="color:#005CC5">280</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // [sp+1DCh] [bp-118h] BYREF</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">  memset</span><span style="color:#24292E">(s, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">21</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#6F42C1">  memset</span><span style="color:#24292E">(decoded, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">C3</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#6F42C1">  memset</span><span style="color:#24292E">(decrypted, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">C3</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> ( </span><span style="color:#D73A49">!</span><span style="color:#6F42C1">memcmp</span><span style="color:#24292E">(</span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">encrypasswd, decrypted, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">C3</span><span style="color:#D73A49">u</span><span style="color:#24292E">) )</span></span><span class="line"><span style="color:#24292E">  {</span></span><span class="line"><span style="color:#6F42C1">    ProcUserLog</span><span style="color:#24292E">(</span><span style="color:#032F62">"passdecry.c"</span><span style="color:#24292E">, </span><span style="color:#005CC5">113</span><span style="color:#24292E">, </span><span style="color:#032F62">"pwdecrypt_passwd"</span><span style="color:#24292E">, </span><span style="color:#005CC5">4</span><span style="color:#24292E">, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#032F62">"the encrypasswd is NULL"</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#D73A49">    return</span><span style="color:#D73A49"> -</span><span style="color:#005CC5">1</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#24292E">  }</span></span><span class="line"><span style="color:#D73A49">  else</span></span><span class="line"><span style="color:#24292E">  {</span></span><span class="line"><span style="color:#D73A49">    if</span><span style="color:#24292E"> ( result )</span></span><span class="line"><span style="color:#24292E">    {</span></span><span class="line"><span style="color:#6F42C1">      j_HexToStr</span><span style="color:#24292E">((</span><span style="color:#D73A49">int</span><span style="color:#24292E">)</span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">encrypasswd, pass_dec_len, (</span><span style="color:#D73A49">int</span><span style="color:#24292E">)decoded);</span></span><span class="line"><span style="color:#6F42C1">      strncpy</span><span style="color:#24292E">(s, </span><span style="color:#032F62">"608158c36497b00221db14afb845c9e3"</span><span style="color:#24292E">, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">20</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#24292E">      dec_len </span><span style="color:#D73A49">=</span><span style="color:#24292E"> pass_dec_len;</span></span><span class="line"><span style="color:#6F42C1">      memset</span><span style="color:#24292E">(s_sha256, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#D73A49">sizeof</span><span style="color:#24292E">(s_sha256));</span></span><span class="line"><span style="color:#6F42C1">      memset</span><span style="color:#24292E">(aes_key, </span><span style="color:#005CC5">0</span><span style="color:#24292E">, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">F4</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#24292E">      s_len </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> strlen</span><span style="color:#24292E">(s);</span></span><span class="line"><span style="color:#6A737D">      // 密钥是上述字符串的 SHA256 值</span></span><span class="line"><span style="color:#6F42C1">      SHA256</span><span style="color:#24292E">((</span><span style="color:#D73A49">int</span><span style="color:#24292E">)s, s_len, s_sha256);</span></span><span class="line"><span style="color:#6F42C1">      AES_set_decrypt_key</span><span style="color:#24292E">((</span><span style="color:#D73A49">int</span><span style="color:#24292E">)s_sha256, </span><span style="color:#005CC5">256</span><span style="color:#24292E">, (</span><span style="color:#D73A49">int</span><span style="color:#24292E">)aes_key);</span></span><span class="line"><span style="color:#6A737D">      // AES padding 的处理</span></span><span class="line"><span style="color:#24292E">      has_extra_block </span><span style="color:#D73A49">=</span><span style="color:#24292E"> (dec_len </span><span style="color:#D73A49">&#x26;</span><span style="color:#D73A49"> 0x</span><span style="color:#005CC5">F</span><span style="color:#24292E">) </span><span style="color:#D73A49">==</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#D73A49">      if</span><span style="color:#24292E"> ( (dec_len </span><span style="color:#D73A49">&#x26;</span><span style="color:#D73A49"> 0x</span><span style="color:#005CC5">F</span><span style="color:#24292E">) </span><span style="color:#D73A49">!=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E"> )</span></span><span class="line"><span style="color:#24292E">        dec_len </span><span style="color:#D73A49">&#x26;=</span><span style="color:#D73A49"> 0x</span><span style="color:#005CC5">FFFFFFF0</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#24292E">      i </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#D73A49">      if</span><span style="color:#24292E"> ( </span><span style="color:#D73A49">!</span><span style="color:#24292E">has_extra_block )</span></span><span class="line"><span style="color:#24292E">        dec_len </span><span style="color:#D73A49">+=</span><span style="color:#005CC5"> 16</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#24292E">      dec_len_ </span><span style="color:#D73A49">=</span><span style="color:#24292E"> dec_len </span><span style="color:#D73A49">&#x26;</span><span style="color:#D73A49"> 0x</span><span style="color:#005CC5">FFFFFFF0</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#6A737D">      // AES-ECB 解密</span></span><span class="line"><span style="color:#D73A49">      while</span><span style="color:#24292E"> ( dec_len_ </span><span style="color:#D73A49">!=</span><span style="color:#24292E"> i )</span></span><span class="line"><span style="color:#24292E">      {</span></span><span class="line"><span style="color:#24292E">        decrypted_block </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> &#x26;</span><span style="color:#24292E">decrypted[i];</span></span><span class="line"><span style="color:#24292E">        decoded_block </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> &#x26;</span><span style="color:#24292E">decoded[i];</span></span><span class="line"><span style="color:#24292E">        i </span><span style="color:#D73A49">+=</span><span style="color:#005CC5"> 16</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#6F42C1">        AES_decrypt</span><span style="color:#24292E">(decoded_block, decrypted_block, aes_key);</span></span><span class="line"><span style="color:#24292E">      }</span></span><span class="line"><span style="color:#6F42C1">      strncpy</span><span style="color:#24292E">(result, decrypted, </span><span style="color:#D73A49">0x</span><span style="color:#005CC5">FF</span><span style="color:#D73A49">u</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#24292E">    }</span></span><span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span><span class="line"><span style="color:#24292E">  }</span></span><span class="line"><span style="color:#24292E">}</span></span><span class="line"></span></code></pre></div><p>可见，插件调用了 OpenSSL 进行解密，所用的加密方式是 AES-256-ECB，密钥是一段字符串的 SHA256 哈希值。由此编写出解密脚本：</p><div class="flex-wrapper"><pre><code class="language-js"><span class="line"><span style="color:#D73A49">import</span><span style="color:#24292E"> crypto </span><span style="color:#D73A49">from</span><span style="color:#032F62"> "crypto"</span><span style="color:#24292E">;</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> encrypasswd</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> Buffer.</span><span style="color:#6F42C1">from</span><span style="color:#24292E">(</span><span style="color:#032F62">"d6122e4ad26fc0c611159cfb99dc9535"</span><span style="color:#24292E">, </span><span style="color:#032F62">"hex"</span><span style="color:#24292E">); </span><span style="color:#6A737D">// 该密码为样例</span></span><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> aesKey</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> crypto.</span><span style="color:#6F42C1">createHash</span><span style="color:#24292E">(</span><span style="color:#032F62">"sha256"</span><span style="color:#24292E">).</span><span style="color:#6F42C1">update</span><span style="color:#24292E">(</span><span style="color:#032F62">"5876a52b309edc013d37d8c857e11db1"</span><span style="color:#24292E">).</span><span style="color:#6F42C1">digest</span><span style="color:#24292E">();</span></span><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> decipher</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> crypto.</span><span style="color:#6F42C1">createDecipheriv</span><span style="color:#24292E">(</span><span style="color:#032F62">"aes-256-ecb"</span><span style="color:#24292E">, aesKey, </span><span style="color:#005CC5">null</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#24292E">decipher.</span><span style="color:#6F42C1">setAutoPadding</span><span style="color:#24292E">(</span><span style="color:#005CC5">false</span><span style="color:#24292E">);</span></span><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> decrypted</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> Buffer.</span><span style="color:#6F42C1">concat</span><span style="color:#24292E">([</span></span><span class="line"><span style="color:#24292E">  decipher.</span><span style="color:#6F42C1">update</span><span style="color:#24292E">(encrypasswd),</span></span><span class="line"><span style="color:#24292E">  decipher.</span><span style="color:#6F42C1">final</span><span style="color:#24292E">()</span></span><span class="line"><span style="color:#24292E">]);</span></span><span class="line"></span><span class="line"><span style="color:#24292E">console.</span><span style="color:#6F42C1">log</span><span style="color:#24292E">(decrypted);</span></span><span class="line"><span style="color:#24292E">console.</span><span style="color:#6F42C1">log</span><span style="color:#24292E">(decrypted.</span><span style="color:#6F42C1">toString</span><span style="color:#24292E">(</span><span style="color:#032F62">"utf8"</span><span style="color:#24292E">));</span></span><span class="line"></span></code></pre></div><p>得到密码后，删除 PPPoE 和 TR069 网络，把 PPPoE 和 TR069 的 VLAN ID 桥出来，并在 LAN 口上配置 VLAN 绑定，这之后就是熟悉的配网流程了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近帮朋友家新装的宽带配网时，登录超级管理员 CMCCAdmin 后，发现光猫管理页面上的 PPPoE 密码是 6 个 &lt;code&gt;*&lt;/code&gt; 星号 —— 好在这台光猫不需要拆机就可以开启 Telnet，不需要大动干戈地拆机拿示波器去找 TTL 了。然而高兴了没多久，登录进 Telnet 之后才发现，虽然是熟悉的 &lt;code&gt;pppd&lt;/code&gt; 拨号，但配置里的拨号密码被加密了……&lt;/p&gt;</summary>
    
    
    
    
    <category term="逆向" scheme="https://blog.men.ci/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="宽带" scheme="https://blog.men.ci/tags/%E5%AE%BD%E5%B8%A6/"/>
    
    <category term="网络" scheme="https://blog.men.ci/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 是如何合并 YAML 配置的？</title>
    <link href="https://blog.men.ci/how-does-kubectl-apply-merge/"/>
    <id>https://blog.men.ci/how-does-kubectl-apply-merge/</id>
    <published>2024-10-21T16:00:00.000Z</published>
    <updated>2024-12-03T06:23:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>今天在更新一个以 StatefulSet 形式部署的服务时出现了一个诡异的问题：一个从 YAML 文件中被删掉的 <code>env</code> 环境变量，在应用 YAML 后的 StatefulSet 对象中仍然存在，导致 Pod 中的应用程序没有正常运行。</p><p>而出现问题的 StatefulSet 资源，唯一的不寻常之处是 —— 上次更新（<code class="punctuation-r punctuation-l">apply -f</code>）后进行了回滚（<code class="punctuation-r punctuation-l">rollout undo</code>）……</p><span id="more"></span><h1 id="%E5%A4%8D%E7%9B%98" tabindex="-1">复盘 <a class="headerlink" href="#%E5%A4%8D%E7%9B%98"></a></h1><p>首先，我们有一个 StatefulSet，它运行得很正常：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">apiVersion</span><span style="color:#24292E">: </span><span style="color:#032F62">apps/v1</span></span><span class="line"><span style="color:#22863A">kind</span><span style="color:#24292E">: </span><span style="color:#032F62">StatefulSet</span></span><span class="line"><span style="color:#22863A">metadata</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  name</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  labels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">spec</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  serviceName</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  replicas</span><span style="color:#24292E">: </span><span style="color:#005CC5">3</span></span><span class="line"><span style="color:#22863A">  selector</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    matchLabels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  template</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    metadata</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      labels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">    spec</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      containers</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">      - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">nginx</span></span><span class="line"><span style="color:#22863A">        image</span><span style="color:#24292E">: </span><span style="color:#032F62">nginx:latest</span></span><span class="line"><span style="color:#22863A">        env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">        - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">TO_BE_DELETED</span></span><span class="line"><span style="color:#22863A">          value</span><span style="color:#24292E">: </span><span style="color:#032F62">needs to be deleted!</span></span><span class="line"><span style="color:#24292E">        - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">ANOTHER_ENV</span></span><span class="line"><span style="color:#22863A">          value</span><span style="color:#24292E">: </span><span style="color:#032F62">who cares?</span></span><span class="line"></span></code></pre></div><p>我们想要部署一个新版，进行了一些代码改动，发了一个新的 Docker 映像，并且不再需要其中的某一个 <code class="punctuation-r">env</code>：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">apiVersion</span><span style="color:#24292E">: </span><span style="color:#032F62">apps/v1</span></span><span class="line"><span style="color:#22863A">kind</span><span style="color:#24292E">: </span><span style="color:#032F62">StatefulSet</span></span><span class="line"><span style="color:#22863A">metadata</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  name</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  labels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">spec</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  serviceName</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  replicas</span><span style="color:#24292E">: </span><span style="color:#005CC5">3</span></span><span class="line"><span style="color:#22863A">  selector</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    matchLabels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">  template</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    metadata</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      labels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        app</span><span style="color:#24292E">: </span><span style="color:#032F62">my-wonderhoy-app</span></span><span class="line"><span style="color:#22863A">    spec</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      containers</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">      - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">nginx</span></span><span class="line"><span style="color:#6A737D">        # 总之这个 image 不工作</span></span><span class="line"><span style="color:#22863A">        image</span><span style="color:#24292E">: </span><span style="color:#032F62">nginx:a-broken-version</span></span><span class="line"><span style="color:#22863A">        env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#6A737D">        # 这个被删掉了！</span></span><span class="line"><span style="color:#6A737D">        # - name: TO_BE_DELETED</span></span><span class="line"><span style="color:#6A737D">        #   value: needs to be deleted!</span></span><span class="line"><span style="color:#24292E">        - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">ANOTHER_ENV</span></span><span class="line"><span style="color:#22863A">          value</span><span style="color:#24292E">: </span><span style="color:#032F62">who cares?</span></span><span class="line"></span></code></pre></div><p>然后，我们发现这个新版的 Docker 映像不工作，于是回滚到上一个版本：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6A737D"># 列出历史版本，找到上一个工作的版本</span></span><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">kubectl</span><span style="color:#032F62"> rollout</span><span style="color:#032F62"> history</span><span style="color:#032F62"> statefulset.apps/my-wonderhoy-app</span></span>REVISION  CHANGE-CAUSE1         kubectl apply -f my-wonderhoy-app-v1.yaml2         kubectl apply -f my-wonderhoy-app-v2.yaml<span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6A737D"># 回滚到所需的版本</span></span><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">kubectl</span><span style="color:#032F62"> rollout</span><span style="color:#032F62"> undo</span><span style="color:#032F62"> statefulset.apps/my-wonderhoy-app</span><span style="color:#005CC5"> --to-revision=1</span></span>statefulset.apps/my-wonderhoy-app rolled back</code></pre></div><p>回滚后，我们的服务回到了正常工作的状态，它使用上一个版本的 Docker 映像，并且存在着被上一个版本所需要的 <code>TO_BE_DELETED</code> 变量。</p><p>而当我们修复了 Docker 映像的问题，再次部署新版时，我们发现 <code>TO_BE_DELETED</code> 这个变量并没有被删除：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">kubectl</span><span style="color:#032F62"> apply</span><span style="color:#005CC5"> -f</span><span style="color:#032F62"> my-wonderhoy-app-v3.yaml</span></span>statefulset.apps/my-wonderhoy-app configured<span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">kubectl</span><span style="color:#032F62"> get</span><span style="color:#032F62"> statefulset.apps/my-wonderhoy-app</span><span style="color:#005CC5"> -o</span><span style="color:#032F62"> jsonpath='{.spec.template.spec.containers[0].env}'</span></span>[map[name:TO_BE_DELETED value:needs to be deleted!] map[name:ANOTHER_ENV value:who cares?]]</code></pre></div><h1 id="%E5%8E%9F%E5%9B%A0" tabindex="-1">原因 <a class="headerlink" href="#%E5%8E%9F%E5%9B%A0"></a></h1><p>这个问题是由于 <code>kubectl apply</code> 的合并策略导致的。<code class="punctuation-l">kubectl apply</code> 并不是简单地用新的 YAML 文件来替换掉集群中现有资源的配置，而是会遵循一个策略来进行合并。对于 <code>env</code> 的成员，Kubernetes 认为它是一种 Key-Value 结构，会对每个 Key 计算合并后的 Value。为了进行 Kubernetes 所认为的「正确」的合并，它对每个资源维护了一个 <code>last-applied-configuration</code> 字段，记录了上次使用 <code>kubectl apply</code> 时为它应用的 YAML 配置，而在本次 <code>kubectl apply</code> 中，它的合并策略是，对于一个 Key：</p><ul><li>如果该 Key 存在于新的 YAML 配置中，那么直接使用新的 Value；</li><li>如果该 Key 不存在于新的 YAML 配置中：<ul><li>如果该 Key 存在于上次应用的 YAML 配置中，Kubernetes 会认为这个 Key 应当被删除；</li><li><strong>如果该 Key 不存在于上次应用的 YAML 配置中，Kubernetes 会认为这个 Key 是被通过 YAML 文件之外的方式被添加的，不应当被删除。</strong></li></ul></li></ul><p>这个策略在大多数情况下是没有问题的，我们（在非调试用途下）一般不会通过 YAML 文件之外的方式来修改资源，所以 <code>last-applied-configuration</code> 一般会运行中的配置一致，使得 Kubernetes 能够正确地判断出哪些 Key 需要被删除。但这次巧合的是：</p><ol><li>首先，我们应用了一次（有 Bug 的）新 YAML 文件，这时 <code>last-applied-configuration</code> 中已经没有要删除的 <code>TO_BE_DELETED</code> 这个 Key 了；</li><li>然后，我们发现 Bug 之后回滚到了上一个版本，但 <code>last-applied-configuration</code> 没有被回滚，它之中仍然没有 <code>TO_BE_DELETED</code> 这个 Key；<ul><li>此时，工作中的该资源 <code>statefulset.apps/my-wonderhoy-app</code> 的配置就与 <code>last-applied-configuration</code> 不一致了；</li></ul></li><li>最后，重新应用（修复了 Bug 的）新 YAML 文件后，Kubernetes 的合并策略会认为 <code>TO_BE_DELETED</code> 是被通过 YAML 文件之外的方式添加的，不应当被删除。</li></ol><h1 id="%E8%A7%A3%E5%86%B3" tabindex="-1">解决 <a class="headerlink" href="#%E8%A7%A3%E5%86%B3"></a></h1><p>搞明白整个问题的流程之后，它就不可怕了。要解决它，只需要手动删掉这个没有被自动删掉的 <code>env</code> 即可：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">kubectl</span><span style="color:#032F62"> edit</span><span style="color:#032F62"> statefulset.apps/my-wonderhoy-app</span><span style="color:#6A737D"> # 编辑 YAML 文件，删除掉不需要的 env</span></span>statefulset.apps/my-wonderhoy-app edited</code></pre></div><p>这个问题在一直使用 <code>kubectl apply</code> 的环境中不会出现，所以我们会误认为 <code>kubectl apply</code> 是一个简单的替换操作，但在手动修改了资源之后，就必须要考虑这个合并策略的问题了。</p><h1 id="%E5%8F%82%E8%80%83" tabindex="-1">参考 <a class="headerlink" href="#%E5%8F%82%E8%80%83"></a></h1><ul><li><a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#merging-changes-to-primitive-fields">https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#merging-changes-to-primitive-fields</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在更新一个以 StatefulSet 形式部署的服务时出现了一个诡异的问题：一个从 YAML 文件中被删掉的 &lt;code&gt;env&lt;/code&gt; 环境变量，在应用 YAML 后的 StatefulSet 对象中仍然存在，导致 Pod 中的应用程序没有正常运行。&lt;/p&gt;
&lt;p&gt;而出现问题的 StatefulSet 资源，唯一的不寻常之处是 —— 上次更新（&lt;code class=&quot;punctuation-r punctuation-l&quot;&gt;apply -f&lt;/code&gt;）后进行了回滚（&lt;code class=&quot;punctuation-r punctuation-l&quot;&gt;rollout undo&lt;/code&gt;）……&lt;/p&gt;</summary>
    
    
    
    
    <category term="SRE" scheme="https://blog.men.ci/tags/SRE/"/>
    
    <category term="云计算" scheme="https://blog.men.ci/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="Kubernetes" scheme="https://blog.men.ci/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用 Thanos 低成本构建存储于 Homelab 上的多服务 Prometheus 监控</title>
    <link href="https://blog.men.ci/thanos-low-cost-metrics-on-homelab/"/>
    <id>https://blog.men.ci/thanos-low-cost-metrics-on-homelab/</id>
    <published>2024-02-16T16:00:00.000Z</published>
    <updated>2024-12-03T06:23:58.001Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 是很常用的服务指标监控系统。通过 Prometheus，我们将线上服务暴露的指标收集存储到时序数据库中，通过 PromQL 来查询，并在 Grafana 中展示。但是，使用小型 VPS 部署的个人项目而言，要在运行业务的同时运行这样一整服务监控系统，无论是长期储存时序数据所占用的磁盘空间，还是执行 PromQL 查询所占用的 CPU 资源，都太为难一台小型 VPS 了。</p><p>而相对的，家里 Homelab 服务器上有成本低廉的存储空间和计算资源，只是难以保证在线率，对 Metrics 这种需要不间断记录数据的场景不太适合 —— 如何才能将二者相结合，在 VPS 上实时收集自身服务的指标数据，同步到 Homelab 上进行储存和查询呢？</p><span id="more"></span><h1 id="%E4%BB%8B%E7%BB%8D" tabindex="-1">介绍 <a class="headerlink" href="#%E4%BB%8B%E7%BB%8D"></a></h1><p>Thanos 是一套基于 Prometheus 的服务监控方案，它为 Prometheus 扩展了中心化查询与长期存储的能力。通过 Thanos，我们可以将一个或多个 Prometheus 收集到的指标数据同步到对象存储（如 S3 兼容的对象存储）中，并通过连接到对象储存进行全局的 PromQL 查询。Thanos 有多个微服务组件，这里我们用到 Thanos Sidecar、Thanos Store 和 Thanos Query：</p><ul><li><strong>Thanos Sidecar:</strong> 在运行 Prometheus 的主机上运行，连接对象存储，将 Prometheus 的时序数据库产生的每个块自动上传到对象存储中；</li><li><strong>Thanos Store:</strong> 连接对象存储，对对象存储中的数据进行查询；</li><li><strong>Thanos Query:</strong> 将多个 Thanos 组件作为数据源组合起来，对整体数据进行查询。</li></ul><p>每个 Thanos 组件都会同时暴露 PromQL HTTP 接口和 Thanos StoreAPI gRPC 接口，所以既可以将 Thanos 组件用 Thanos Query 进行级联，也可以将任意一个 Thanos 组件实例接入 Grafana。</p><h1 id="%E9%83%A8%E7%BD%B2" tabindex="-1">部署 <a class="headerlink" href="#%E9%83%A8%E7%BD%B2"></a></h1><p>为了降低成本，我们使用自家 Homelab 上部署的 MinIO 代替 S3 / OSS 服务作为对象存储，并同时在 Homelab 上部署 Thanos Store 和 Thanos Query 来进行查询，而将 Prometheus 和 Thanos Sidecar 部署在每个业务服务器上。为了安全，将各个服务器之间用 VPN 组成内网，将这些服务全部监听在 VPN 内网上。</p><h2 id="minio" tabindex="-1">MinIO <a class="headerlink" href="#minio"></a></h2><p>部署 MinIO 的方式不再赘述，这里只给出最简单的 Docker 部署的命令。有条件的也可以考虑把 MinIO 部署在家用 NAS 上。</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># 建立 MinIO 数据目录</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">mkdir</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> ~/minio-data</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># 假设整个监控服务的 VPN 网段是 10.0.0.0/24，部署 MinIO 的主机是 10.0.0.1</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">docker</span><span style="color:#032F62"> run</span><span style="color:#005CC5"> -d</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    -p</span><span style="color:#032F62"> 10.0.0.1:9000:9000</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    --restart=unless-stopped</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    --name</span><span style="color:#032F62"> minio</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    -v</span><span style="color:#032F62"> ~/minio-data:/data</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    -e</span><span style="color:#032F62"> "MINIO_ROOT_USER=&#x3C;MinIO AK>"</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">    -e</span><span style="color:#032F62"> "MINIO_ROOT_PASSWORD=&#x3C;MinIO SK>"</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#032F62">    quay.io/minio/minio</span><span style="color:#032F62"> server</span><span style="color:#032F62"> /data</span><span style="color:#005CC5"> --console-address</span><span style="color:#032F62"> :9001</span></span></code></pre></div><h2 id="prometheus" tabindex="-1">Prometheus <a class="headerlink" href="#prometheus"></a></h2><p>在业务服务器上安装 Prometheus，一般直接使用包管理器安装即可。安装后修改其启动参数（Ubuntu / Debian 通过 APT 安装后在 <code class="punctuation-r">/etc/default/prometheus</code>）：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#6A737D"># 在 ARGS="" 中加入以下参数：</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 因为只需要暴露给本机的 Thanos Sidecar，所以监听 127.0.0.1 即可。</span></span><span class="line"><span style="color:#032F62">--web.listen-address=127.0.0.1:9090</span></span><span class="line"><span style="color:#6A737D"># 设置一个稍长一点的存储时间，保证在 Homelab 暂时离线时不会丢失数据。</span></span><span class="line"><span style="color:#032F62">--storage.tsdb.retention.time=7d</span></span><span class="line"><span style="color:#6A737D"># 将块大小设置为 2h（Thanos Sidecar 会在每个块生成后将其上传）。</span></span><span class="line"><span style="color:#032F62">--storage.tsdb.max-block-duration=2h</span></span><span class="line"><span style="color:#032F62">--storage.tsdb.min-block-duration=2h</span></span><span class="line"><span style="color:#6A737D"># 启用一些 Thanos Sidecar 会用到的接口。</span></span><span class="line"><span style="color:#032F62">--web.enable-admin-api</span></span><span class="line"><span style="color:#032F62">--web.enable-lifecycle</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 如果安装了一些 Prometheus Exporter（如 prometheus-node-exporter），</span></span><span class="line"><span style="color:#6A737D"># 建议也将它们改为仅监听本机。</span></span><span class="line"></span></code></pre></div><p>在 Prometheus 配置中加入 <code class="punctuation-r">external_labels</code>，对来自该主机的所有数据添加标签：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">global</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  external_labels</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#6A737D">    # 用标签标明这些数据来自于哪里，注意不要和业务标签冲突。</span></span><span class="line"><span style="color:#22863A">    monitor</span><span style="color:#24292E">: </span><span style="color:#032F62">my-vps</span></span><span class="line"></span></code></pre></div><h2 id="thanos" tabindex="-1">Thanos <a class="headerlink" href="#thanos"></a></h2><p>Thanos 不在 Ubuntu 和 Debian 的官方仓库中，但在 <a href="https://github.com/cloudposse/packages">Cloud Posse 仓库</a>中有所提供。安装 Cloud Posse 的 DEB 仓库（对于其他发行版可以参考链接中的 README 进行安装）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">curl</span><span style="color:#005CC5"> -1sLf</span><span style="color:#032F62"> 'https://dl.cloudsmith.io/public/cloudposse/packages/cfg/setup/bash.deb.sh'</span><span style="color:#D73A49"> |</span><span style="color:#6F42C1"> bash</span></span></code></pre></div><p>然后 <code>apt install thanos</code> 即可安装 Thanos。但 Cloud Posse 提供的 Thanos 只有程序本身，没有 systemd 服务配置，需要自行编写。创建 <code class="punctuation-r">/etc/systemd/system/thanos@.service</code>（修改自 <a href="https://github.com/thanos-io/thanos/issues/6865#issuecomment-1869227718">thanos-io/thanos#6865</a>）：</p><div class="flex-wrapper"><pre><code class="language-ini"><span class="line"><span style="color:#6F42C1">[Unit]</span></span><span class="line"><span style="color:#D73A49">Description</span><span style="color:#24292E">=Thanos (%i)</span></span><span class="line"><span style="color:#D73A49">After</span><span style="color:#24292E">=network.target</span></span><span class="line"><span style="color:#D73A49">RequiresMountsFor</span><span style="color:#24292E">=/etc/thanos</span></span><span class="line"><span style="color:#D73A49">AssertPathExists</span><span style="color:#24292E">=/etc/thanos/%i.conf</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">[Service]</span></span><span class="line"><span style="color:#D73A49">Type</span><span style="color:#24292E">=exec</span></span><span class="line"><span style="color:#6A737D"># The following reads words from `/etc/thanos/%i.conf`, unescapes any `\`-</span></span><span class="line"><span style="color:#6A737D"># escape-sequences for `printf`’s `b`-conversion-specifier in each word and uses</span></span><span class="line"><span style="color:#6A737D"># the resulting words as arguments to Thanos.</span></span><span class="line"><span style="color:#D73A49">ExecStart</span><span style="color:#24292E">=sh -c </span><span style="color:#032F62">'name="$$1"; set --; for word in $$(grep -E -v "^[[:space:]]*(#.*)?$$" "/etc/thanos/$${name}.conf"); do set -- "$$@" "$$(printf "%%b" "$${word}")"; done; exec /usr/bin/thanos "$$@"'</span><span style="color:#032F62"> ''</span><span style="color:#24292E"> %i</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">User</span><span style="color:#24292E">=prometheus</span></span><span class="line"><span style="color:#D73A49">Group</span><span style="color:#24292E">=prometheus</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">SyslogIdentifier</span><span style="color:#24292E">=thanos@%i</span></span><span class="line"><span style="color:#D73A49">Restart</span><span style="color:#24292E">=on-failure</span></span><span class="line"><span style="color:#D73A49">RestartPreventExitStatus</span><span style="color:#24292E">=SIGINT SIGTERM</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">[Install]</span></span><span class="line"><span style="color:#D73A49">WantedBy</span><span style="color:#24292E">=multi-user.target</span></span><span class="line"></span></code></pre></div><p>注意，为了方便读取 Prometheus 的数据文件，这里直接使用了 <code>prometheus</code> 用户和组。如果没有安装 Prometheus 请注意修改。</p><h3 id="sidecar" tabindex="-1">Sidecar <a class="headerlink" href="#sidecar"></a></h3><p>在运行 Prometheus 的主机上启动 Thanos Sidecar。创建 <code class="punctuation-r">/etc/thanos/sidecar.conf</code>：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#032F62">sidecar</span></span><span class="line"><span style="color:#6A737D"># 限制只能查询最近 3h 的数据，以免 Thanos Query 将过多的查询任务</span></span><span class="line"><span style="color:#6A737D"># 分配给 Thanos Sidecar。考虑到 Thanos Sidecar 每 2h 同步一个块</span></span><span class="line"><span style="color:#6A737D"># 到 MinIO，3h 足以填充最近的时间窗口。</span></span><span class="line"><span style="color:#032F62">--min-time=-3h</span></span><span class="line"><span style="color:#6A737D"># 在 VPN 内网上暴露 Thanos StoreAPI gRPC 服务。</span></span><span class="line"><span style="color:#032F62">--grpc-address=10.0.0.2:10901</span></span><span class="line"><span style="color:#032F62">--http-address=10.0.0.2:10902</span></span><span class="line"><span style="color:#6A737D"># 指定本机的 Prometheus 端口，Thanos Store 会将查询下游的查询请求</span></span><span class="line"><span style="color:#6A737D"># 对应转发到 Prometheus 上。</span></span><span class="line"><span style="color:#032F62">--prometheus.url=http://127.0.0.1:9090</span></span><span class="line"><span style="color:#6A737D"># 指定 Prometheus 的时序数据库路径，以下为 Debian / Ubuntu APT 安装</span></span><span class="line"><span style="color:#6A737D"># 后的默认路径。</span></span><span class="line"><span style="color:#032F62">--tsdb.path=/var/lib/prometheus/metrics2/</span></span><span class="line"><span style="color:#6A737D"># 指定要上传到的对象存储，在单独的文件中配置。</span></span><span class="line"><span style="color:#032F62">--objstore.config-file=/etc/thanos/objstore.yaml</span></span><span class="line"></span></code></pre></div><p>并创建对象存储配置 <code class="punctuation-r">/etc/thanos/objstore.yaml</code>：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">type</span><span style="color:#24292E">: </span><span style="color:#032F62">S3</span></span><span class="line"><span style="color:#22863A">config</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  bucket</span><span style="color:#24292E">: </span><span style="color:#032F62">thanos</span></span><span class="line"><span style="color:#6A737D">  # 通过 VPN 连接到 Homelab 上的 MinIO。</span></span><span class="line"><span style="color:#22863A">  endpoint</span><span style="color:#24292E">: </span><span style="color:#032F62">10.0.0.1:9000</span></span><span class="line"><span style="color:#6A737D">  # `insecure` 表示使用 HTTP 而非 HTTPS。</span></span><span class="line"><span style="color:#22863A">  insecure</span><span style="color:#24292E">: </span><span style="color:#005CC5">true</span></span><span class="line"><span style="color:#22863A">  access_key</span><span style="color:#24292E">: </span><span style="color:#032F62">&#x3C;MinIO AK></span></span><span class="line"><span style="color:#22863A">  secret_key</span><span style="color:#24292E">: </span><span style="color:#032F62">&#x3C;MinIO SK></span></span><span class="line"></span></code></pre></div><p>启动 Thanos Sidecar（<code class="punctuation-r punctuation-l">systemctl enable --now thanos@sidecar</code>）后，如果一切正常，Thanos Sidecar 应当会输出：</p><div class="flex-wrapper"><pre><code class="language-plain"><span class="line"><span>ts=2024-02-14T19:06:34.414308781Z caller=sidecar.go:195 level=info msg="successfully loaded prometheus version"</span></span><span class="line"><span>ts=2024-02-14T19:06:34.415053542Z caller=sidecar.go:217 level=info msg="successfully loaded prometheus external labels" external_labels="{monitor=\"my-vps\"}"</span></span><span class="line"><span>ts=2024-02-14T19:06:36.412919439Z caller=shipper.go:263 level=warn msg="reading meta file failed, will override it" err="failed to read /var/lib/prometheus/metrics2/thanos.shipper.json: open /var/lib/prometheus/metrics2/thanos.shipper.json: no such file or directory"</span></span><span class="line"><span>ts=2024-02-14T19:06:36.504494277Z caller=shipper.go:361 level=info msg="upload new block" id=01HPM5YGK7IUD9PFK3FYSUJIN2</span></span><span class="line"><span>ts=2024-02-14T19:06:39.282504533Z caller=shipper.go:361 level=info msg="upload new block" id=01HPM9DF4JODUT9L2PA8NG4UT4</span></span><span class="line"><span></span></span></code></pre></div><p>其中 <code>reading meta file failed, will override it</code> 表示第一次启动，没有读取到上传进度文件，将会自动创建。如果又看到上传错误相关的信息，请检查对象存储是否配置正确。</p><h3 id="store" tabindex="-1">Store <a class="headerlink" href="#store"></a></h3><p>在 Homelab 上启动 Thanos Store。为了方便这里直接将 Thanos Store 与 Thanos Query 部署在一起。</p><p>创建 <code class="punctuation-r">/etc/thanos/store.conf</code>：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#032F62">store</span></span><span class="line"><span style="color:#6A737D"># 仅在本机暴露 Thanos StoreAPI gRPC 服务，供 Thanos Query 访问。</span></span><span class="line"><span style="color:#032F62">--grpc-address=localhost:10901</span></span><span class="line"><span style="color:#032F62">--http-address=localhost:10902</span></span><span class="line"><span style="color:#6A737D"># 需要注意的是，Thanos Store 本身不参与时序数据的存储，它只会连接</span></span><span class="line"><span style="color:#6A737D"># 对象存储服务进行查询，而磁盘上仅存储少量元数据。</span></span><span class="line"><span style="color:#6A737D"># 需要手动创建该目录，注意权限。</span></span><span class="line"><span style="color:#032F62">--data-dir=/var/lib/thanos</span></span><span class="line"><span style="color:#6A737D"># 指定要上传到的对象存储，在单独的文件中配置。</span></span><span class="line"><span style="color:#032F62">--objstore.config-file=/etc/thanos/objstore.yaml</span></span><span class="line"></span></code></pre></div><p>并且同样创建 <code>/etc/thanos/objstore.yaml</code> 配置文件，连接 Homelab 上的 MinIO。</p><p>启动 Thanos Sidecar（<code class="punctuation-r punctuation-l">systemctl enable --now thanos@store</code>）后，如果一切正常，Thanos Sidecar 应当会输出：</p><div class="flex-wrapper"><pre><code class="language-plain"><span class="line"><span>ts=2024-02-14T18:16:46.892043238Z caller=fetcher.go:557 level=info component=block.BaseFetcher msg="successfully synchronized block metadata" duration=7.928513ms duration_ms=7 cached=2 returned=2 partial=0</span></span><span class="line"><span>ts=2024-02-14T18:16:46.904327891Z caller=bucket.go:757 level=info msg="loaded new block" elapsed=12.215001ms id=01HPM5YGK7IUD9PFK3FYSUJIN2</span></span><span class="line"><span>ts=2024-02-14T18:16:46.904555976Z caller=bucket.go:757 level=info msg="loaded new block" elapsed=12.367995ms id=01HPM9DF4JODUT9L2PA8NG4UT4</span></span><span class="line"><span>ts=2024-02-14T18:16:46.904609028Z caller=store.go:451 level=info msg="bucket store ready" init_duration=20.501403ms</span></span><span class="line"><span>ts=2024-02-14T18:16:46.904732128Z caller=intrumentation.go:56 level=info msg="changing probe status" status=ready</span></span><span class="line"><span>ts=2024-02-14T18:16:46.904780023Z caller=grpc.go:131 level=info service=gRPC/server component=store msg="listening for serving gRPC" address=127.0.0.1:10901</span></span><span class="line"><span></span></span></code></pre></div><h3 id="query" tabindex="-1">Query <a class="headerlink" href="#query"></a></h3><p>在 Homelab 上启动 Thanos Query。创建 <code class="punctuation-r">/etc/thanos/query.conf</code>：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#032F62">query</span></span><span class="line"><span style="color:#6A737D"># 仅在本机暴露 Thanos StoreAPI gRPC 服务，供 Grafana 访问。</span></span><span class="line"><span style="color:#6A737D"># 如果需要在其他主机访问，建议使用 Nginx 进行 HTTPS 反代。</span></span><span class="line"><span style="color:#032F62">--http-address=localhost:19090</span></span><span class="line"><span style="color:#032F62">--grpc-address=localhost:10911</span></span><span class="line"><span style="color:#6A737D"># 如果需要在其他主机访问，启用 HTTP Basic Auth。</span></span><span class="line"><span style="color:#032F62">--http.config=/etc/thanos/query-http.yaml</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 指定数据源，每个 `--store` 参数是一个数据源，与各个服务的</span></span><span class="line"><span style="color:#6A737D"># `--grpc-address` 相对应。</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># Thanos Store 包含除最新一个块（2h）之外的所有历史数据。</span></span><span class="line"><span style="color:#032F62">--store=localhost:10901</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 加入各个 VPS 上的 Thanos Sidecar，以查询最新数据。</span></span><span class="line"><span style="color:#6A737D"># 因为有 `--min-time` 的限制，所以 Thanos Sidecar 和对应</span></span><span class="line"><span style="color:#6A737D"># 的 Prometheus 不会有过大的压力。</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># my-vps</span></span><span class="line"><span style="color:#032F62">--store=10.0.0.2:10901</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># my-vps-2</span></span><span class="line"><span style="color:#032F62">--store=10.0.0.3:10901</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># my-vps-3</span></span><span class="line"><span style="color:#032F62">--store=10.0.0.4:10901</span></span><span class="line"></span></code></pre></div><p>如果需要启用 HTTP Basic Auth，创建 <code class="punctuation-r">/etc/thanos/query-http.yaml</code>（密码使用 <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> 哈希后存储）：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">basic_auth_users</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  my-grafana</span><span style="color:#24292E">: </span><span style="color:#032F62">$2y$04$wSTX2UC9pGdLB.1Dl7t1eOxXuIcerYgH/qJRf2id.m60hnuKbxKHm</span></span><span class="line"></span></code></pre></div><p>最后在 Grafana 或者其他 PromQL 客户端上连接到 Thanos Query 的 HTTP 端口即可。Thanos Query 会自动根据各个 <code>--store</code> 数据源的元数据来得知他们提供的数据范围，来决定去哪些数据源查询。</p><h1 id="%E5%90%8E%E8%AE%B0" tabindex="-1">后记 <a class="headerlink" href="#%E5%90%8E%E8%AE%B0"></a></h1><p>除了使用 Thanos Sidecar 将 Prometheus 接入到 Thanos 中之外，还可以使用 Thanos Receiver 进行接入。Thanos Receiver 通过配置 Prometheus 的远程写入功能，来让 Prometheus 主动将数据推送给它，来取代主动读取 Prometheus 的时序数据库目录，这主要适用于当 Prometheus 运行在云上的托管环境，无法访问其数据目录的情况。除此之外，一般来说更推荐使用 Thanos Sidecar 进行接入。</p><p>此外，Thanos 还有一些其他组件：</p><ul><li><strong>Thanos Compactor:</strong> 对上传到对象存储中的数据进行压缩和降采样，减少空间占用；</li><li><strong>Thanos Query Frontend:</strong> 置于 Thanos Query 之前，对查询进行拆分和缓存，并能够对慢查询进行记录；</li><li><strong>Thanos Ruler:</strong> 通过预定义监控规则，自动监视 Thanos 数据源中的指标数据，当条件满足时触发告警。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Prometheus 是很常用的服务指标监控系统。通过 Prometheus，我们将线上服务暴露的指标收集存储到时序数据库中，通过 PromQL 来查询，并在 Grafana 中展示。但是，使用小型 VPS 部署的个人项目而言，要在运行业务的同时运行这样一整服务监控系统，无论是长期储存时序数据所占用的磁盘空间，还是执行 PromQL 查询所占用的 CPU 资源，都太为难一台小型 VPS 了。&lt;/p&gt;
&lt;p&gt;而相对的，家里 Homelab 服务器上有成本低廉的存储空间和计算资源，只是难以保证在线率，对 Metrics 这种需要不间断记录数据的场景不太适合 —— 如何才能将二者相结合，在 VPS 上实时收集自身服务的指标数据，同步到 Homelab 上进行储存和查询呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Homelab" scheme="https://blog.men.ci/tags/Homelab/"/>
    
    <category term="SRE" scheme="https://blog.men.ci/tags/SRE/"/>
    
    <category term="Metrics" scheme="https://blog.men.ci/tags/Metrics/"/>
    
    <category term="Thanos" scheme="https://blog.men.ci/tags/Thanos/"/>
    
    <category term="Prometheus" scheme="https://blog.men.ci/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>SLAAC 环境下的 IPv6 桥接与中继</title>
    <link href="https://blog.men.ci/ipv6-slaac-relay-and-bridge/"/>
    <id>https://blog.men.ci/ipv6-slaac-relay-and-bridge/</id>
    <published>2023-01-03T17:51:00.000Z</published>
    <updated>2024-12-03T06:23:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>IPv6 网络已经日渐普及，中国的绝大多数家庭宽带或校园网用户均可获得 IPv6 地址。对于手动组网的用户来说，可以使用与 IPv4 一样的方式，配置 IPv6 NAT 来让内网设备接入 IPv6 网络。但我们往往希望不使用 NAT，而是让内网设备可以获得全局可路由的公网 IPv6 地址。本文将从 IPv6 网络的原理入手，介绍如何配置 Linux 路由器，使得内网设备可以直接获得上层网络下发的 IPv6 地址，并同时使自定义路由与防火墙可用。</p><span id="more"></span><h1 id="%E5%8E%9F%E7%90%86" tabindex="-1">原理 <a class="headerlink" href="#%E5%8E%9F%E7%90%86"></a></h1><h2 id="slaac" tabindex="-1">SLAAC <a class="headerlink" href="#slaac"></a></h2><p>SLAAC（Stateless Address Auto-Configuration，无状态地址自动配置）是 IPv6 网络中最常见的为单一主机分配地址的方式。一般来说，IPv6 终端网络使用 <code>/64</code> 的前缀长度，并使用 SLAAC 来配置每个主机的 <code>/64</code> 后缀。主机使用其网卡 MAC 地址来生成后缀，确保地址不会冲突。</p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.8276em;vertical-align:-3.2164em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6111em;"><span style="top:-1.6659em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">prefix: </span></span><span class="mord text mtight"><span class="mord texttt mtight">/64</span></span><span class="mord text mtight"><span class="mord mtight"> network address</span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6111em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">2409:8a20:85e5:cc40</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4702em;"><span></span></span></span></span></span><span class="mord text"><span class="mord texttt">:</span></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6111em;"><span style="top:-1.152em;"><span class="pstrut" style="height:3.3592em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9417em;"><span style="top:-4.0211em;"><span class="pstrut" style="height:3.0714em;"></span><span class="mord sizing reset-size3 size6"><span class="mord text"><span class="mord">suffix: </span></span><span class="mord text"><span class="mord texttt">/64</span></span><span class="mord text"><span class="mord"> host address</span></span></span></span><span style="top:-2.2897em;"><span class="pstrut" style="height:3.0714em;"></span><span class="mord sizing reset-size3 size6"><span class="mord text"><span class="mord">(generated from MAC)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4417em;"><span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.3592em;"><span class="pstrut" style="height:3.3592em;"></span><span class="mord munder"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6111em;"><span class="svg-align" style="top:-2.352em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.548em;min-width:1.6em;"><span class="brace-left" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMinYMin slice"><path d="M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z"></path></svg></span><span class="brace-center" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMidYMin slice"><path d="M199572 214c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z"></path></svg></span><span class="brace-right" style="height:0.548em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.548em" viewBox="0 0 400000 548" preserveAspectRatio="xMaxYMin slice"><path d="M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z"></path></svg></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord texttt">0090:27ff:fe17:fc0f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.648em;"><span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2164em;"><span></span></span></span></span></span></span></span></span></span><p>这种配置方式的存在，得益于 IPv6 地址高达 128 位的地址空间。ISP 能够为每个用户网络分配 <code>/64</code> 乃至更大的地址空间，终端网络无需使用 DHCP 小心翼翼地在有限的地址池中为设备分配地址，也不需要使用 NAT 来让网络中的设备共享一个公网地址。</p><p>SLAAC 协议由两种数据包组成，它们都属于 ICMPv6：</p><ul><li><strong>Router Solicitation（路由请求）</strong>，由需要配置 IPv6 的主机发送的组播包，向网络中的路由器请求路由宣告。</li><li><strong>Router Advertisement（路由宣告）</strong>，由路由器在收到请求后发送，或配置变更时发送。包含前缀、路由、有效时长等信息，也包含 DNS 服务器地址等一些扩展。<ul><li>一些时候 SLAAC 不足以配置网络中的所有信息，仍然需要 DHCP，这种情况不是本文所介绍的重点，但可以用类似的方法解决。</li></ul></li></ul><p>主机在收到路由宣告后，会使用其中的信息来为自己配置 IPv6 地址和路由表。注意，由于 SLAAC 是无状态的，主机并不需要将选择的地址上报给路由器。</p><h2 id="ndp" tabindex="-1">NDP <a class="headerlink" href="#ndp"></a></h2><p>与 IPv4 的 ARP 协议类似，IPv6 使用 NDP（Neighbor Discovery Protocol）协议来将同一网络中其他主机的 IP 地址对应到 MAC 地址。</p><p>这个过程与 ARP 基本一致，一方发送<strong>Neighbor Solicitation（邻居请求）<strong>组播包，包含所查询的 IPv6 地址，持有该地址主机返回</strong>Neighbor Advertisement（邻居宣告）</strong>。</p><h2 id="pd" tabindex="-1">PD <a class="headerlink" href="#pd"></a></h2><p>PD（Prefix Delegation）是 DHCPv6 的一项扩展，用于 DHCP 服务器将一整段地址分配给 DHCP 客户端。这种情况一般常见于 ISP 为用户分配 IPv6 地址。在客户端获取地址时，DHCPv6 服务器（作为上级路由器）会添加一条路由，将整个被下发的网段路由到客户端。这样一来，整个地址块（一般为 <code>/64</code> 或者 <code class="punctuation-r">/60</code>）均可被客户端网络使用。</p><p>DHCPv6 客户端收到由 PD 下发的前缀后，即可通过 SLAAC 等方式为整个网络内的所有主机配置 IPv6 地址，这个过程不再需要上级路由的参与。这也是一般家用网络中最常见的 IPv6 地址分配方式。</p><h1 id="%E9%97%AE%E9%A2%98" tabindex="-1">问题 <a class="headerlink" href="#%E9%97%AE%E9%A2%98"></a></h1><div class="flex-wrapper"><blockquote><p>如果我们的路由器本身处于一个没有 DHCPv6 PD 分配的环境中，只能通过 SLAAC 从上级路由（WAN）获得单个 IPv6 地址，应该如何为网络中（LAN）的主机分配 IPv6 地址？</p></blockquote></div><p>这种情况常见于校园网环境中，不存在 PD 前缀下发，只有 SLAAC 地址分配。以及，在一些家庭宽带环境下，ISP 提供的光猫完成了 PPPoE 拨号、DHCPv6 PD 获取前缀、SLAAC 下发地址的整个过程，接入光猫（上级路由）的路由器同样无法获得前缀。</p><h2 id="%E4%B8%AD%E7%BB%A7" tabindex="-1">中继 <a class="headerlink" href="#%E4%B8%AD%E7%BB%A7"></a></h2><p>在这种情况下，除 NAT 之外，使 LAN 中的终端设备接入 IPv6 的主要思路是，假装这些设备被直接接入到 WAN 中，从 WAN 上的上级路由获得 IPv6 地址，并在 LAN 和 WAN 之间对 SLAAC 和 NDP 协议进行代理 —— <b>双向转发 SLAAC 与 NDP 包，并将源 MAC 地址改为我们的路由器的 MAC 地址。</b>在 WAN 和 LAN 中的设备看来，对方网络中的 IP 地址由我们的路由器所持有，所有流量均由我们的路由器。</p><p>这种实现思路被称为 IPv6 中继（Relay）。OpenWrt 的 <code class="punctuation-r">6relayd</code>（早期）与 <code class="punctuation-r">odhcpd</code>（目前）实现了这个功能，在一般的 Linux 路由器上，我们也可以通过抓包来手动实现它（见 <a href="https://github.com/Menci/magpie">Menci/magpie</a>），但实现较为复杂，运行效果并不好。</p><h2 id="%E7%9B%B4%E6%8E%A5%E6%A1%A5%E6%8E%A5" tabindex="-1">直接桥接 <a class="headerlink" href="#%E7%9B%B4%E6%8E%A5%E6%A1%A5%E6%8E%A5"></a></h2><p>我们可以将 IPv4 和 IPv6 视作独立的网络接口。假设我们有 WAN4、WAN6、LAN4、LAN6，将 WAN6 与 LAN6 桥接，保持 WAN4 与 LAN4 上原有的 NAT 配置。这样一来，桥接会使得 WAN 与 LAN 中主机的 IPv6 流量互通，无需关心地址分配与邻居发现上的任何问题。在 Linux 上，通过 <code>ebtables</code> 来配置：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">brctl</span><span style="color:#032F62"> addif</span><span style="color:#032F62"> br-lan</span><span style="color:#032F62"> wan</span><span style="color:#6A737D"> # 将 WAN 与 LAN 桥接</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> broute</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> BROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> !</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> -i</span><span style="color:#032F62"> wan</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> DROP</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> filter</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> OUTPUT</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> !</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-out</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -o</span><span style="color:#032F62"> wan</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> DROP</span></span></code></pre></div><p>上述命令添加了两条 <code>ebtables</code> 规则。首先在 <code>broute</code> 链上，将 <code>br-lan</code> 从 <code>wan</code> 接口进入的非 IPv6 流量全部 DROP。在 <code>broute</code> 链上 DROP 数据包并不会使得数据包被丢弃，而是会使得该数据包不经过网桥，原样发到物理接口上。这样一来，<code class="punctuation-l">wan</code> 上进入的 IPv4 流量会在 <code>wan</code> 上被收到，不影响原有的 IPv4 NAT 配置，而 IPv6 流量会经过网桥 <code>br-lan</code> 与 LAN 上的主机互通。</p><p>第二条规则在 <code>filter</code> 链上，将 <code>br-lan</code> 上要发往 <code>wan</code> 接口的非 IPv6 流量全部 DROP，这保证了 <code>br-lan</code> 上的 IPv4 数据包在泛洪时不会将 LAN 侧的 IPv4 数据包泄漏到 WAN 上。</p><p>这种做法虽然解决了 LAN 上主机接入 IPv6 的问题，但 WAN 与 LAN 之间的 IPv6 流量不会经过路由器的三层，无法为其配置路由规则和防火墙规则。</p><h2 id="%E5%9F%BA%E4%BA%8E%E6%A1%A5%E6%8E%A5%E7%9A%84%E4%B8%AD%E7%BB%A7" tabindex="-1">基于桥接的中继 <a class="headerlink" href="#%E5%9F%BA%E4%BA%8E%E6%A1%A5%E6%8E%A5%E7%9A%84%E4%B8%AD%E7%BB%A7"></a></h2><p>考虑到桥接的实现方式，内核会在 MAC 表中记录每个 MAC 地址所在的接口，在需要时进行泛洪，所以能够天然地正确转发 NDP 的 NS 与 NA 包。不考虑对数据流量的转发，桥接的机制相当于为我们实现了 NDP 中继。</p><p>与手动实现中继有一点不同，桥接会<b>直接双向转发 SLAAC 与 NDP 包，不改变包的 MAC 地址。</b>在 WAN 和 LAN 中的设备看来，他们互相可以直接在同一二层中收到对方的 ICMPv6 消息，但实际上这些数据包由我们的路由器进行转发。WAN 和 LAN 上的交换机会分别记录对方网络中设备的 MAC 地址的所属方为我们的路由器，所以，双方会认为它们在同一个网络中，而双方之间的流量则自然而然地到达了我们的路由器。<strong>而我们希望不对数据流量进行二层交换，而是在利用桥接带来的连通性的同时，让数据流量经过三层进行路由。</strong></p><p>同样地，使用 <code>ebtables</code> 来实现流量分离：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># br-lan 为上一节中桥接了 WAN 与 LAN 的网桥</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># 如果上级路由使用 DHCPv6 下发地址，同样需要将 DHCPv6 数据包跳过处理</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> nat</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> PREROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> --ip6-proto</span><span style="color:#032F62"> ipv6-icmp</span><span style="color:#005CC5"> --ip6-icmp-type</span><span style="color:#032F62"> router-solicitation</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> ACCEPT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> nat</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> PREROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> --ip6-proto</span><span style="color:#032F62"> ipv6-icmp</span><span style="color:#005CC5"> --ip6-icmp-type</span><span style="color:#032F62"> router-advertisement</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> ACCEPT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> nat</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> PREROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> --ip6-proto</span><span style="color:#032F62"> ipv6-icmp</span><span style="color:#005CC5"> --ip6-icmp-type</span><span style="color:#032F62"> neighbour-solicitation</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> ACCEPT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> nat</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> PREROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> --ip6-proto</span><span style="color:#032F62"> ipv6-icmp</span><span style="color:#005CC5"> --ip6-icmp-type</span><span style="color:#032F62"> neighbour-advertisement</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> ACCEPT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ebtables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> nat</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> PREROUTING</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> IPv6</span><span style="color:#005CC5"> --logical-in</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> redirect</span></span></code></pre></div><p>前四条规则跳过 ICMPv6 的 SLAAC 与 NDP 相关的包，让它们通过网桥，实现 SLAAC 与 NDP 的中继。最后一条规则在 <code>nat</code> 链上让进入 <code>br-lan</code> 的所有 IPv6 数据包（排除了 SLAAC 与 NDP，剩余的均为需要路由的数据流量）停止经过网桥，而是将它们的目标 MAC 地址改为 <code>br-lan</code> 的 MAC 地址，使得这些数据包在路由器上的 <code>br-lan</code> 接口上被收到。对于发往本机的包和从本机发出的包，这些规则没有影响。而对于原本目标非本机 IP 的数据包，在被本机收到后，会被三层路由机制进行转发，由于被转发的两个网络地址范围均在 <code>br-lan</code> 上，所以包会再次从 <code>br-lan</code> 发出，经过网桥的 MAC 表，自动发往正确的接口。这需要开启 IPv6 转发，并允许 <code>br-lan</code> 到 <code>br-lan</code> 的转发：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">sysctl</span><span style="color:#005CC5"> -w</span><span style="color:#032F62"> net.ipv6.conf.all.forwarding=</span><span style="color:#005CC5">1</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ip6tables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> filter</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> FORWARD</span><span style="color:#005CC5"> -i</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -o</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -j</span><span style="color:#032F62"> ACCEPT</span></span></code></pre></div><p>此时使用 <code>ip route</code> 配置额外的 IPv6 路由，它们会对来自 LAN 与 WAN 的流量生效。<br>同理 <code>ip6tables</code> 的防火墙规则也会生效。如果需要在防火墙中判断连接来自 WAN 或 LAN，可以使用 <code>physdev</code> 模块：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ip6tables</span><span style="color:#005CC5"> -t</span><span style="color:#032F62"> fitler</span><span style="color:#005CC5"> -A</span><span style="color:#032F62"> FORWARD</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">            -i</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> -o</span><span style="color:#032F62"> br-lan</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">            -m</span><span style="color:#032F62"> physdev</span><span style="color:#005CC5"> --physdev-in</span><span style="color:#032F62"> wan</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">            -p</span><span style="color:#032F62"> tcp</span><span style="color:#005CC5"> --dport</span><span style="color:#005CC5"> 80</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">            -j</span><span style="color:#032F62"> DROP</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># 注意此处不要使用 `--physdev-out lan`，因为 `--physdev-out` 有不同的含义</span></span></code></pre></div><p>即可将从 WAN 进入的目标端口为 TCP 80 的流量全部阻止，使得 WAN 中的主机无法访问 LAN 中主机的 TCP 80 端口。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;IPv6 网络已经日渐普及，中国的绝大多数家庭宽带或校园网用户均可获得 IPv6 地址。对于手动组网的用户来说，可以使用与 IPv4 一样的方式，配置 IPv6 NAT 来让内网设备接入 IPv6 网络。但我们往往希望不使用 NAT，而是让内网设备可以获得全局可路由的公网 IPv6 地址。本文将从 IPv6 网络的原理入手，介绍如何配置 Linux 路由器，使得内网设备可以直接获得上层网络下发的 IPv6 地址，并同时使自定义路由与防火墙可用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://blog.men.ci/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux" scheme="https://blog.men.ci/tags/Linux/"/>
    
    <category term="IPv6" scheme="https://blog.men.ci/tags/IPv6/"/>
    
    <category term="防火墙" scheme="https://blog.men.ci/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="路由" scheme="https://blog.men.ci/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>基于 TPM 2.0 与 Secure Boot 的 LUKS 自动解密</title>
    <link href="https://blog.men.ci/luks-with-tpm2-secure-boot/"/>
    <id>https://blog.men.ci/luks-with-tpm2-secure-boot/</id>
    <published>2022-12-02T16:27:00.000Z</published>
    <updated>2024-12-03T06:23:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>为了保护用户数据，现代设备与操作系统往往都支持全盘加密的功能，其中最为典型的是 Microsoft Windows 的 BitLocker。它既可以对系统分区进行加密，又可以在确认引导过程可信的情况下，不需要用户交互即可自动解密，这利用到了 TPM 和 Secure Boot。而在 GNU/Linux 系统下，如果用常用的 LUKS 加密方案进行全盘加密，则需要在每次开机时输入密码。</p><p>本篇文章将参考 BitLocker 的做法，利用 Secure Boot 和 TPM 2.0 来实现 LUKS 全盘加密的自动解密。</p><span id="more"></span><h1 id="%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86" tabindex="-1">前置知识 <a class="headerlink" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"></a></h1><h2 id="secure-boot" tabindex="-1">Secure Boot <a class="headerlink" href="#secure-boot"></a></h2><p>Secure Boot（安全启动）是 Microsoft 在 UEFI 中引入的一项安全功能，旨在防止恶意代码在进入操作系统之前被加载，破坏操作系统的安全。</p><p>Secure Boot 的原理是信任链，其信任根是 UEFI 中的 CA 证书，这里 CA 证书可以内置在 UEFI 固件中，也可以由机器所有者手动设置。在开启 Secure Boot 时，UEFI 固件在加载 EFI 可执行文件前，会首先检验其签名，如果其签名不是来自于 CA，则会拒绝加载。一般主板的 UEFI 固件均内置 Microsoft 的两个 CA 证书，分别为：</p><ul><li><strong>Microsoft Windows Production PCA 2011</strong>，为 Windows 引导程序签名</li><li><strong>Microsoft Corporation UEFI CA 2011</strong>，为 Linux 相关的引导程序签名</li></ul><p>Microsoft 为多个 Linux 发行版的引导程序提供了签名，如 Ubuntu、Debian 和 Fedora 等。除此之外，Microsoft 也为 PreLoader 和 shim 两个特殊的引导程序提供了签名，他们的作用是在不修改设备 CA 的情况下，让用户通过安装自己的证书来加载由用户自己签名的其他引导程序。这种证书叫做 MOK（Machine Owner Key）证书。有了 PreLoader / shim 与 MOK，用户可以方便地让系统信任用户自己的引导程序。</p><p>Secure Boot 仅提供对第一阶段引导程序的签名检验，而之后的代码检验则交给被加载的引导器，以及被引导器加载的系统内核所完成。在 Secure Boot 开启时，UEFI 会提供一个接口来获得当前设备上的可信证书列表，包含 CA 证书和（由 PreLoader / shim 管理的）MOK 证书，以便后续的检验过程使用。例如，默认情况下，GRUB 在 Secure Boot 开启时，会使用 UEFI 提供的证书列表检验其所加载的内核的代码签名。内核也可以被配置为检验其加载的 <code>.ko</code> 模块文件的签名。</p><div class="flex-wrapper"><blockquote><p><strong>提示</strong></p><p>除第一步 UEFI 固件对第一阶段引导程序的签名检验强制使用 UEFI 中的 Secure Boot CA 证书外，之后的过程如何校验均不是受 UEFI 所控制的。即使 UEFI 提供了通用的接口来允许引导程序或操作系统获得其信任的证书列表（包括 CA 和 MOK），第一阶段之后的引导程序仍然可以不使用这些证书，或者使用这些证书外加其自身信任的证书来进行代码签名检验。例如，UEFI 本身不信任 MOK，但被 UEFI 信任的 PreLoader / shim 信任 MOK，所以使用 MOK 签名的引导程序可以被 PreLoader / shim 加载。</p><p>另一个典型的例子是，Linux 内核在编译时，可以使用一个自有的证书对随内核编译的模块进行签名，并将该证书内置在编译好的内核中，自动信任这些一同编译的模块，而同时也会信任用户自行编译并使用 UEFI CA / MOK 签名的模块。</p></blockquote></div><h2 id="tpm-2.0" tabindex="-1">TPM 2.0 <a class="headerlink" href="#tpm-2.0"></a></h2><p>TPM（Trusted Platform Module，可信平台模块）是一种安全芯片，提供了硬件级别的一些安全相关的功能。TPM 可以在内部实现不受恶意软件干扰的密码学操作。早年的 TPM 一般作为独立的模块，插入到计算机主板上的专用接口上，而近年的 CPU 往往内置了 TPM 的功能（如 Intel PTT 与 AMD fTPM），不再需要独立硬件。TPM 的规范由 TCG（Trusted Computing Group，可信计算组织）制定，目前最为广泛使用的版本是 2.0。</p><p>本文中，我们主要用到 TPM 2.0 的<b>完整性测量（Integrity Measurement）</b>的功能。TPM 中定义了一些 PCR（Platform Configuration Register，平台配置寄存器），用于在系统引导过程中记录相关的配置。在 GRUB + Linux 的环境中，常用的一些 PCR 的所测量的值如下：</p><table><thead><tr><th style="text-align:center">PCR 编号</th><th style="text-align:center">测量值</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">UEFI BIOS 固件代码</td><td style="text-align:center">当升级 BIOS 固件时变化</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">UEFI BIOS 固件配置</td><td style="text-align:center">当修改 BIOS 设置时变化，改回后会恢复</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Option ROM 固件代码</td><td style="text-align:center">一些硬件设备（如 PCIe 设备）在启动时执行的代码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Option ROM 固件配置</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">UEFI 引导程序代码</td><td style="text-align:center">即引导过程中加载的 <code>.efi</code> 可执行文件<br>（由 UEFI 设置，<a href="https://github.com/rhboot/shim/blob/ea4911c2f3ce8f8f703a1476febac86bb16b00fd/shim.c#L993">shim 也会设置</a>）</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">GPT 分区表</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">S4/S5 挂起恢复状态</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">Secure Boot 配置</td><td style="text-align:center">关闭 Secure Boot 或修改 MOK 后会变化</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">GRUB 命令与内核参数</td><td style="text-align:center"><a href="https://github.com/rhboot/grub2/blob/87399901aafe63adeb88b7e58c8fea51c915e627/docs/grub.texi#L6198">由 GRUB 设置</a></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">GRUB 读取的所有文件<br>（包括 <code>vmlinuz</code> 与 <code class="punctuation-r">initrd</code>）</td><td style="text-align:center"><a href="https://github.com/rhboot/grub2/blob/87399901aafe63adeb88b7e58c8fea51c915e627/docs/grub.texi#L6198">由 GRUB 设置</a></td></tr></tbody></table><p>由于这些值均是在引导过程中由固件/引导器/操作系统的代码所设置，为了确保这些值不被篡改，TPM 所定义的唯一修改 PCR 的接口是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">PCR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Extend</span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">PCR</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">data</span></span><span class="mclose">)</span></span></span></span>，其中：</p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Extend</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">data</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">hash</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mrel">∣</span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">hash</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">data</span></span><span class="mclose">))</span></span></span></span></span><p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mrel">∣</span></span></span></span></span> 表示二进制或，哈希函数目前可选 SHA-1 与 SHA-256。这种算法使得 PCR 中的测量值的变化是不可预测且不可逆的，在可信的引导组件将测量值正确地传递给 TPM 后，恶意代码即使已知期望的 PCR 测量值，也无法将其写入 TPM，从而无法欺骗 TPM 的完整性测量。</p><p>在这样的前提下，TPM 提供了安全存储密钥的功能。操作系统可以指定一系列 PCR 寄存器的编号，令 TPM 通过这些 PCR 目前的测量值计算出检验值，并将检验值和密钥持久化存储。在之后的引导中，操作系统可以再次告知 TPM 所检验的 PCR 值列表，当 TPM 验证这些 PCR 的当前测量值的校验和与之前保存的一致时，才会向 CPU 输出密钥，否则不会输出密钥。这样一来，当攻击者植入恶意代码，或者修改固件配置，导致引导阶段的完整性被破坏时，处于安全威胁中的操作系统将无法获得密钥。</p><h2 id="luks" tabindex="-1">LUKS <a class="headerlink" href="#luks"></a></h2><p>LUKS（Linux Unified Key Setup，Linux 统一密钥设置）是 Linux 下最常用的磁盘加密方案。LUKS 基于 DM（Device Mapper，设备映射器）的 <code>dm-crypt</code> 功能，将<strong>被加密块设备</strong>解密后的内容映射为<strong>虚拟块设备</strong>，对文件系统透明。LUKS 提供了多种加密算法与密钥派生函数，目前的默认值是 <a href="https://en.wikipedia.org/wiki/Disk_encryption_theory#XEX-based_tweaked-codebook_mode_with_ciphertext_stealing_(XTS)">AES-XTS-512</a> 和 <a href="https://en.wikipedia.org/wiki/Argon2">Argon2i</a>。LUKS 有 8 个密钥槽，即可以分别设置 8 个解密密码。</p><div class="flex-wrapper"><blockquote><p><strong>密钥派生</strong></p><p>PBKDF（Password-Based Key Derivation Function，基于密码的密钥派生函数）是一种哈希函数，被用于将用户设置的便于记忆的密码转换为加密算法接受的固定长度密钥。</p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">key</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">password</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">salt</span></span><span class="mclose">)</span></span></span></span></span><p>加密算法一般接受长度为 256 或 512 位的密钥，而用户设置的密码复杂度一般在 10 个可见字符左右，包含的信息熵远低于加密算法所接受的密钥长度。如果使用一般的哈希函数（如 SHA-512），由于其计算速度较快，穷举密码的复杂度远远小于穷举密钥，将会降低整个加密系统的安全性。所以，为了抵抗穷举密码攻击，密钥派生函数往往被设计为单次计算需要消耗较多时间。于此同时，一些密钥派生函数会被设计为计算时需要占用较大的内存，来加大并行计算的难度。</p><p>当密码的信息熵足够大时（如直接使用随机生成的 512 字节密钥文件作为密码），密码与派生后密钥的穷举空间相同，此时不需要使用密钥派生函数。但在 LUKS 中无法关闭密钥派生这一步骤，只能使用相关参数降低密钥派生的计算复杂度。</p></blockquote></div><p>为了实现包括根分区在内的全盘加密，常用的各个发行版均在 <code>initrd</code> 中加入了在引导过程中进行解密的支持。<code class="punctuation-l">initrd</code> 中的脚本会解析 <code>/etc/crypttab</code> 文件，加载其中的加密分区，用户可以设置解密时要求输入密码，或通过命令读取密码。本文将会实现在引导时使用储存在 TPM 中的密钥作为密码进行解密，并同时支持输入由用户设置的密码进行解密。</p><h1 id="%E5%AE%9E%E8%B7%B5" tabindex="-1">实践 <a class="headerlink" href="#%E5%AE%9E%E8%B7%B5"></a></h1><p>本文的实践部分基于 Debian 11，其他发行版可能需要修改一些命令和软件包名称。</p><p>在进行系统外的离线操作时，推荐使用 Arch Linux 安装镜像，其中包含了大部分维护工具和 <code>arch-chroot</code> 命令。</p><div class="flex-wrapper"><blockquote><p><strong>注意</strong></p><p>由于 Arch Linux 不使用 <code>/usr/sbin</code> 目录，所以该路径不会包含在 Arch Linux 安装镜像中的默认 <code>$PATH</code> 中。所以使用 <code>chroot</code> 进入一个 Debian / Ubuntu 根文件系统后，一些命令会找不到，此时需要将该路径手动添加到 <code>$PATH</code> 中：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#24292E">PATH</span><span style="color:#D73A49">=</span><span style="color:#24292E">$PATH</span><span style="color:#032F62">:/usr/sbin</span></span></code></pre></div><p>如果目标文件系统是 ZFS，则需要安装 <a href="https://github.com/eoli3n/archiso-zfs"><code>archiso-zfs</code></a>。</p></blockquote></div><h2 id="%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E4%B8%8E%E5%8A%A0%E5%AF%86" tabindex="-1">准备分区与加密 <a class="headerlink" href="#%E5%87%86%E5%A4%87%E5%88%86%E5%8C%BA%E4%B8%8E%E5%8A%A0%E5%AF%86"></a></h2><p>在一个加密的系统上，硬盘分区分为两部分：加密的部分和未加密的部分。加密的部分的分区是可信的，而未加密的部分分区是不可信的，需要在引导过程中被检验。我们可以将硬盘分为三个分区（按顺序）：EFI 引导分区，<code class="punctuation-l">/boot</code> 分区和需要加密的数据分区（下简称数据分区），并在加密数据分区上使用 LVM（Logical volume Manager，逻辑卷管理）来管理逻辑分区。当然，LVM 不是必须的，如果不需要对加密部分进行分区，可以直接将加密空间作为一个根分区来使用。如果原本没有 EFI 分区，说明是使用 CSM 引导，此时需要参考其他教程迁移到 EFI 引导。如果原本没有 <code>/boot</code> 分区，则需要调整分区后手动创建，将原本 <code>/boot</code> 内容移动进去，并加入到 <code>/etc/fstab</code> 中。</p><div class="flex-wrapper"><blockquote><p><strong>注意</strong></p><p>一些教程会将 <code>/boot</code> 分区一并加密，这会使得配置过程更加繁琐。在我们的设置中，保持 <code>/boot</code> 未被加密并不会降低安全性，因为在调用 TPM 获取密钥进行自动解密时，TPM 会确保启动链未被篡改。而即使加密了 <code class="punctuation-r">/boot</code>，在启动链未被验证的系统上，恶意代码仍然能够被通过 EFI 注入。</p></blockquote></div><p>对于已安装的系统，我们需要将现有的数据分区备份，最简单的方式是使用 <code>dd</code> 命令复制块设备。注意 LUKS 加密会占用一部分空间用于存储元数据，所以备份原分区前需要先将其缩小，推荐的步骤是：</p><ol><li>将原分区的文件系统缩小 2 GiB（使用 <code class="punctuation-r">pvresize</code>、<code class="punctuation-r punctuation-l">btrfs filesystem resize</code>、<code class="punctuation-l">resize2fs</code> 等命令）</li><li>将原分区的分区删除，并在原位置重建，重建时大小缩小 1 GiB（使用 <code>cfdisk</code> 等管理工具）</li><li>将新分区的大小自动扩大到文件系统大小（使用第一步相同的命令，通常默认参数会自动扩大到文件系统大小）</li></ol><p>这种方式可以避免计算和在命令中填写具体大小，同时留有一定的余量，方便调整/创建 EFI 和 <code>/boot</code> 分区。</p><p>将原有的 EFI 和 <code>/boot</code> 中的数据备份（如果没有多系统引导则不需要备份 EFI 分区），并将缩小后的数据分区备份，之后对硬盘进行安全擦除，防止加密前的数据被恢复。擦除后重新建立分区表，推荐为 EFI 分配 128 MiB（如果不使用 EFISTUB），为 <code>/boot</code> 分配至少 1 GiB，剩余的空间作为加密数据分区。</p><p>假设为加密数据准备的分区是 <code class="punctuation-r">/dev/sda3</code>，执行以下命令创建 LUKS 加密分区（注意输入大写的 <code class="punctuation-r">YES</code>）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cryptsetup</span><span style="color:#032F62"> luksFormat</span><span style="color:#032F62"> /dev/sda3</span></span>WARNING!========This will overwrite data on /dev/sda3 irrevocably.Are you sure? (Type &#039;yes&#039; in capital letters): YESEnter passphrase for /dev/sda3:Verify passphrase:</code></pre></div><p>创建加密分区后，将加密分区打开。打开加密分区时需要指定一个名称。成功打开后，系统将在 <code>/dev/mapper/</code> 下创建解密后的块设备，例如指定名称为 <code class="punctuation-r">lvm-encrypted</code>：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cryptsetup</span><span style="color:#032F62"> open</span><span style="color:#032F62"> /dev/sda3</span><span style="color:#032F62"> lvm-encrypted</span></span>Enter passphrase for /dev/sda3:</code></pre></div><div class="flex-wrapper"><blockquote><p><strong>提示</strong></p><p>为了提高加密后 SSD 的 I/O 性能，可以<a href="https://wiki.archlinux.org/title/Dm-crypt/Specialties#Disable_workqueue_for_increased_solid_state_drive_(SSD)_performance">禁用工作队列</a>，执行以下命令（选项将保存在 LUKS 元数据中）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cryptsetup</span><span style="color:#005CC5"> --perf-no_read_workqueue</span><span style="color:#005CC5"> --perf-no_write_workqueue</span><span style="color:#005CC5"> --persistent</span><span style="color:#032F62"> refresh</span><span style="color:#032F62"> lvm-encrypted</span></span></code></pre></div></blockquote></div><p>将备份好的数据分区使用 <code>dd</code> 恢复到该块设备中：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">dd</span><span style="color:#032F62"> if=/path/to/backup/drive/bak.img</span><span style="color:#032F62"> of=/dev/mapper/lvm-encrypted</span><span style="color:#032F62"> status=progress</span><span style="color:#032F62"> bs=128M</span></span></code></pre></div><p>此时，对于 LVM，可以使用 <code>vgscan</code> 命令识别原有的卷组，并使用 <code>vgchange -ay &lt;vgname&gt;</code> 激活。</p><p>由于我们缩减文件系统时留下了较大的空闲空间，此时可以将文件系统大小调整到到 LUKS 创建的块设备的大小上限。同理使用 <code class="punctuation-r">pvresize</code>、<code class="punctuation-r punctuation-l">btrfs filesystem resize</code>、<code class="punctuation-l">resize2fs</code> 等命令即可完成。</p><p>将根文件系统挂载。如果 <code>/boot</code> 分区是新创建的，需要从原有的根分区中将原有的文件移动过去。重新创建的 EFI 和 <code>/boot</code> 分区的 UUID 会与原有的不同，需要添加或者修改 <code>/etc/fstab</code> 中的条目。最简单的方式是将 <code>/mnt/boot</code> 和 <code>/mnt/boot/efi</code> 挂载后，使用 <code>genfstab -U /mnt</code> 命令生成（对于加密分区或者 LVM 分区，建议不使用 UUID，而是使用 <code>/dev/mapper/&lt;name&gt;</code> 挂载）。</p><p>之后执行 <code class="punctuation-r">arch-chroot /mnt</code>，进入加密系统的根文件系统中执行。要使得加密后的系统能够正常引导，需要告知系统在 <code>initrd</code> 中打开加密分区。在根文件系统中创建 <code>/etc/crypttab</code> 文件：</p><div class="flex-wrapper"><pre><code><span class="line"><span>lvm-encrypted UUID=72fa928c-4df7-6448-ae04-11c909ff071e none luks,discard</span></span><span class="line"><span></span></span></code></pre></div><p>文件的每一行共有四列，分别表示名称、块设备（请将 UUID 替换为加密分区的文件系统 UUID）、密钥文件（<code class="punctuation-l">none</code> 表示不使用固定的密钥解密）和选项。选项中的 <code>discard</code> 表示<a href="https://wiki.archlinux.org/title/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)">启用 SSD TRIM</a>，启用后可能会导致一些测信道信息泄露，例如其中文件系统的类型和用量可能能够被从被丢弃块的特征中推算出来，但这通常不被认为是一个安全威胁。</p><div class="flex-wrapper"><blockquote><p><strong>ZFS 注意事项</strong></p><p>在构建 <code>initrd</code> 时，<code class="punctuation-l">cryptsetup</code> 的脚本会通过 <code>/proc/mounts</code> 中的信息判断当前系统的根目录属于哪一个加密块设备，进而将对应的 <code>/etc/crypttab</code> 条目放入 <code>initrd</code> 中，在引导时进行解密。但由于 ZFS 根目录不是通过块设备挂载的，所以 <code>update-initramfs</code> 会提示找不到根目录所对应的加密设备条目。</p><p>此时需要手动在 <code>/etc/crypttab</code> 的对应条目中加入 <code>initramfs</code> 选项，将其指定为在引导时进行解密（即改为 <code class="punctuation-r">luks,initramfs,discard</code>）。</p></blockquote></div><p>如果 <code>cryptsetup</code> 命令不存在，则需要手动安装 <code>cryptsetup</code> 包，否则直接运行 <code>update-initramfs -u -k all</code> 重建 <code>initrd</code> 即可。</p><p>如果原有的引导方式为 EFI GRUB，则此时重建 GRUB 后即可正常引导原有系统，系统会在开机时提示输入密码解密 LUKS 分区。接下来的步骤可以在 <code>chroot</code> 中完成，也可以在成功引导的系统中完成。</p><h2 id="%E9%85%8D%E7%BD%AE-secure-boot" tabindex="-1">配置 Secure Boot <a class="headerlink" href="#%E9%85%8D%E7%BD%AE-secure-boot"></a></h2><p>首先，安装 <code class="punctuation-r">shim-signed</code>，<code class="punctuation-l">sbsigntool</code> 和 <code>mokutil</code> 包，前者包含带有 Microsoft 签名的 shim 二进制文件，后两者是用于签名和管理设备上的 MOK 证书。</p><h3 id="%E7%94%9F%E6%88%90-mok-%E8%AF%81%E4%B9%A6" tabindex="-1">生成 MOK 证书 <a class="headerlink" href="#%E7%94%9F%E6%88%90-mok-%E8%AF%81%E4%B9%A6"></a></h3><p>创建一个目录，为安全起见设为仅 root 可访问，使用 <code>openssl</code> 命令生成自签名 MOK 的证书与私钥（其中 <code>CN=</code> 之后的名字可以自定义）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">mkdir</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> /var/lib/shim-signed/mok/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">chmod</span><span style="color:#005CC5"> 700</span><span style="color:#032F62"> /var/lib/shim-signed/mok/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#005CC5">cd</span><span style="color:#032F62"> /var/lib/shim-signed/mok/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">openssl</span><span style="color:#032F62"> req</span><span style="color:#005CC5"> -nodes</span><span style="color:#005CC5"> -new</span><span style="color:#005CC5"> -x509</span><span style="color:#005CC5"> -newkey</span><span style="color:#032F62"> rsa:2048</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">              -keyout</span><span style="color:#032F62"> MOK.key</span><span style="color:#005CC5"> -outform</span><span style="color:#032F62"> DER</span><span style="color:#005CC5"> -out</span><span style="color:#032F62"> MOK.der</span><span style="color:#005CC5"> -days</span><span style="color:#005CC5"> 36500</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">              -subj</span><span style="color:#032F62"> "/CN=My Secure Boot MOK/"</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">openssl</span><span style="color:#032F62"> x509</span><span style="color:#005CC5"> -inform</span><span style="color:#032F62"> der</span><span style="color:#005CC5"> -in</span><span style="color:#032F62"> MOK.der</span><span style="color:#005CC5"> -out</span><span style="color:#032F62"> MOK.pem</span></span></code></pre></div><p>上述命令生成了 DER 格式的证书，以及 PEM 格式的私钥和证书，因为 <code>mokutil</code> 需要 DER 格式，而 <code>sbsign</code> 需要 PEM 格式。</p><p>使用 <code>mokutil</code> 请求将 MOK 证书导入到系统 PKI 中，这里需要设置一个一次性的密码，以便于 shim 在启动时能够验证证书是由可信的管理员所请求添加的（注意，只有在 shim 被加载时，MOK 与 MOK 安装请求才会生效）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">mokutil</span><span style="color:#005CC5"> --import</span><span style="color:#032F62"> MOK.der</span></span>input password:input password again:</code></pre></div><h3 id="%E5%AE%89%E8%A3%85-shim" tabindex="-1">安装 shim <a class="headerlink" href="#%E5%AE%89%E8%A3%85-shim"></a></h3><p>将 shim 安装到 EFI 分区中：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">rm</span><span style="color:#005CC5"> -rf</span><span style="color:#032F62"> /boot/efi/EFI/BOOT</span><span style="color:#24292E"> &#x26;&#x26; </span><span style="color:#6F42C1">mkdir</span><span style="color:#005CC5"> -p</span><span style="color:#032F62"> /boot/efi/EFI/BOOT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cp</span><span style="color:#032F62"> /usr/lib/shim/shimx64.efi.signed</span><span style="color:#032F62"> /boot/efi/EFI/BOOT/BOOTx64.EFI</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cp</span><span style="color:#032F62"> /usr/lib/shim/mmx64.efi.signed</span><span style="color:#032F62"> /boot/efi/EFI/BOOT/mmx64.efi</span></span></code></pre></div><p>为 shim 创建 EFI 引导条目，并设为默认（假设 EFI 分区是 <code class="punctuation-r">/dev/sda1</code>）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">efibootmgr</span><span style="color:#005CC5"> --unicode</span><span style="color:#005CC5"> --disk</span><span style="color:#032F62"> /dev/sda</span><span style="color:#005CC5"> --part</span><span style="color:#005CC5"> 1</span><span style="color:#005CC5"> --create</span><span style="color:#005CC5"> --label</span><span style="color:#032F62"> "Shim"</span><span style="color:#005CC5"> --loader</span><span style="color:#032F62"> /EFI/BOOT/BOOTx64.EFI</span></span></code></pre></div><p>此时，开机时将首先加载 <code class="punctuation-r">BOOTx64.EFI</code>，该文件是 shim 的主程序，它会检测是否有 MOK 安装请求，如果是则会调用 MOK 管理界面 <code>mmx64.efi</code> 进行处理，否则会<a href="https://github.com/rhboot/shim/blob/6402f1fec4c9b19f8d570791827b13b9cad98827/BUILDING#L23">默认引导 <code>grubx64.efi</code> 程序</a>。接下来我们需要安装 GRUB 到 <code class="punctuation-r">grubx64.efi</code>，来让 shim 能够找到它。</p><h3 id="%E7%AD%BE%E5%90%8D%E5%B9%B6%E5%AE%89%E8%A3%85-grub" tabindex="-1">签名并安装 GRUB <a class="headerlink" href="#%E7%AD%BE%E5%90%8D%E5%B9%B6%E5%AE%89%E8%A3%85-grub"></a></h3><p>如果没有安装 GRUB（或未安装 EFI 版的 GRUB），需要先安装。Debian 下的包名为 <code class="punctuation-r">grub-efi-amd64-bin</code>。</p><p>由于在 Secure Boot 开启时，GRUB 不允加载文件系统上的任何模块，所以所有需要的模块都要被打包进 <code>grubx64.efi</code> 中。Ubuntu 提供了一个<a href="https://git.launchpad.net/~ubuntu-core-dev/grub/+git/ubuntu/tree/debian/build-efi-images?h=debian/2.06-2ubuntu12">列表</a>，默认情况下，将列表中的模块全部加入即可（找不到的模块可以删除）。假设 GRUB 模块列表在 <code>GRUB_MODULES</code> 环境变量中。</p><p>另一方面，shim 要求其加载的 EFI 程序具有 <a href="https://github.com/rhboot/shim/blob/main/SBAT.md">SBAT 段</a>。GRUB 安装器可以在生成 EFI 程序时直接指定 SBAT 文件，创建 <code>/tmp/sbat.csv</code> 保存为以下内容：</p><div class="flex-wrapper"><pre><code class="language-csv"><span class="line"><span style="color:#24292E">sbat,</span><span style="color:#D73A49">1,</span><span style="color:#6F42C1">SBAT Version,</span><span style="color:#6A737D">sbat,</span><span style="color:#032F62">1,</span><span style="color:#E36209">https://github.com/rhboot/shim/blob/main/SBAT.md</span></span><span class="line"><span style="color:#24292E">grub,</span><span style="color:#D73A49">1,</span><span style="color:#6F42C1">Free Software Foundation,</span><span style="color:#6A737D">grub,</span><span style="color:#032F62">2.04,</span><span style="color:#E36209">https://www.gnu.org/software/grub/</span></span><span class="line"></span></code></pre></div><p>然后安装 GRUB 到目标位置（安装时不需要修改 EFI 设置）并使用 <code>sbsign</code> 对其进行签名：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">grub-install</span><span style="color:#005CC5"> --efi-directory=/boot/efi/</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --sbat=/tmp/sbat.csv</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --modules=</span><span style="color:#032F62">"</span><span style="color:#24292E">$GRUB_MODULES</span><span style="color:#032F62">"</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --no-nvram</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --no-bootsector</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --no-uefi-secure-boot</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">               --bootloader-id=BOOT</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">update-grub</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">sbsign</span><span style="color:#005CC5"> --key</span><span style="color:#032F62"> MOK.key</span><span style="color:#005CC5"> --cert</span><span style="color:#032F62"> MOK.pem</span><span style="color:#005CC5"> --output</span><span style="color:#032F62"> /boot/efi/EFI/BOOT/grubx64.efi</span><span style="color:#032F62"> /boot/efi/EFI/BOOT/grubx64.efi</span></span></code></pre></div><h3 id="%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8" tabindex="-1">签名内核 <a class="headerlink" href="#%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8"></a></h3><p>由于 GRUB 也会验证内核的签名，我们同样也需要对内核进行签名：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#D73A49">for</span><span style="color:#24292E"> KERNEL </span><span style="color:#D73A49">in</span><span style="color:#032F62"> /boot/vmlinuz*</span><span style="color:#24292E">; </span><span style="color:#D73A49">do</span><span style="color:#6F42C1"> sbsign</span><span style="color:#005CC5"> --key</span><span style="color:#032F62"> MOK.key</span><span style="color:#005CC5"> --cert</span><span style="color:#032F62"> MOK.pem</span><span style="color:#005CC5"> --output</span><span style="color:#032F62"> "</span><span style="color:#24292E">$KERNEL</span><span style="color:#032F62">"</span><span style="color:#032F62"> "</span><span style="color:#24292E">$KERNEL</span><span style="color:#032F62">"</span><span style="color:#24292E">; </span><span style="color:#D73A49">done</span></span></code></pre></div><p>重启并开启 Secure Boot，此时 shim 应当会被加载，并出现 MOK 管理界面。安装 MOK 后再次启动，shim 会加载带有签名的 GRUB，并由 GRUB 加载带有签名的内核。</p><div class="flex-wrapper"><blockquote><p><strong>内核模块签名</strong></p><p>对于开启了<a href="https://www.kernel.org/doc/html/v4.15/admin-guide/module-signing.html#configuring-module-signing">模块签名检验</a>（<code class="punctuation-r punctuation-l">CONFIG_MODULE_SIG</code>）的内核，在开启 Secure Boot 的平台上引导时，仅允许加载带有有效签名的模块。内核在检验模块签名时，会同时信任内核编译时使用的证书和 UEFI 提供的可信证书（包含 MOK 证书）。所以，一般来说，随内核提供的模块不需要手动进行签名（由 <code>CONFIG_MODULE_SIG_ALL</code> 控制，编译内核时自动对模块签名）。对于手动编译的内核模块，常见的实践是使用 dkms 的 <code>SIGN_TOOL</code> 选项指定一个脚本来<a href="https://gist.github.com/lijikun/22be09ec9b178e745758a29c7a147cc9">实现自动签名</a>。</p><p>在 <code>CONFIG_MODULE_SIG</code> 开启的前提下，Secure Boot 被关闭时，开启选项 <code>CONFIG_MODULE_SIG_FORCE</code> 或者内核参数 <code>module.sig_enforce</code> 也可以实现仅允许加载带有有效签名的模块的功能。</p></blockquote></div><h2 id="%E9%85%8D%E7%BD%AE-tpm" tabindex="-1">配置 TPM <a class="headerlink" href="#%E9%85%8D%E7%BD%AE-tpm"></a></h2><p>首先安装用于操作 TPM 2.0 的软件包 <code>tpm2-tools</code> 和 <code class="punctuation-r">tpm2-initramfs-tool</code>。</p><p>使用 TPM 安全地生成一个 64 字节（512 位）的密钥，以十六进制形式保存（注意设为仅 <code>root</code> 可读写）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#24292E">(</span><span style="color:#6F42C1">tpm2_getrandom</span><span style="color:#005CC5"> --hex</span><span style="color:#005CC5"> 32</span><span style="color:#24292E">; </span><span style="color:#6F42C1">tpm2_getrandom</span><span style="color:#005CC5"> --hex</span><span style="color:#005CC5"> 32</span><span style="color:#24292E">) </span><span style="color:#D73A49">></span><span style="color:#6F42C1"> /luks-key</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">chmod</span><span style="color:#005CC5"> 600</span><span style="color:#032F62"> /luks-key</span></span></code></pre></div><p>将密钥添加到 LUKS 中（由于 512 位密钥包含的信息熵已经足够大，PBKDF 相关参数通过减少密钥派生函数的复杂度来提升性能）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">cryptsetup</span><span style="color:#032F62"> luksAddKey</span><span style="color:#032F62"> /dev/sda3</span><span style="color:#032F62"> /luks-key</span><span style="color:#005CC5"> --pbkdf-force-iterations=4</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">                                            --pbkdf-parallel=1</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">                                            --pbkdf-memory=32</span></span>Enter any existing passphrase:</code></pre></div><p>将 TPM 清除（只有第一次写入时需要先清除），并将密钥写入 TPM：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">tpm2_clear</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">tpm2-initramfs-tool</span><span style="color:#032F62"> seal</span><span style="color:#005CC5"> --data</span><span style="color:#032F62"> "$(</span><span style="color:#6F42C1">cat</span><span style="color:#032F62"> /luks-key)"</span><span style="color:#005CC5"> --pcrs</span><span style="color:#032F62"> 0,1,2,3,4,5,6,7,8,9</span></span></code></pre></div><p>命令表示将密钥的文本数据写入到 TPM 中，以当前 PCR 0 - 9 的所有度量值进行认证。注意，<code class="punctuation-l">tpm2-initramfs-tool</code> 会默认将写入 TPM 的数据输出到标准输出，如果在脚本中运行，建议 <code>&gt; /dev/null</code> 以防密钥泄露到日志中。</p><p>执行完成后，即可使用 <code>unseal</code> 操作读取 TPM 中的值。在重启后，如果被选定的任一 PCR 的度量值与写入时的值不符，则读取将会失败。</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">tpm2-initramfs-tool</span><span style="color:#032F62"> unseal</span><span style="color:#005CC5"> --pcrs</span><span style="color:#032F62"> 0,1,2,3,4,5,6,7,8,9</span></span></code></pre></div><h3 id="%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86" tabindex="-1">自动解密 <a class="headerlink" href="#%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%AF%86"></a></h3><p>要使得开机时系统能够自动从 TPM 中获取密钥并解密，我们需要将 <code>tpm2-initramfs-tool</code> 放入 <code>initrd</code> 中，并编写解密脚本。</p><p><code>/etc/crypttab</code> 提供了 <code>keyscript=</code> 选项来支持通过脚本获取解密密钥：</p><div class="flex-wrapper"><pre><code><span class="line"><span>lvm-encrypted UUID=72fa928c-4df7-6448-ae04-11c909ff071e none luks,discard,keyscript=/etc/initramfs-tools/tpm2-cryptsetup</span></span><span class="line"><span></span></span></code></pre></div><p>编写 <code>/etc/initramfs-tools/tpm2-cryptsetup</code> 脚本（并添加执行权限）：</p><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#6A737D">#!/bin/sh</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">unseal_tpm</span><span style="color:#24292E">() {</span></span><span class="line"><span style="color:#6F42C1">    tpm2-initramfs-tool</span><span style="color:#032F62"> unseal</span><span style="color:#005CC5"> --pcrs</span><span style="color:#032F62"> 0,1,2,3,4,5,6,7,8,9</span></span><span class="line"><span style="color:#24292E">}</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">ask_password</span><span style="color:#24292E">() {</span></span><span class="line"><span style="color:#6F42C1">    stty</span><span style="color:#005CC5"> -echo</span></span><span class="line"><span style="color:#005CC5">    echo</span><span style="color:#005CC5"> -n</span><span style="color:#032F62"> "Please enter the passphrase for </span><span style="color:#24292E">$CRYPTTAB_NAME</span><span style="color:#032F62"> (</span><span style="color:#24292E">$CRYPTTAB_SOURCE</span><span style="color:#032F62">): "</span><span style="color:#D73A49"> >&#x26;2</span></span><span class="line"><span style="color:#005CC5">    read</span><span style="color:#032F62"> pass</span></span><span class="line"><span style="color:#005CC5">    echo</span><span style="color:#D73A49"> >&#x26;2</span></span><span class="line"><span style="color:#6F42C1">    stty</span><span style="color:#032F62"> echo</span></span><span class="line"><span style="color:#005CC5">    echo</span><span style="color:#005CC5"> -n</span><span style="color:#24292E"> $pass</span></span><span class="line"><span style="color:#24292E">}</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">if</span><span style="color:#24292E"> KEY</span><span style="color:#D73A49">=</span><span style="color:#032F62">"$(</span><span style="color:#6F42C1">unseal_tpm</span><span style="color:#032F62">)"</span><span style="color:#24292E">; </span><span style="color:#D73A49">then</span></span><span class="line"><span style="color:#005CC5">    echo</span><span style="color:#005CC5"> -n</span><span style="color:#032F62"> "</span><span style="color:#24292E">$KEY</span><span style="color:#032F62">"</span></span><span class="line"><span style="color:#D73A49">else</span></span><span class="line"><span style="color:#6F42C1">    ask_password</span></span><span class="line"><span style="color:#D73A49">fi</span></span><span class="line"></span></code></pre></div><p>该脚本会首先尝试从 TPM 中读取密钥，如果失败则会回退到提示用户手动输入密钥。根据 <code>keyscript</code> 的要求，密钥被输出到标准输出中。</p><p>编写一个 initramfs Hook，如 <code class="punctuation-r">/etc/initramfs-tools/hooks/tpm2-cryptsetup-setup</code>，来将 <code>tpm2-initramfs-tool</code> 工具和加密脚本加入到 intiramfs 中：</p><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#005CC5">.</span><span style="color:#032F62"> /usr/share/initramfs-tools/hook-functions</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">copy_exec</span><span style="color:#032F62"> /usr/lib/x86_64-linux-gnu/libtss2-tcti-device.so.0</span></span><span class="line"><span style="color:#6F42C1">copy_exec</span><span style="color:#032F62"> /usr/bin/tpm2-initramfs-tool</span></span><span class="line"></span></code></pre></div><p>最后执行 <code>update-initramfs -u -k all</code> 来重建 <code class="punctuation-r">initrd</code>，成功后重启，应该会先看到从 TPM 读取密钥的错误信息，再看到输入密码的提示，这是由于 <code>initrd</code> 改变使得 GRUB 写入的 PCR 9 的度量值改变，导致 TPM 拒绝输出密钥。进入系统后重新执行上述 <code>tpm2-initramfs-tool seal</code> 命令，再次重启后即可自动解密。</p><h2 id="%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0" tabindex="-1">系统更新 <a class="headerlink" href="#%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0"></a></h2><p>当内核更新时，我们需要对新安装的内核进行签名。而对于 <code class="punctuation-r">initrd</code>，由于它的哈希值是 TPM 测量值的一部分，所以更新 <code>initrd</code> 一定会使 TPM 解锁失败。对于可以直接控制的设备，可以通过输入密码解决，而对于没有显示的服务器设备，我们可以暂时生成一个新的密钥，添加到 LUKS 中，并明文存储在硬盘上，在确保安全的情况下重启计算机，使计算机通过临时密钥解密。再次进入系统后，TPM 的测量值成为新值，此时将临时密钥从 LUKS 删除，并将原有的密钥再次存入 TPM 即可。这种方式与 BitLocker 的解决方案类似。</p><div class="flex-wrapper"><blockquote><p><strong>注意</strong></p><p>当临时密钥存在时，请务必确保计算机重启过程是安全的。此时攻击者可以轻易获得明文密钥进行解密。对于开启 BitLocker 的 Windows 系统的系统更新也是如此。</p></blockquote></div><h2 id="%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC" tabindex="-1">工具脚本 <a class="headerlink" href="#%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC"></a></h2><p>我编写了一个用于自动化处理 TPM 2 解密设置的脚本 <a href="https://github.com/Menci/tpm2-luks-helper">tpm2-luks-helper</a>，具有以下功能：</p><ul><li>在更新内核时自动进行签名（通过 initramfs 的 post-update 来实现）</li><li>在更新 GRUB 时自动重新签名并安装 GRUB 到 EFI 分区（通过 APT Hook 来实现）</li><li>使用临时密钥来在更新系统后 TPM 不可用时自动解密，并通过检查内核参数 / <code>initrd</code> / GRUB EFI 是否变化来提示是否需要开启临时密钥（称之为 <code class="punctuation-r">trusted-boot</code>）</li></ul><p>将仓库下载到 <code class="punctuation-r">/opt/tpm2-luks-helper</code>（在 <code>config.sh</code> 中更改配置）并安装脚本主程序和 systemd 服务：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">git</span><span style="color:#032F62"> clone</span><span style="color:#032F62"> https://github.com/Menci/tpm2-luks-helper</span><span style="color:#032F62"> /opt/tpm2-luks-helper</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">vim</span><span style="color:#032F62"> /opt/tpm2-luks-helper/config.sh</span><span style="color:#6A737D"> # 修改配置</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /opt/tpm2-luks-helper/script.sh</span><span style="color:#032F62"> /usr/local/bin/tpm2-luks-helper</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /opt/tpm2-luks-helper/tpm2-luks-helper-on-boot.service</span><span style="color:#032F62"> /etc/systemd/system/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">systemctl</span><span style="color:#032F62"> enable</span><span style="color:#005CC5"> --now</span><span style="color:#032F62"> tpm2-luks-helper-on-boot</span></span></code></pre></div><p>该 systemd 服务会在开机时记录内核参数以及 <code>initrd</code> 和 GRUB EFI 的哈希值，用于判断是否需要使用临时密钥，并自动删除使用后的临时密钥。</p><p>安装 initramfs post-update 脚本，来实现自动对新内核进行签名：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /opt/tpm2-luks-helper/initramfs/post-update-sign-kernels</span><span style="color:#032F62"> /etc/initramfs/post-update.d/</span></span></code></pre></div><p>将 <code>/etc/crypttab</code> 中的 <code>keyscript</code> 改为仓库中的脚本，并添加 initramfs Hook（注意，仓库中的脚本增加了 <code>trusted-boot</code> 使用临时密钥解密的功能，与上述脚本不同）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">vim</span><span style="color:#032F62"> /etc/crypttab</span><span style="color:#6A737D"> # 改为 keyscript=/opt/tpm2-luks-helper/initramfs/tpm2-cryptsetup</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /opt/tpm2-luks-helper/initramfs/tpm2-cryptsetup-setup</span><span style="color:#032F62"> /etc/initramfs-tools/hooks/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">update-initramfs</span><span style="color:#005CC5"> -u</span><span style="color:#005CC5"> -k</span><span style="color:#032F62"> all</span></span></code></pre></div><p>安装 APT Hook，在 GRUB 更新时自动重新安装 GRUB：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /opt/tpm2-luks-helper/grub/99update-and-sign-grub</span><span style="color:#032F62"> /etc/apt/apt.conf.d/</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6A737D"># 执行 apt install --reinstall grub-efi-amd64-bin 来确认</span></span></code></pre></div><p>修改 <code class="punctuation-r">.bashrc</code>，在执行重启 / 关机命令时检查下次启动是否可以正常解密：</p><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#D73A49">alias</span><span style="color:#24292E"> reboot</span><span style="color:#D73A49">=</span><span style="color:#032F62">"tpm2-luks-helper check-next-boot &#x26;&#x26; reboot"</span></span><span class="line"><span style="color:#D73A49">alias</span><span style="color:#24292E"> shutdown</span><span style="color:#D73A49">=</span><span style="color:#032F62">"tpm2-luks-helper check-next-boot &#x26;&#x26; shutdown"</span></span><span class="line"></span></code></pre></div><p>如果检查到不满足自动解密的条件，脚本会提示：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">reboot</span></span>Check failed: initramfs changed  -   Current: &quot;/boot//initrd.img-5.15.30-2-pve:a47803f6bbe1430a3d6fb50f75002c8c&quot;  - Next boot: &quot;/boot//initrd.img-5.15.30-2-pve:06cae583f012d98371d34f3fd379e161&quot;Please run &quot;tpm2-luks-helper trust-next-boot&quot; and do a *attended* reboot.</code></pre></div><p>此时运行 <code>tpm2-luks-helper trust-next-boot</code> 生成临时密钥，在下次引导时脚本将会自动从临时密钥解密。成功启动后临时密钥将被自动删除，之后继续使用 TPM 中的密钥解密。</p><h1 id="%E6%94%BB%E5%87%BB%E9%9D%A2" tabindex="-1">攻击面 <a class="headerlink" href="#%E6%94%BB%E5%87%BB%E9%9D%A2"></a></h1><p>一般来说，存储在 TPM 中的密钥足够安全，难以被攻击者直接获得，而 Secure Boot 和 TPM 测量的存在也使得密钥在引导过程被篡改时无法获得密钥。但在常见的设备上，仍然有一些方式可以攻击使用 TPM 的硬盘加密。</p><h2 id="%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB" tabindex="-1">冷启动攻击 <a class="headerlink" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E6%94%BB%E5%87%BB"></a></h2><p>用于加解密磁盘数据的密钥往往被存储在内存中。在通常条件下，DRAM 内存中的数据会在断电后迅速消失，而在低温条件下，DRAM 内存中的数据可以保持很久。攻击者可以启动计算机，等待系统从 TPM 中读取密钥并解密，然后使用制冷剂对内存冷冻，并从外部设备引导计算机，或将冷冻的内存移动到另一台计算机上，进入特制的操作系统读取数据。</p><p>一些现代 CPU 具有<strong>内存加密</strong>功能，可以在 CPU 读写内存时透明地对 DRAM 中的数据进行加解密，以抵御冷启动攻击。在纯软件的层面上，可以通过将密钥保持在 CPU 寄存器中而不写入内存的方式来阻止攻击者从内存中取得密钥，但内存中的其他敏感信息仍然能够被取得。</p><h2 id="evil-maid-%E6%94%BB%E5%87%BB" tabindex="-1">Evil Maid 攻击 <a class="headerlink" href="#evil-maid-%E6%94%BB%E5%87%BB"></a></h2><p>在攻击者能够在计算机拥有者者不知情时物理接触到计算机的情况下，攻击者可以对计算机进行一些修改，制作一个假的输入密码界面，欺骗拥有者 TPM 解密失败，从而诱惑拥有者输入密码解密。对于纯软件层面的修改，拥有者可以通过检查 BIOS 设置、检查 Secure Boot 证书、检查未加密部分文件来识别这种攻击行为。对于硬件层面上的修改，拥有者无法检查，但一些安全设备可以通过物理熔断的方式来检测其是否被拆卸，从来识别这种攻击。</p><h1 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" tabindex="-1">参考资料 <a class="headerlink" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"></a></h1><ul><li><a href="https://superuser.com/a/1417510">StackExchange: Migrating from unencrypted Ubuntu 16.04 to LUKS Encrypted install of 16.04</a>（<a href="https://archive.is/wip/diu8h">存档</a>）</li><li><a href="https://blastrock.github.io/fde-tpm-sb.html">Philippe Daouadi: The ultimate guide to Full Disk Encryption with TPM and Secure Boot</a>（<a href="https://archive.is/1QZtK">存档</a>）</li><li><a href="https://wiki.debian.org/SecureBoot">Debian Wiki: SecureBoot</a>（<a href="https://archive.is/DP0KH">存档</a>）</li><li><a href="https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface/Secure_Boot">ArchWiki: Unified Extensible Firmware Interface/Secure Boot</a>（<a href="https://archive.md/ouOEE">存档</a>）</li><li><a href="https://wiki.archlinux.org/title/Trusted_Platform_Module">ArchWiki: Trusted Platform Module</a>（<a href="https://archive.is/cp5oj">存档</a>）</li><li><a href="https://wiki.archlinux.org/title/Dm-crypt/Specialties">ArchWiki: dm-crypt/Specialties</a>（<a href="https://archive.is/05h4j">存档</a>）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了保护用户数据，现代设备与操作系统往往都支持全盘加密的功能，其中最为典型的是 Microsoft Windows 的 BitLocker。它既可以对系统分区进行加密，又可以在确认引导过程可信的情况下，不需要用户交互即可自动解密，这利用到了 TPM 和 Secure Boot。而在 GNU/Linux 系统下，如果用常用的 LUKS 加密方案进行全盘加密，则需要在每次开机时输入密码。&lt;/p&gt;
&lt;p&gt;本篇文章将参考 BitLocker 的做法，利用 Secure Boot 和 TPM 2.0 来实现 LUKS 全盘加密的自动解密。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SRE" scheme="https://blog.men.ci/tags/SRE/"/>
    
    <category term="Linux" scheme="https://blog.men.ci/tags/Linux/"/>
    
    <category term="安全" scheme="https://blog.men.ci/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用 Proxmox Backup Server 备份 Proxmox VE 的客户机与宿主机</title>
    <link href="https://blog.men.ci/backup-pve-with-pbs/"/>
    <id>https://blog.men.ci/backup-pve-with-pbs/</id>
    <published>2022-11-11T18:43:00.000Z</published>
    <updated>2024-12-03T06:23:57.965Z</updated>
    
    <content type="html"><![CDATA[<p>Proxmox VE 是一款功能强大且易于使用的虚拟化平台。在不依赖其它服务的情况下，Proxmox VE 即可设置灵活的备份策略，将客户机按时备份储存到指定的存储中。但 Proxmox VE 的一般备份方式不支持增量备份，也不支持备份宿主机本身。</p><p>本篇文章将介绍 Proxmox Backup Server 的安装与使用，它为 Proxmox VE 提供了增量备份、远程同步等高级功能。</p><span id="more"></span><h1 id="%E5%AE%89%E8%A3%85" tabindex="-1">安装 <a class="headerlink" href="#%E5%AE%89%E8%A3%85"></a></h1><p>由于 Proxmox Backup Server 一般与 Proxmox VE 配合使用，我们将 Proxmox Backup Server 作为虚拟机安装在 Proxmox VE 环境中，官方提供的安装方式是使用 ISO 镜像安装，适用于 KVM 虚拟机，跟随图形界面安装程序安装即可。不建议将 Proxmox Backup Server 安装在单独的物理机器上，一方面，Proxmox Backup Server 对 CPU 与内存的占用并不大，使用单独的物理机会造成浪费；另一方面，即使在同一内网中，网络可能会成为备份数据传输的瓶颈。较为轻量化的安装方式是使用 LXC 容器。</p><p>截止本文发布之时，Proxmox Backup Server 的最新版本为 2.2，基于 Debian 11。</p><p>首先创建一个 Debian 11 的 LXC 容器（不需要 Privileged），并为其设置 <code>root</code> 密码（Proxmox Backup Server 需要在 Web 管理界面上使用 <code>root</code> 密码登录）。登录到容器内，为其设置时区（定时任务会根据当前时区运行）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">rm</span><span style="color:#032F62"> /etc/localtime</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">ln</span><span style="color:#005CC5"> -sf</span><span style="color:#032F62"> /usr/share/zoneinfo/Asia/Shanghai</span><span style="color:#032F62"> /etc/localtime</span></span></code></pre></div><p>在 Debian 源的基础上，添加 Proxmox Backup Server 的软件源：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">nano</span><span style="color:#032F62"> /etc/apt/sources.list.d/pbs-enterprise.list</span></span></code></pre></div><p>任选一个镜像源即可：</p><div class="flex-wrapper"><pre><code class="language-debsources"><span class="line"><span style="color:#D73A49">deb</span><span style="color:#032F62"> http://mirrors.ustc.edu.cn/proxmox/debian/pbs</span><span style="color:#24292E"> bullseye pbs-</span><span style="color:#6F42C1">no</span><span style="color:#24292E">-subscription</span></span><span class="line"><span style="color:#D73A49">deb</span><span style="color:#032F62"> http://mirrors.tuna.tsinghua.edu.cn/proxmox/pbs</span><span style="color:#24292E"> bullseye pbs-</span><span style="color:#6F42C1">no</span><span style="color:#24292E">-subscription</span></span><span class="line"><span style="color:#D73A49">deb</span><span style="color:#032F62"> http://mirrors.xtom.hk/proxmox/debian/pbs</span><span style="color:#24292E"> bullseye pbs-</span><span style="color:#6F42C1">no</span><span style="color:#24292E">-subscription</span></span><span class="line"></span></code></pre></div><p>之后添加 Proxmox 的 GPG Key，并使用 APT 安装 <code>proxmox-backup-server</code> 包：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">wget</span><span style="color:#032F62"> https://enterprise.proxmox.com/debian/proxmox-release-bullseye.gpg</span><span style="color:#005CC5"> -O</span><span style="color:#032F62"> /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg</span></span><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">apt</span><span style="color:#032F62"> update</span><span style="color:#24292E"> &#x26;&#x26; </span><span style="color:#6F42C1">apt</span><span style="color:#032F62"> install</span><span style="color:#032F62"> proxmox-backup-server</span></span></code></pre></div><p>如果 <code>ifupdown2</code> 包配置出错，可以忽略并重启后使用 <code>apt -f install</code> 修复。</p><p>安装结束后，登录 <code class="punctuation-r">https://IP:8007</code>（注意，与 Proxmox VE 的 8006 端口不同，Proxmox Backup Server 使用 8007 端口），使用创建 LXC 容器时的 <code>root</code> 密码登录，即可进入 Proxmox Backup Server 的管理界面。</p><p>注意，ISO 镜像中的图形化安装程序会设置管理员邮箱，但手动安装时不会询问。如果需要邮件通知，请在安装之后需要手动再管理界面中设置管理员邮箱（左侧菜单中选择「Configuraion → Access Control」，双击右侧的 <code>root</code> 用户）：</p><div class="images"><div class="image"><a href="set-admin-email@1.333x.svg" title="为 Proxmox Backup Server 设置管理员邮箱" data-fancybox><img src="set-admin-email@1.333x.svg" alt="编辑管理员用户" title="为 Proxmox Backup Server 设置管理员邮箱" srcset="set-admin-email@1.333x.svg 1.333x"></a><p class="image-caption">为 Proxmox Backup Server 设置管理员邮箱</p></div></div><p>最后可以手动禁用 <code>systemd</code> 中不需要的 failed 服务：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">systemctl</span><span style="color:#032F62"> disable</span><span style="color:#032F62"> zfs-mount.service</span><span style="color:#032F62"> zfs-share.service</span><span style="color:#032F62"> zfs-zed.service</span><span style="color:#032F62"> systemd-modules-load.service</span></span></code></pre></div><h1 id="%E9%85%8D%E7%BD%AE" tabindex="-1">配置 <a class="headerlink" href="#%E9%85%8D%E7%BD%AE"></a></h1><h2 id="%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" tabindex="-1">数据存储 <a class="headerlink" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"></a></h2><p>在 Proxmox Backup Server 中，备份被存储在数据存储（Datastore）中，每个数据存储对应文件系统上的一个文件夹。备份文件被以 Proxmox Backup Server 的自有格式组织在文件系统上，数据以分块的形式存储，对文件系统的性能要求（相对于直接存储压缩文档）较高，所以不建议使用远程存储（CIFS / NFS）作为数据存储，推荐使用本地硬盘。如果需要在 NAS 上储存备份数据，建议在 NAS 上安装 Proxmox Backup Server 虚拟机。</p><p>将需要存储数据的硬盘分区挂载到任意目录下（如 <code class="punctuation-r">/mnt/data</code>）。如果在 Proxmox VE 管理界面为 Proxmox Backup Server 客户机分配备份存储空间，请注意不要勾选备份（Backup）选项。如果需要在 LXC 容器中挂载远程 NFS 共享作为数据存储目录，请在宿主机中为其开启 NFS 支持。对于 KVM，可以将备份硬盘直通给虚拟机进行使用；对于 LXC，可以将备份硬盘挂载到宿主机上，并映射给 LXC 容器：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">pct</span><span style="color:#032F62"> set</span><span style="color:#005CC5"> 111</span><span style="color:#005CC5"> -mp0</span><span style="color:#032F62"> /mnt/hdd,mp=/mnt/data</span><span style="color:#6A737D"> # 将宿主机的 /mnt/hdd 映射到 LXC 容器 111 的客户机 /mnt/data 路径中</span></span></code></pre></div><p>对于 Unprivileged 容器，会遇到容器中无法写入的问题，这是由于 LXC 将容器内的 UID/GID 映射到了宿主机上的其他 UID/GID。可以在宿主机上检查容器内 <code>root</code> 用户/用户组所对应的 UID/GID：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#005CC5">stat</span><span style="color:#005CC5"> -c</span><span style="color:#032F62"> "%u %g"</span><span style="color:#032F62"> /proc/</span><span style="color:#24292E">$(</span><span style="color:#6F42C1">pgrep</span><span style="color:#005CC5"> -f</span><span style="color:#032F62"> proxmox-backup-api</span><span style="color:#24292E">)</span></span>100000 100000</code></pre></div><p>将宿主机上的数据目录的属主/属组改为上述命令输出的 UID/GID 即可：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">chown</span><span style="color:#032F62"> 100000:100000</span><span style="color:#032F62"> /mnt/hdd</span></span></code></pre></div><p>确保 Proxmox Backup Server 可以正确写入存储目录后，在管理界面上创建数据存储（左侧菜单中选择「Datastore → Add Datastore」）：</p><div class="images"><div class="image"><a href="add-datastore@1.333x.svg" title="添加 Datastore" data-fancybox><img src="add-datastore@1.333x.svg" alt="添加 Datastore" title="添加 Datastore" srcset="add-datastore@1.333x.svg 1.333x"></a><p class="image-caption">添加 Datastore</p></div></div><p>右侧的 GC Schedule 和 Prune Schedule 分别表示进行垃圾回收与删除多余备份的定时任务时间，默认的 <code>daily</code> 表示每天 <code class="punctuation-r">00:00</code>。删除备份时的保留策略在第二个选项卡「Prune Options」中设置：</p><div class="images"><div class="image"><a href="add-datastore-prune-options@1.333x.svg" title="设置 Datastore 的保留策略" data-fancybox><img src="add-datastore-prune-options@1.333x.svg" alt="设置 Datastore 的保留策略" title="设置 Datastore 的保留策略" srcset="add-datastore-prune-options@1.333x.svg 1.333x"></a><p class="image-caption">设置 Datastore 的保留策略</p></div></div><p>如图所示，表示保留互相间隔一天的 7 个备份，互相间隔一周的 8 个备份，互相间隔一个月的 6 个备份。这些选项也可以在 Proxmox VE 的备份任务中设置，但更推荐在 Proxmox Backup Server 中设置。</p><p>点击「Add」提交后，系统将开始创建数据存储，由于需要对文件系统上的目录结构进行一些初始化，在 HDD 或远程存储上可能需要较长的时间。</p><h3 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" tabindex="-1">命名空间 <a class="headerlink" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"></a></h3><p>每个数据存储中可以包含多个命名空间，命名空间并不隔离访问权限与存储设备，仅隔离备份名称。每一组备份以 VM/CT 的 ID 或者宿主机的主机名来命名，在不同命名空间中放置来自不同 Proxmox VE 服务器的数据，可以确保名称不会冲突。</p><p>在 Datastore 的管理界面选择「Content」选项卡，并在下方列表的右上方点击「Add NS」按钮，即可创建命名空间。</p><h2 id="%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90" tabindex="-1">用户与权限 <a class="headerlink" href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90"></a></h2><p>除仅用于登录管理界面的 <code>root</code> 用户使用 PAM 认证外，其他管理员用户或备份客户端均使用 Proxmox Backup Server 自带的用户管理系统进行认证。在左侧菜单中选择「Configuration → Access Control」，并点击右侧的「Add」按钮，输入用户名与密码：</p><div class="images"><div class="image"><a href="add-user@1.333x.svg" title="添加用户" data-fancybox><img src="add-user@1.333x.svg" alt="添加用户" title="添加用户" srcset="add-user@1.333x.svg 1.333x"></a><p class="image-caption">添加用户</p></div></div><p>如果该用户是另一位管理员用户，则可以输入其邮箱地址，之后可以将邮件通知设为发往其邮箱。如果是备份客户端用户，则不需要填写邮箱。</p><p>然后在「Permissions」选项卡中，点击「Add → User Permission」，为刚刚创建的用户添加权限：</p><div class="images"><div class="image"><a href="add-user-permission@1.333x.svg" title="为用户授予权限" data-fancybox><img src="add-user-permission@1.333x.svg" alt="为用户授予权限" title="为用户授予权限" srcset="add-user-permission@1.333x.svg 1.333x"></a><p class="image-caption">为用户授予权限</p></div></div><p>如果该用户是另一位管理员用户，可以选择为其授予根路径的管理员权限。如果用于 Proxmox VE 服务器上的备份客户端，并且希望在 Proxmox VE 上管理备份，可以选择在特定数据存储下的 <code>DatastoreAdmin</code> 权限。</p><h1 id="%E5%A4%87%E4%BB%BD" tabindex="-1">备份 <a class="headerlink" href="#%E5%A4%87%E4%BB%BD"></a></h1><h2 id="%E6%B7%BB%E5%8A%A0%E5%AD%98%E5%82%A8" tabindex="-1">添加存储 <a class="headerlink" href="#%E6%B7%BB%E5%8A%A0%E5%AD%98%E5%82%A8"></a></h2><p>首先需要在 Proxmox VE 中将 Proxmox Backup Server 添加为存储（Storage）。登录 Proxmox VE 管理界面，选择「Datacenter → Storage」，在「Add」按钮的菜单中选择「Proxmox Backup Server」：</p><div class="images"><div class="image"><a href="pve-add-pbs-storage@1.333x.svg" title="在 Proxmox VE 中添加备份存储" data-fancybox><img src="pve-add-pbs-storage@1.333x.svg" alt="在 Proxmox VE 中添加备份存储" title="在 Proxmox VE 中添加备份存储" srcset="pve-add-pbs-storage@1.333x.svg 1.333x"></a><p class="image-caption">在 Proxmox VE 中添加备份存储</p></div></div><p>在 Server 字段中填写 Proxmox Backup Server 的 IP 地址或域名。如果在特殊情况下，Proxmox Backup Server 位于 NAT 之后无法被主动连接，可以使用 <a href="https://github.com/rapiz1/rathole">Rathole</a> 等内网穿透工具，这种时候可将 8007 端口转发到任意端口号，并在 Server 字段中填写 IP:PORT。对于 Username 字段，请注意在创建时输入的用户名后面加上 <code class="punctuation-r">@pbs</code>，表示是 Proxmox Backup Server 自己的账户系统（而非 PAM）。</p><p>建议对备份进行加密，在「Encryption」选项卡中选择第二项「Auto-generate a client encryption key」，自动生成客户端加密密钥。对备份进行加密可以确保服务器端无法访问备份数据的内容，特别是对于使用共享的 Proxmox Backup Server，或者为了冗余需要将备份同步到其他 Proxmox Backup Server 时。</p><div class="images"><div class="image"><a href="pve-add-pbs-storage-encryption@1.333x.svg" title="为备份存储设置加密" data-fancybox><img src="pve-add-pbs-storage-encryption@1.333x.svg" alt="为备份存储设置加密" title="为备份存储设置加密" srcset="pve-add-pbs-storage-encryption@1.333x.svg 1.333x"></a><p class="image-caption">为备份存储设置加密</p></div></div><p>点击「Add」按钮添加后，如果使用了默认的自签证书（未被 Proxmox VE 客户端所信任），会提示 SSL Fingerprint 不匹配，这时候复制错误文本中的 Fingerprint 文本，填写到「General」选项卡的对应字段中，即可添加成功。添加成功后，Proxmox VE 会提示你将自动生成的加密密钥保存。再次添加该存储并读取已有的备份时，需要选择「Upload an existing client encryption key」，将保存好的 Key 文件上传，即可解密之前的备份数据。</p><div class="images"><div class="image"><a href="pve-add-pbs-storage-save-key@1.333x.svg" title="下载加密密钥" data-fancybox><img src="pve-add-pbs-storage-save-key@1.333x.svg" alt="下载加密密钥" title="下载加密密钥" srcset="pve-add-pbs-storage-save-key@1.333x.svg 1.333x"></a><p class="image-caption">下载加密密钥</p></div></div><h2 id="%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD%E4%BB%BB%E5%8A%A1" tabindex="-1">设置备份任务 <a class="headerlink" href="#%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD%E4%BB%BB%E5%8A%A1"></a></h2><p>在 Proxmox VE 管理面板中，选择「Datacenter → Backup → Add」，指定需要备份的客户机列表与备份时间，选择 Storage 为刚刚添加的 Proxmox Backup Server，即可创建备份任务。</p><p>创建备份任务后，可以在列表中选中任务点击「Run now」，测试备份任务是否可以正常工作。</p><h2 id="%E5%A4%87%E4%BB%BD-proxmox-ve-%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%88%E6%88%96%E4%BB%BB%E6%84%8F%E7%89%A9%E7%90%86%E6%9C%BA%EF%BC%89" tabindex="-1">备份 Proxmox VE 宿主机（或任意物理机） <a class="headerlink" href="#%E5%A4%87%E4%BB%BD-proxmox-ve-%E5%AE%BF%E4%B8%BB%E6%9C%BA%EF%BC%88%E6%88%96%E4%BB%BB%E6%84%8F%E7%89%A9%E7%90%86%E6%9C%BA%EF%BC%89"></a></h2><p>截至本文发布之时，Proxmox Backup Server 还没有完整支持对 Proxmox VE 宿主机的备份，我们暂时无法在管理界面中配置宿主机备份。但是该功能已存在于当前的版本中，可以通过手动调用 <code>proxmox-backup-client</code> 来使用。参考<a href="https://pbs.proxmox.com/docs/command-syntax.html#proxmox-backup-client">官方文档</a>，使用 <code>--backup-type host</code> 参数可以创建宿主机备份。</p><p>对于使用 LVM 安装的 Proxmox VE，我们可以编写一个脚本，首先对 Proxmox VE 的宿主机根分区创建一个 LVM 快照（宿主机的写入量不大，快照的大小只需要能满足备份期间宿主机写入量即可，所以快照不需要太大），然后调用 <code>proxmox-backup-client</code> 对快照块设备进行备份，最后删除快照：</p><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#6A737D">#!/bin/bash</span></span><span class="line"><span style="color:#6F42C1">lvremove</span><span style="color:#005CC5"> -y</span><span style="color:#032F62"> pve/root_snapshot</span><span style="color:#D73A49"> ||</span><span style="color:#005CC5"> true</span></span><span class="line"><span style="color:#6F42C1">lvcreate</span><span style="color:#005CC5"> -pr</span><span style="color:#005CC5"> -L</span><span style="color:#032F62"> 5G</span><span style="color:#005CC5"> --monitor</span><span style="color:#032F62"> y</span><span style="color:#005CC5"> --snapshot</span><span style="color:#005CC5"> --name</span><span style="color:#032F62"> root_snapshot</span><span style="color:#032F62"> pve/root</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">export</span><span style="color:#24292E"> PBS_PASSWORD_FILE</span><span style="color:#D73A49">=</span><span style="color:#24292E">/etc/pve/priv/storage/menci-pbs-home.pw</span></span><span class="line"><span style="color:#6F42C1">proxmox-backup-client</span><span style="color:#032F62"> backup</span><span style="color:#032F62"> root.img:/dev/pve/root_snapshot</span><span style="color:#005CC5"> --backup-type</span><span style="color:#032F62"> host</span><span style="color:#005CC5"> --repository</span><span style="color:#032F62"> Menci-Home@pbs@192.168.1.12:HDD</span><span style="color:#005CC5"> --ns</span><span style="color:#032F62"> Home</span><span style="color:#005CC5"> --keyfile</span><span style="color:#032F62"> /etc/pve/priv/storage/menci-pbs-home.enc</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">lvremove</span><span style="color:#005CC5"> -y</span><span style="color:#032F62"> pve/root_snapshot</span></span><span class="line"></span></code></pre></div><p>上述命令中，<code class="punctuation-l">--repository</code> 表示备份目标存储，格式为 <code class="punctuation-r">&lt;username&gt;@pbs@&lt;host:port&gt;:&lt;datastore&gt;</code>，命名空间通过 <code>--ns</code> 参数指定。密码和加密密钥通过文件指定，对于在 Proxmox VE 管理面板添加过的存储，对应的文件即为 <code>/etc/pve/priv/storage/</code> 目录下的 <code>.pw</code> 与 <code>.enc</code> 文件。</p><p>该命令中的 <code>root.img:/dev/pve/root_snapshot</code> 部分可以指定多次，用于备份多个磁盘分区。前半部分为生成的备份中的文件名，后半部分为文件系统中的源文件（或目录）的路径。如果后半部分是一个路径，则前半部分需要是 <code>.pxar</code> 格式的文件名，表示将文件夹打包为 Proxmox Backup Server 的 <a href="https://pbs.proxmox.com/docs/file-formats.html">Proxmox File Archive Format</a> 格式，可以使用对应的<a href="https://pbs.proxmox.com/docs/pxar-tool.html">命令行工具</a>进行处理。</p><p>对于使用 ZFS 安装的 Proxmox VE，其根文件系统是一个 ZFS dataset（默认位于 <code class="punctuation-r">/rpool/ROOT/pve-1</code>），我们可以为其创建快照。ZFS 快照可以被挂载为一个只读目录，可以使用 <code>.pxar</code> 格式对快照目录进行备份即可：</p><div class="flex-wrapper"><blockquote><p>ZFS 快照目录默认可能是隐藏的，需要先执行 <code>zfs set snapdir=visible rpool/ROOT/pve-1</code> 将其设为可见。</p></blockquote></div><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#6A737D">#!/bin/bash</span></span><span class="line"><span style="color:#6F42C1">zfs</span><span style="color:#032F62"> destroy</span><span style="color:#032F62"> rpool/ROOT/pve-1@backup</span><span style="color:#D73A49"> ||</span><span style="color:#005CC5"> true</span></span><span class="line"><span style="color:#6F42C1">zfs</span><span style="color:#032F62"> snapshot</span><span style="color:#032F62"> rpool/ROOT/pve-1@backup</span></span><span class="line"></span><span class="line"><span style="color:#D73A49">export</span><span style="color:#24292E"> PBS_PASSWORD_FILE</span><span style="color:#D73A49">=</span><span style="color:#24292E">/etc/pve/priv/storage/menci-pbs-home.pw</span></span><span class="line"><span style="color:#6F42C1">proxmox-backup-client</span><span style="color:#032F62"> backup</span><span style="color:#032F62"> root.pxar:/.zfs/snapshot/backup</span><span style="color:#005CC5"> --backup-type</span><span style="color:#032F62"> host</span><span style="color:#005CC5"> --repository</span><span style="color:#032F62"> Menci-Home@pbs@menci-pbs.home.net.men.ci:HDD</span><span style="color:#005CC5"> --ns</span><span style="color:#032F62"> Home</span><span style="color:#005CC5"> --keyfile</span><span style="color:#032F62"> /etc/pve/priv/storage/menci-pbs-home.enc</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">zfs</span><span style="color:#032F62"> destroy</span><span style="color:#032F62"> rpool/ROOT/pve-1@backup</span></span><span class="line"></span></code></pre></div><p>将编写好的备份脚本保存，例如保存到 <code class="punctuation-r">/root/backup-host.sh</code>。为其添加执行权限，并加入到 <code>cron</code> 中定时执行（注意添加 <code>PATH</code> 行，否则 <code>cron</code> 定时任务执行时的 <code>PATH</code> 不完整会导致执行失败）：</p><div class="flex-wrapper"><pre><code class="language-crontab"><span class="line"><span style="color:#24292E">PATH</span><span style="color:#D73A49">=</span><span style="color:#032F62">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><span class="line"><span style="color:#005CC5">0</span><span style="color:#005CC5"> 3</span><span style="color:#005CC5"> *</span><span style="color:#005CC5"> *</span><span style="color:#005CC5"> *</span><span style="color:#032F62"> /root/backup-host.sh</span></span><span class="line"></span></code></pre></div><p>当需要进行恢复时，使用同样在命令行下使用 <code>proxmox-backup-client</code> 工具进行恢复：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">proxmox-backup-client</span><span style="color:#032F62"> restore</span><span style="color:#032F62"> host/Menci-PVE</span><span style="color:#032F62"> root.img</span><span style="color:#032F62"> restored_root.img</span><span style="color:#005CC5"> --repository</span><span style="color:#032F62"> Menci-Home@pbs@192.168.1.12:HDD</span><span style="color:#005CC5"> --ns</span><span style="color:#032F62"> Home</span><span style="color:#005CC5"> --keyfile</span><span style="color:#032F62"> /etc/pve/priv/storage/menci-pbs-home.enc</span></span></code></pre></div><p>上述命令表示，从该备份存储中，恢复 <code class="punctuation-r">host/Menci-PVE</code>（格式为 <code class="punctuation-r">host/&lt;hostname&gt;</code>，可在 Web 管理界面中看到这些备份）中的 <code>root.img</code> 文件，下载到本地的 <code>restored_root.img</code> 文件中。</p><p>除备份 Proxmox VE 宿主机外，<code class="punctuation-l">proxmox-backup-client</code> 命令行工具也可以在其他任何 Linux 机器上运行，官方提供了该工具的 <a href="https://pbs.proxmox.com/docs/installation.html#proxmox-backup-client-only-repository">APT 源</a>。理论上来说，任何支持快照的文件系统均可使用该工具进行备份。</p><h1 id="%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5" tabindex="-1">远程同步 <a class="headerlink" href="#%E8%BF%9C%E7%A8%8B%E5%90%8C%E6%AD%A5"></a></h1><p>Proxmox Backup Server 支持在多个服务器之间将备份进行同步，具体的实现方式是，原本的备份数据存放在 A 服务器上，B 服务器定时连接 A 服务器拉取备份。注意这里只能由 B（需同步到的目标服务器）主动连接 A（存放原始备份的源服务器），如果 A 在 NAT 之后无法由 B 主动连接，可以使用上述添加存储时一样的解决方案，使用 <a href="https://github.com/rapiz1/rathole">Rathole</a> 等内网穿透工具进行端口映射。</p><p>与进行备份时一样，进行同步时，B 服务器也需要使用用户和密码登录到 A 服务器。按照上述方法在 A 服务器上创建用户，仅需授予 <code>DatastoreReader</code> 权限。同步备份无需客户端密钥，因为 Proxmox VE 在备份客户端所进行的加密，对 Proxmox Backup Server 是透明的，同步时也无需解密。所以，如果之后要从 B 服务器上恢复备份，同样需要连接 A 服务器时的密钥。</p><p>在 B 服务器上选择左侧菜单中的「Configuration → Remotes」，点击右侧的「Add」按钮，添加 A 服务器（按照同样的方式填写 Fingerprint）：</p><div class="images"><div class="image"><a href="sync-add-remote@1.333x.svg" title="添加远程服务器" data-fancybox><img src="sync-add-remote@1.333x.svg" alt="添加远程服务器" title="添加远程服务器" srcset="sync-add-remote@1.333x.svg 1.333x"></a><p class="image-caption">添加远程服务器</p></div></div><p>之后在 B 服务器上创建一个数据存储，并创建对应的命名空间（如果需要）。在创建好的数据存储中选择「Sync Jobs」选项卡，点击「Add」按钮：</p><div class="images"><div class="image"><a href="sync-add-job@1.333x.svg" title="添加拉取任务" data-fancybox><img src="sync-add-job@1.333x.svg" alt="添加拉取任务" title="添加拉取任务" srcset="sync-add-job@1.333x.svg 1.333x"></a><p class="image-caption">添加拉取任务</p></div></div><p>指定从源 A 服务器的某个数据存储的某个命名空间，同步到当前 B 服务器的某个数据存储的某个命名空间，并填写计划时间。如果传输在公网上进行，建议设置带宽限制，以免影响双方（特别是上传方）的其他网络应用。可以勾选「Remove vanished」选项以自动删除在原服务器 A 上已删除的备份，或者在 B 服务器上为数据存储设置保留策略。</p><p>创建完成后可以点击「Run now」测试同步是否可以正常工作。</p><h1 id="%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98" tabindex="-1">已知问题 <a class="headerlink" href="#%E5%B7%B2%E7%9F%A5%E9%97%AE%E9%A2%98"></a></h1><h2 id="%E5%A4%87%E4%BB%BD%E6%89%80%E6%9C%89%E6%9D%83%E9%94%99%E8%AF%AF" tabindex="-1">备份所有权错误 <a class="headerlink" href="#%E5%A4%87%E4%BB%BD%E6%89%80%E6%9C%89%E6%9D%83%E9%94%99%E8%AF%AF"></a></h2><p>类似 Linux 的文件系统权限管理，Proxmox Backup Server 会记录每个备份组是由哪个用户所创建的。例如，如果用户 A 连接到服务器创建了一个 <code class="punctuation-r">vm/101</code>（ID 为 101 的 KVM 虚拟机）的备份，则以用户 B 连接时，无法在同一命名空间创建再次创建名为 <code>vm/101</code> 的另一个备份。</p><p>即使删除掉已有的 <code>vm/101</code> 下的所有备份，所有权仍然不会消除。如果需要使用另一个用户创建同名的备份，请使用命令手动修改所有权。登录任意具有 <code>DatastoreAdmin</code> 权限的用户即可更改所有权。</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="# "></span><span class="line"><span style="color:#6F42C1">proxmox-backup-client</span><span style="color:#032F62"> change-owner</span><span style="color:#032F62"> vm/101</span><span style="color:#032F62"> New-User@pbs</span><span style="color:#005CC5"> --repository</span><span style="color:#032F62"> Any-User@pbs@192.168.1.12:HDD</span><span style="color:#005CC5"> --ns</span><span style="color:#032F62"> Home</span></span></code></pre></div><p>在 Web 管理界面上可以看到每个备份组的所有者，但暂时无法进行修改。目前仅支持使用上述命令修改所有权。</p><h2 id="%E8%99%9A%E6%8B%9F%E6%9C%BA-i%2Fo-%E6%9C%AA%E5%93%8D%E5%BA%94" tabindex="-1">虚拟机 I/O 未响应 <a class="headerlink" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA-i%2Fo-%E6%9C%AA%E5%93%8D%E5%BA%94"></a></h2><p>Proxmox VE 传统的 <code>vzdump</code> 备份统一采用 LVM / ZFS 快照来捕捉客户机（KVM 虚拟机和 LXC 容器）的一致性的文件系统，不会影响客户机的运行。向 Proxmox Backup Server 备份时，Proxmox VE 对 LVM 采用同样的方式进行，并采用对两次快照进行对比的方式实现增量（对宿主机备份也是如此），但对于 KVM 虚拟机，他们使用了另一种由 QEMU 提供的一致性增量备份接口：<a href="https://qemu-project.gitlab.io/qemu/interop/bitmaps.html">Dirty Bitmaps</a>。</p><p>QEMU Dirty Bitmap 可以记录 KVM 虚拟机在虚拟磁盘设备的哪些位置进行了写入操作，并允许虚拟机管理程序仅将被修改的部分记录到备份中。在创建备份时，QEMU 在内存中进行一个快照，向虚拟机管理程序提供一致性的 Bitmap 和虚拟磁盘数据。但由于缺少类似 LVM 的 Copy on Write 机制，为了保证虚拟机能够正常运行不被中断，QEMU 只能将备份期间虚拟机进行的磁盘写入操作暂时缓存在内存中，待备份结束后再写回存储设备。</p><p>这导致了一个问题，如果单个虚拟机备份耗时较长，同时在这个时间内虚拟机进行了较多的磁盘写入操作，则 QEMU 内部的快照缓冲区会被占满，此时 QEMU 只能将接下来的写入操作完全阻塞，导致虚拟机无响应，造成服务中断。而如果该虚拟机位于 Proxmox VE 到 Proxmox Backup Server 的网络出口上（例如，向公网上的服务器备份，途中作为路由器/防火墙的虚拟机被阻塞），则备份过程会被阻塞，最终因连接中断而备份失败。</p><p>有用户曾经提出过使用 LVM / ZFS 快照进行 KVM 备份的<a href="https://bugzilla.proxmox.com/show_bug.cgi?id=4136">建议</a>，但被官方驳回，官方更倾向于使用 QEMU 自带的增量备份机制。QEMU 在 <a href="https://github.com/qemu/qemu/commit/af5bcd775f3115e4c1b7715920a67b31b119de30">7.0 中加入</a>了名为 Fleecing 的机制，可以利用磁盘作为备份快照的写入缓冲，以解决内存中的缓冲区不足的问题，但 Proxmox VE 还没有跟进支持。</p><p>目前针对此问题的建议是，不要直接从 Proxmox VE 向异地的 Proxmox Backup Server 发送备份，而是先备份到本地的 Proxmox Backup Server 中，确保单个虚拟机的备份过程不会持续太久，之后再同步到远程服务器上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Proxmox VE 是一款功能强大且易于使用的虚拟化平台。在不依赖其它服务的情况下，Proxmox VE 即可设置灵活的备份策略，将客户机按时备份储存到指定的存储中。但 Proxmox VE 的一般备份方式不支持增量备份，也不支持备份宿主机本身。&lt;/p&gt;
&lt;p&gt;本篇文章将介绍 Proxmox Backup Server 的安装与使用，它为 Proxmox VE 提供了增量备份、远程同步等高级功能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Homelab" scheme="https://blog.men.ci/tags/Homelab/"/>
    
    <category term="Proxmox" scheme="https://blog.men.ci/tags/Proxmox/"/>
    
    <category term="SRE" scheme="https://blog.men.ci/tags/SRE/"/>
    
    <category term="虚拟化" scheme="https://blog.men.ci/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    <category term="备份" scheme="https://blog.men.ci/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 自动申请与部署 ACME SSL 证书</title>
    <link href="https://blog.men.ci/ssl-with-github-actions/"/>
    <id>https://blog.men.ci/ssl-with-github-actions/</id>
    <published>2022-05-11T02:37:00.000Z</published>
    <updated>2024-12-03T06:23:58.001Z</updated>
    
    <content type="html"><![CDATA[<p>对于将 Web 服务部署在多个服务器与云服务的人来说，如何方便地申请并管理 SSL 证书，是一个值得思考的问题。我使用 GitHub Actions 来自动申请/续期 ACME SSL 证书，部署到各个云平台上，并在自己管理的服务器上定期拉取证书。</p><span id="more"></span><p>首先创建一个私有 GitHub 仓库用于存放证书配置和各类凭据，以及存放申请到的证书。</p><h1 id="%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6" tabindex="-1">申请证书 <a class="headerlink" href="#%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6"></a></h1><h2 id="%E5%87%86%E5%A4%87" tabindex="-1">准备 <a class="headerlink" href="#%E5%87%86%E5%A4%87"></a></h2><p>首先请在本地（或自己的服务器上）成功使用 <a href="https://acme.sh">acme.sh</a> 的 DNS-01 验证方式成功申请一次证书。这个过程包括：</p><ol><li>向 CA 注册 ACME 账户（如果使用 Let's Encrypt 则会自动进行，如果使用 ZeroSSL 或者 GTS 则需要手动注册）。</li><li>通过环境变量指定 DNS 提供商的凭据，用于添加/删除 ACME DNS-01 认证所需的 TXT 记录。</li><li>确认证书申请可以成功，为后续调试排除可能的问题。</li></ol><p>第一次申请证书后，CA 的 ACME 账户凭据将被存储到 <code>~/.acme.sh/ca</code> 中，DNS 提供商的凭据将被存储到 <code>~/.acme.sh/account.conf</code> 中。将它们打包并 BASE64 以备在 GitHub Actions 上使用：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#005CC5">cd</span><span style="color:#032F62"> ~/.acme.sh</span></span><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">tar</span><span style="color:#032F62"> cz</span><span style="color:#032F62"> ca</span><span style="color:#032F62"> account.conf</span><span style="color:#D73A49"> |</span><span style="color:#6F42C1"> base64</span><span style="color:#005CC5"> -w0</span></span></code></pre></div><p>将输出内容添加到 GitHub 仓库的 Secrets 中。</p><h2 id="acme-action" tabindex="-1">ACME Action <a class="headerlink" href="#acme-action"></a></h2><p>使用 Action <a href="https://github.com/marketplace/actions/issue-ssl-certificate"><code>Menci/acme</code></a> 可以通过 acme.sh 申请 SSL 证书（使用 DNS-01 验证）。需要以下参数：</p><ul><li><code class="punctuation-r">account-tar</code>：用于指定 ACME 客户端的凭据。使用刚刚生成好的 Secret 即可。</li><li><code class="punctuation-r">domains-file</code>：指定一个文件，其中包含需要为其申请证书的域名列表，用空白字符隔开。<ul><li>亦可直接使用 <code>domain</code> 参数来指定域名列表，但不推荐直接将域名列表硬编码在 Workflow 文件中。</li><li>默认将包含它们对应的 wildcard 域名（即 <code>example.com</code> 会包含 <code class="punctuation-r">*.example.com</code>），如果不希望自动添加，则可以设置 <code>append-wildcard</code> 为 <code class="punctuation-r">false</code>。</li></ul></li><li><code class="punctuation-r">arguments-file</code>：指定一个文件，其中包含向 acme.sh 传递的参数列表。主要用于指定 <code>--dns</code> 和 <code>--server</code> 参数。如 <code class="punctuation-r">--dns dns_cf --server letsencrypt</code>。<ul><li>亦可直接使用 <code>arguments</code> 参数来指定参数列表。</li><li>其它常用参数如 <code>--valid-to</code> 和 <code>--challenge-alias</code> 也可以在此设定。</li></ul></li><li><code class="punctuation-r">output-fullchain</code>：输出 PEM 格式的全链证书文件的路径（如果目录不存在将自动创建，下同）。</li><li><code class="punctuation-r">output-key</code>：输出 PEM 格式的证书私钥文件的路径。</li><li><code class="punctuation-r">output-pfx</code>：输出 PFX 格式的全链证书文件的路径（如果不需要可以留空，上同）。<ul><li>使用 <code>output-pfx-password</code> 指定 PFX 文件的密码，随意指定即可。</li></ul></li></ul><p>另外，建议通过 <code>version</code> 参数指定 acme.sh 的版本（版本号或者 commit）来保持稳定性。</p><h2 id="%E4%B8%8A%E4%BC%A0%E8%AF%81%E4%B9%A6" tabindex="-1">上传证书 <a class="headerlink" href="#%E4%B8%8A%E4%BC%A0%E8%AF%81%E4%B9%A6"></a></h2><p>因为我们将在不同的 Job 中执行接下来的证书部署操作，我们需要在申请证书的 Job 的最后将证书 push 到仓库中（或者上传到 Artifacts 中）。</p><p>首先创建一个空的分支：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">mkdir</span><span style="color:#032F62"> /tmp/empty-repo</span><span style="color:#24292E"> &#x26;&#x26; </span><span style="color:#005CC5">cd</span><span style="color:#032F62"> /tmp/empty-repo</span><span style="color:#24292E"> &#x26;&#x26; </span><span style="color:#6F42C1">git</span><span style="color:#032F62"> init</span><span style="color:#6A737D">   # 创建一个临时 repo</span></span><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">git</span><span style="color:#032F62"> commit</span><span style="color:#005CC5"> --allow-empty</span><span style="color:#005CC5"> -m</span><span style="color:#032F62"> "Initial commit"</span><span style="color:#6A737D">              # 创建一个空的 commit</span></span><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">git</span><span style="color:#032F62"> push</span><span style="color:#032F62"> git@github.com:</span><span style="color:#D73A49">&#x3C;</span><span style="color:#032F62">usernam</span><span style="color:#24292E">e</span><span style="color:#D73A49">></span><span style="color:#032F62">/</span><span style="color:#D73A49">&#x3C;</span><span style="color:#032F62">rep</span><span style="color:#24292E">o</span><span style="color:#D73A49">></span><span style="color:#032F62"> HEAD:certs-main</span><span style="color:#6A737D"> # push 到新的分支上</span></span></code></pre></div><p>在申请证书之前 checkout 这个分支到一个子目录，将申请到的证书放到这个目录下，并 commit-push 即可：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Push to GitHub</span></span><span class="line"><span style="color:#22863A">  run</span><span style="color:#24292E">: </span><span style="color:#D73A49">|</span></span><span class="line"><span style="color:#032F62">    git config --global user.name $(git show -s --format='%an' HEAD)</span></span><span class="line"><span style="color:#032F62">    git config --global user.email $(git show -s --format='%ae' HEAD)</span></span><span class="line"><span style="color:#032F62">    cd "$CERTS_OUTPUT_DIRECTORY"</span></span><span class="line"><span style="color:#032F62">    git add "$FILE_KEY" "$FILE_FULLCHAIN" "$FILE_PFX"</span></span><span class="line"><span style="color:#032F62">    git commit -m "[Actions/${<span></span>{ github.workflow }}] Upload certificates on $(date '+%Y-%m-%d %H:%M:%S')"</span></span><span class="line"><span style="color:#032F62">    git push</span></span><span class="line"><span style="color:#22863A">  env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    TZ</span><span style="color:#24292E">: </span><span style="color:#032F62">Asia/Shanghai</span></span><span class="line"></span></code></pre></div><h1 id="%E9%83%A8%E7%BD%B2%E8%AF%81%E4%B9%A6" tabindex="-1">部署证书 <a class="headerlink" href="#%E9%83%A8%E7%BD%B2%E8%AF%81%E4%B9%A6"></a></h1><p>在申请证书的 Job 执行完成后，我们执行一系列 Job 来将证书部署到各个云服务。</p><h2 id="azure-key-vault" tabindex="-1">Azure Key Vault <a class="headerlink" href="#azure-key-vault"></a></h2><p><a href="https://azure.microsoft.com/en-us/services/key-vault/">Key Vault</a> 是 Azure 提供的密钥存储服务，可以用于存储 SSL 证书。并可以用于在 <a href="https://azure.microsoft.com/en-us/services/frontdoor/">Front Door</a> 中使用。</p><p>使用 Azure CLI（<code class="punctuation-r punctuation-l">azure/CLI</code>）将证书部署到 Key Vault：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Login to Azure</span></span><span class="line"><span style="color:#22863A">  uses</span><span style="color:#24292E">: </span><span style="color:#032F62">azure/login@v1</span></span><span class="line"><span style="color:#22863A">  with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    creds</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.AZURE_CREDENTIALS }}</span></span><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Upload certificate</span></span><span class="line"><span style="color:#22863A">  uses</span><span style="color:#24292E">: </span><span style="color:#032F62">azure/CLI@v1</span></span><span class="line"><span style="color:#22863A">  with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    inlineScript</span><span style="color:#24292E">: </span><span style="color:#D73A49">|</span></span><span class="line"><span style="color:#032F62">      az keyvault certificate import --subscription "$AZURE_SUBSCRIPTION" \</span></span><span class="line"><span style="color:#032F62">                                     --vault-name "$AZURE_KEY_VAULT_NAME" \</span></span><span class="line"><span style="color:#032F62">                                     --file "$CERTS_OUTPUT_DIRECTORY/$FILE_PFX" \</span></span><span class="line"><span style="color:#032F62">                                     --name "$AZURE_KEY_CERTIFICATE_NAME" \</span></span><span class="line"><span style="color:#032F62">                                     --password "$PFX_PASSWORD"</span></span><span class="line"><span style="color:#22863A">  env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    AZURE_SUBSCRIPTION</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.subscription }}</span></span><span class="line"><span style="color:#22863A">    AZURE_KEY_VAULT_NAME</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.vault-name }}</span></span><span class="line"><span style="color:#22863A">    AZURE_KEY_CERTIFICATE_NAME</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.certificate-name }}</span></span><span class="line"></span></code></pre></div><p>在 Front Door 中指定来自 Key Vault 的证书后，证书将自动更新。</p><p>所使用的 Service Principal 需要拥有该 Key Vault 的 Certificate → Import 权限。使用以下命令可以创建一个 Service Principal：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">az</span><span style="color:#032F62"> ad</span><span style="color:#032F62"> sp</span><span style="color:#032F62"> create-for-rbac</span><span style="color:#005CC5"> --name</span><span style="color:#032F62"> SSLCertificateUploader</span></span>{  &quot;appId&quot;: &quot;019d7f61-a969-4daa-b53f-f2341f6f4705&quot;,  &quot;displayName&quot;: &quot;SSLCertificateUploader&quot;,  &quot;password&quot;: &quot;vCGS5BQMm.BI~6BEjjCa-j6tZ2fCxJsENA&quot;,  &quot;tenant&quot;: &quot;72f988bf-86f1-41af-91ab-2d7cd011db47&quot;}</code></pre></div><p>输出的内容即为该 Service Principal 的凭据（<a href="https://github.com/Azure/login/blob/6bc1b5ecb97c62c523edc56f8da91d422a1c2efc/README.md#configure-deployment-credentials">建议删除换行</a>以免 <code>{</code> 和 <code>}</code> 被认为是 Secret，导致在 Actions 的输出中被遮盖）。在 Azure Portal 中为其<a href="https://docs.microsoft.com/en-us/azure/key-vault/general/assign-access-policy?tabs=azure-portal">赋予权限</a>即可。</p><h2 id="azure-app-service" tabindex="-1">Azure App Service <a class="headerlink" href="#azure-app-service"></a></h2><p><a href="https://azure.microsoft.com/en-us/services/app-service/">App Service</a>（<a href="https://azure.microsoft.com/en-us/services/functions/">Function App</a> 同理）是 Azure 提供的 Web 应用服务。App Service 绑定的域名需要手动上传 SSL 证书（也可从 Key Vault 中导入，但导入是一次性的，不会像 Front Door 一样自动更新）。</p><p>使用 <a href="https://github.com/marketplace/actions/deploy-ssl-certificate-to-azure-web-app"><code>Menci/deploy-certificate-to-azure-web-app</code></a> 将证书部署到 App Service：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">  uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-azure-web-app@beta-v2</span></span><span class="line"><span style="color:#22863A">  with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    azcliversion</span><span style="color:#24292E">: </span><span style="color:#005CC5">2.28.0</span></span><span class="line"><span style="color:#22863A">    creds</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.AZURE_CREDENTIALS }}</span></span><span class="line"><span style="color:#22863A">    subscription</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.subscription }}</span></span><span class="line"><span style="color:#22863A">    resource-group</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.resource-group }}</span></span><span class="line"><span style="color:#22863A">    webapp-name</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.webapp-name }}</span></span><span class="line"><span style="color:#22863A">    certificate-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_PFX }}</span></span><span class="line"><span style="color:#22863A">    certificate-password</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.PFX_PASSWORD }}</span></span><span class="line"><span style="color:#22863A">    delete-old-certificates</span><span style="color:#24292E">: </span><span style="color:#005CC5">true</span></span><span class="line"></span></code></pre></div><p>该 Action 会将新的证书上传到 App Service 所在的 Resource Group 中，并为该 App Service 所绑定的所有匹配的域名应用该证书。当 <code>delete-old-certificates</code> 参数为 <code>true</code> 时，将自动删除该 App Service 之前使用的所有证书（包含非本 Action 上传的证书）。</p><p>所使用的 Service Principal 需要拥有 Resource Group 级别（而非 Resource 级别，因为同一个 Resource Group 的 SSL 证书是共享的）的 Website Contributor权限。在 Azure Portal 中为其<a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-assignments-portal?tabs=current">赋予权限</a>即可。</p><h2 id="%E9%98%BF%E9%87%8C%E4%BA%91" tabindex="-1">阿里云 <a class="headerlink" href="#%E9%98%BF%E9%87%8C%E4%BA%91"></a></h2><p>阿里云的 <a href="https://www.aliyun.com/product/cas">SSL 证书服务</a>支持上传自定义证书，该证书可以用于阿里云 <a href="https://www.aliyun.com/product/cdn">CDN</a>。阿里云暂未提供将证书部署至 <a href="https://www.aliyun.com/product/oss">OSS</a> 的 API，建议 OSS 用户使用 CDN 回源 OSS 来代替。</p><p>使用 <a href="https://github.com/marketplace/actions/deploy-ssl-certificate-to-aliyun"><code>Menci/deploy-certificate-to-aliyun</code></a> 将证书部署到阿里云：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">  uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-aliyun@beta-v1</span></span><span class="line"><span style="color:#22863A">  with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    access-key-id</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.ALIYUN_ACCESS_KEY_ID }}</span></span><span class="line"><span style="color:#22863A">    access-key-secret</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.ALIYUN_ACCESS_KEY_SECRET }}</span></span><span class="line"><span style="color:#22863A">    fullchain-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_FULLCHAIN }}</span></span><span class="line"><span style="color:#22863A">    key-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_KEY }}</span></span><span class="line"><span style="color:#22863A">    certificate-name</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.certificate-name }}</span></span><span class="line"><span style="color:#22863A">    cdn-domains</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ join(matrix.cdn-domains, ' ') }}</span></span><span class="line"></span></code></pre></div><p>其中 <code>certificate-name</code> 指定上传的证书在证书服务中的名称（将自动替换旧版本），<code class="punctuation-l">cdn-domain</code> 指定需要将该证书部署到的 CDN 域名列表（用空白字符隔开）。</p><p>建议使用子账户 Access Key，为其赋予以下权限（并按需使用资源组隔离）：</p><ul><li><code>AliyunYundunCertFullAccess</code></li><li><code>AliyunCDNFullAccess</code></li><li><code>AliyunPCDNFullAccess</code></li><li><code>AliyunSCDNFullAccess</code></li><li><code>AliyunDCDNFullAccess</code></li></ul><h2 id="%E5%8F%88%E6%8B%8D%E4%BA%91" tabindex="-1">又拍云 <a class="headerlink" href="#%E5%8F%88%E6%8B%8D%E4%BA%91"></a></h2><p>又拍云的<a href="http://docs.upyun.com/cdn/ssl/">证书服务</a>支持上传自定义证书，该证书可以用于又拍云所有服务。</p><p>使用 <a href="https://github.com/marketplace/actions/deploy-ssl-certificate-to-upyun"><code>Menci/deploy-certificate-to-upyun</code></a> 将证书部署到又拍云：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#24292E">- </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">  uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-upyun@beta-v2</span></span><span class="line"><span style="color:#22863A">  with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    subaccount-username</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.UPYUN_SUBACCOUNT_USERNAME }}</span></span><span class="line"><span style="color:#22863A">    subaccount-password</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.UPYUN_SUBACCOUNT_PASSWORD }}</span></span><span class="line"><span style="color:#22863A">    fullchain-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_FULLCHAIN }}</span></span><span class="line"><span style="color:#22863A">    key-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_KEY }}</span></span><span class="line"><span style="color:#22863A">    domains</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ join(matrix.domains, ' ') }}</span></span><span class="line"><span style="color:#22863A">    delete-unused-certificates</span><span style="color:#24292E">: </span><span style="color:#005CC5">true</span></span><span class="line"></span></code></pre></div><p>其中 <code>domains</code> 指定需要将该证书部署到的域名列表（用空白字符隔开）。当 <code>delete-unused-certificates</code> 为 <code>true</code> 时，将自动删除所有未使用的旧证书（包含非本 Action 上传的证书，以及在又拍云申请的证书）。</p><p>由于又拍云没有提供证书相关的公开 API，该 Action 使用控制台 API 实现，所以需要提供子账户的用户名和密码，而非 Access Key 和 Secret Key。</p><h2 id="%E8%85%BE%E8%AE%AF%E4%BA%91" tabindex="-1">腾讯云 <a class="headerlink" href="#%E8%85%BE%E8%AE%AF%E4%BA%91"></a></h2><p>见<a href="https://blog.baoshuo.ren/post/actions-ssl-cert/#%E8%85%BE%E8%AE%AF%E4%BA%91">宝硕博客</a>。</p><h2 id="%E6%9C%8D%E5%8A%A1%E5%99%A8" tabindex="-1">服务器 <a class="headerlink" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"></a></h2><p>通过 GitHub Actions 自动向服务器部署证书较为困难，特别是对于位于 NAT 后的服务器而言。我的解决方法是让服务器自动从 Azure Key Vault 中拉取证书。如果你不使用 Azure Key Vault，也可以考虑直接从 GitHub 仓库中拉取证书（使用只读的 Deploy Keys 可以达到权限最小化，但只能控制到仓库级别，无法控制到分支级别）。</p><p>下载证书所用的 Service Principal 需要拥有该 Key Vault 的 Secret → Get 权限（而非 Certificate → Get 权限，该权限仅可读取证书本身，不可读取证书私钥）。与上文同理，创建一个 Service Principal 并赋予权限（建议使用不同的 Service Principal 上传和下载证书），并在服务器上登录（其中 <code>username</code> 即为 <code class="punctuation-r">appId</code>）：</p><div class="flex-wrapper"><pre><code class="language-bash-prompt"><span class="hl-sh-prompt" data-prompt="$ "></span><span class="line"><span style="color:#6F42C1">az</span><span style="color:#032F62"> login</span><span style="color:#005CC5"> --service-principal</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">           --username</span><span style="color:#032F62"> 218acab1-8f2d-4f0c-ab30-8931332058d3</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">           --password</span><span style="color:#032F62"> 'fbrDxvS0~mWQ8QcHVLQzqAuJhOHDR9-YW4'</span><span style="color:#005CC5"> \</span></span><span class="line"><span style="color:#005CC5">           --tenant</span><span style="color:#032F62"> 72f988bf-86f1-41af-91ab-2d7cd011db47</span></span></code></pre></div><p>登录 Azure CLI 后，使用以下脚本自动从 Azure Key Vault 中拉取证书（记得 <code class="punctuation-r">chmod +x</code>）：</p><div class="flex-wrapper"><pre><code class="language-bash"><span class="line"><span style="color:#6A737D">#!/bin/bash -e</span></span><span class="line"></span><span class="line"><span style="color:#24292E">AZURE_CERT_URI</span><span style="color:#D73A49">=</span><span style="color:#032F62">"https://&#x3C;你的 Key Vault 名称>.vault.azure.net/secrets/&#x3C;你的 Key Vault 中证书的名称>"</span></span><span class="line"><span style="color:#24292E">INSTALL_KEY</span><span style="color:#D73A49">=</span><span style="color:#032F62">"/etc/nginx/ssl/ssl.key"</span><span style="color:#6A737D">  # PEM 私钥的目标位置</span></span><span class="line"><span style="color:#24292E">INSTALL_CERT</span><span style="color:#D73A49">=</span><span style="color:#032F62">"/etc/nginx/ssl/ssl.crt"</span><span style="color:#6A737D"> # PEM 全链的目标位置</span></span><span class="line"><span style="color:#24292E">INSTALL_CMD</span><span style="color:#D73A49">=</span><span style="color:#032F62">"systemctl reload nginx"</span><span style="color:#6A737D">  # 应用证书的命令</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">rm</span><span style="color:#005CC5"> -rf</span><span style="color:#032F62"> /tmp/update-cert</span></span><span class="line"><span style="color:#6F42C1">mkdir</span><span style="color:#032F62"> /tmp/update-cert</span></span><span class="line"><span style="color:#005CC5">cd</span><span style="color:#032F62"> /tmp/update-cert</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 下载 PFX 格式的证书</span></span><span class="line"><span style="color:#6F42C1">az</span><span style="color:#032F62"> keyvault</span><span style="color:#032F62"> secret</span><span style="color:#032F62"> download</span><span style="color:#005CC5"> --id</span><span style="color:#032F62"> "</span><span style="color:#24292E">$AZURE_CERT_URI</span><span style="color:#032F62">"</span><span style="color:#005CC5"> --encoding</span><span style="color:#032F62"> base64</span><span style="color:#005CC5"> --file</span><span style="color:#032F62"> cert.pfx</span></span><span class="line"></span><span class="line"><span style="color:#6A737D"># 转换为 PEM 格式</span></span><span class="line"><span style="color:#6F42C1">openssl</span><span style="color:#032F62"> pkcs12</span><span style="color:#005CC5"> -in</span><span style="color:#032F62"> cert.pfx</span><span style="color:#005CC5"> -nocerts</span><span style="color:#005CC5"> -out</span><span style="color:#032F62"> key-enc.pem</span><span style="color:#005CC5"> -passin</span><span style="color:#032F62"> pass:</span><span style="color:#005CC5"> -passout</span><span style="color:#032F62"> pass:pass</span></span><span class="line"><span style="color:#6F42C1">openssl</span><span style="color:#032F62"> pkcs12</span><span style="color:#005CC5"> -in</span><span style="color:#032F62"> cert.pfx</span><span style="color:#005CC5"> -nokeys</span><span style="color:#005CC5"> -out</span><span style="color:#032F62"> cert.pem</span><span style="color:#005CC5"> -passin</span><span style="color:#032F62"> pass:</span></span><span class="line"><span style="color:#6F42C1">openssl</span><span style="color:#032F62"> rsa</span><span style="color:#005CC5"> -in</span><span style="color:#032F62"> key-enc.pem</span><span style="color:#005CC5"> -out</span><span style="color:#032F62"> key.pem</span><span style="color:#005CC5"> -passin</span><span style="color:#032F62"> pass:pass</span></span><span class="line"></span><span class="line"><span style="color:#6F42C1">cp</span><span style="color:#032F62"> key.pem</span><span style="color:#032F62"> "</span><span style="color:#24292E">$INSTALL_KEY</span><span style="color:#032F62">"</span></span><span class="line"><span style="color:#6F42C1">cp</span><span style="color:#032F62"> cert.pem</span><span style="color:#032F62"> "</span><span style="color:#24292E">$INSTALL_CERT</span><span style="color:#032F62">"</span></span><span class="line"></span><span class="line"><span style="color:#24292E">$INSTALL_CMD</span></span><span class="line"></span></code></pre></div><p>将该脚本添加到 <code>cron</code> 即可定期运行，如：</p><div class="flex-wrapper"><pre><code class="language-crontab"><span class="line"><span style="color:#005CC5">0</span><span style="color:#005CC5"> 20</span><span style="color:#005CC5"> *</span><span style="color:#005CC5"> *</span><span style="color:#005CC5"> *</span><span style="color:#032F62"> /root/update-cert.sh</span></span><span class="line"></span></code></pre></div><h1 id="%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90" tabindex="-1">完整例子 <a class="headerlink" href="#%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90"></a></h1><p>这里给出一个完整的例子，即我目前使用的配置。在 <code>main/options</code> 和 <code>main/domains</code> 文件中指定参数和域名列表，在 <code>main/deploy.json</code> 中指定部署目标，每一类部署目标可以有多个（主要是 Azure App Service）。</p><p>GitHub Workflow 文件（将在每周三、周六的 UTC+0 零点自动更新证书）：</p><div class="flex-wrapper"><pre><code class="language-yaml"><span class="line"><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Main</span></span><span class="line"><span style="color:#005CC5">on</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  workflow_dispatch</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  schedule</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">cron</span><span style="color:#24292E">: </span><span style="color:#032F62">'0 0 * * SAT'</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">cron</span><span style="color:#24292E">: </span><span style="color:#032F62">'0 0 * * WED'</span></span><span class="line"><span style="color:#22863A">env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  TARGET</span><span style="color:#24292E">: </span><span style="color:#032F62">main</span></span><span class="line"><span style="color:#22863A">  CERTS_OUTPUT_DIRECTORY</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-output</span></span><span class="line"><span style="color:#22863A">  FILE_FULLCHAIN</span><span style="color:#24292E">: </span><span style="color:#032F62">fullchain.pem</span></span><span class="line"><span style="color:#22863A">  FILE_KEY</span><span style="color:#24292E">: </span><span style="color:#032F62">key.pem</span></span><span class="line"><span style="color:#22863A">  FILE_PFX</span><span style="color:#24292E">: </span><span style="color:#032F62">certificate.pfx</span></span><span class="line"><span style="color:#22863A">  PFX_PASSWORD</span><span style="color:#24292E">: </span><span style="color:#032F62">qwq</span></span><span class="line"><span style="color:#22863A">jobs</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">  issue-push</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Issue &#x26; Push</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">main</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout output branch</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-${<span></span>{ env.TARGET }}</span></span><span class="line"><span style="color:#22863A">        path</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Issue certificate</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/acme@main</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        version</span><span style="color:#24292E">: </span><span style="color:#032F62">83da01a2e1f5384ed997f9e023ea4a813dcac1f0</span></span><span class="line"><span style="color:#22863A">        account-tar</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.ACME_SH_ACCOUNT_TAR }}</span></span><span class="line"><span style="color:#22863A">        domains-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CONFIG_DOMAINS }}</span></span><span class="line"><span style="color:#22863A">        arguments-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CONFIG_OPTIONS }}</span></span><span class="line"><span style="color:#22863A">        output-fullchain</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_FULLCHAIN }}</span></span><span class="line"><span style="color:#22863A">        output-key</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_KEY }}</span></span><span class="line"><span style="color:#22863A">        output-pfx</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_PFX }}</span></span><span class="line"><span style="color:#22863A">        output-pfx-password</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.PFX_PASSWORD }}</span></span><span class="line"><span style="color:#22863A">      env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        CONFIG_DOMAINS</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.TARGET }}/domains</span></span><span class="line"><span style="color:#22863A">        CONFIG_OPTIONS</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.TARGET }}/options</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Push to GitHub</span></span><span class="line"><span style="color:#22863A">      run</span><span style="color:#24292E">: </span><span style="color:#D73A49">|</span></span><span class="line"><span style="color:#032F62">        git config --global user.name $(git show -s --format='%an' HEAD)</span></span><span class="line"><span style="color:#032F62">        git config --global user.email $(git show -s --format='%ae' HEAD)</span></span><span class="line"><span style="color:#032F62">        cd "$CERTS_OUTPUT_DIRECTORY"</span></span><span class="line"><span style="color:#032F62">        git add "$FILE_KEY" "$FILE_FULLCHAIN" "$FILE_PFX"</span></span><span class="line"><span style="color:#032F62">        git commit -m "[Actions/${<span></span>{ github.workflow }}] Upload certificates on $(date '+%Y-%m-%d %H:%M:%S')"</span></span><span class="line"><span style="color:#032F62">        git push</span></span><span class="line"><span style="color:#22863A">      env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        TZ</span><span style="color:#24292E">: </span><span style="color:#032F62">Asia/Shanghai</span></span><span class="line"><span style="color:#22863A">  deployment-config</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Load Deployment Config</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    outputs</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      config</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ steps.read-deployment-config.outputs.config }}</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">main</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Read Deployment Config</span></span><span class="line"><span style="color:#22863A">      id</span><span style="color:#24292E">: </span><span style="color:#032F62">read-deployment-config</span></span><span class="line"><span style="color:#22863A">      run</span><span style="color:#24292E">: </span><span style="color:#D73A49">|</span></span><span class="line"><span style="color:#032F62">        echo "::set-output name=config::$(jq -c &#x3C; "$CONFIG_FILE")"</span></span><span class="line"><span style="color:#22863A">      env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        CONFIG_FILE</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.TARGET }}/deploy.json</span></span><span class="line"><span style="color:#22863A">  deploy-azure-keyvault</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy to Azure KeyVault (${<span></span>{ matrix.vault-name }})</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    needs</span><span style="color:#24292E">: [</span><span style="color:#032F62">issue-push</span><span style="color:#24292E">, </span><span style="color:#032F62">deployment-config</span><span style="color:#24292E">]</span></span><span class="line"><span style="color:#22863A">    if</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).azure-keyvault }}</span></span><span class="line"><span style="color:#22863A">    strategy</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      fail-fast</span><span style="color:#24292E">: </span><span style="color:#005CC5">false</span></span><span class="line"><span style="color:#22863A">      matrix</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        include</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).azure-keyvault }}</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout output branch</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-${<span></span>{ env.TARGET }}</span></span><span class="line"><span style="color:#22863A">        path</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Login to Azure</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">azure/login@v1</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        creds</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.AZURE_CREDENTIALS }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Upload certificate</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">azure/CLI@v1</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        inlineScript</span><span style="color:#24292E">: </span><span style="color:#D73A49">|</span></span><span class="line"><span style="color:#032F62">          az keyvault certificate import --subscription "$AZURE_SUBSCRIPTION" \</span></span><span class="line"><span style="color:#032F62">                                         --vault-name "$AZURE_KEY_VAULT_NAME" \</span></span><span class="line"><span style="color:#032F62">                                         --file "$CERTS_OUTPUT_DIRECTORY/$FILE_PFX" \</span></span><span class="line"><span style="color:#032F62">                                         --name "$AZURE_KEY_CERTIFICATE_NAME" \</span></span><span class="line"><span style="color:#032F62">                                         --password "$PFX_PASSWORD"</span></span><span class="line"><span style="color:#22863A">      env</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        AZURE_SUBSCRIPTION</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.subscription }}</span></span><span class="line"><span style="color:#22863A">        AZURE_KEY_VAULT_NAME</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.vault-name }}</span></span><span class="line"><span style="color:#22863A">        AZURE_KEY_CERTIFICATE_NAME</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.certificate-name }}</span></span><span class="line"><span style="color:#22863A">  deploy-azure-webapp</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy to Azure Web App (${<span></span>{ matrix.name }})</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    needs</span><span style="color:#24292E">: [</span><span style="color:#032F62">issue-push</span><span style="color:#24292E">, </span><span style="color:#032F62">deployment-config</span><span style="color:#24292E">]</span></span><span class="line"><span style="color:#22863A">    if</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).azure-webapp }}</span></span><span class="line"><span style="color:#22863A">    strategy</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      fail-fast</span><span style="color:#24292E">: </span><span style="color:#005CC5">false</span></span><span class="line"><span style="color:#22863A">      matrix</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        include</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).azure-webapp }}</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout output branch</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-${<span></span>{ env.TARGET }}</span></span><span class="line"><span style="color:#22863A">        path</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-azure-web-app@main</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        azcliversion</span><span style="color:#24292E">: </span><span style="color:#005CC5">2.28.0</span></span><span class="line"><span style="color:#22863A">        creds</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.AZURE_CREDENTIALS }}</span></span><span class="line"><span style="color:#22863A">        subscription</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.subscription }}</span></span><span class="line"><span style="color:#22863A">        resource-group</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.resource-group }}</span></span><span class="line"><span style="color:#22863A">        webapp-name</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.webapp-name }}</span></span><span class="line"><span style="color:#22863A">        certificate-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_PFX }}</span></span><span class="line"><span style="color:#22863A">        certificate-password</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.PFX_PASSWORD }}</span></span><span class="line"><span style="color:#22863A">        delete-old-certificates</span><span style="color:#24292E">: </span><span style="color:#005CC5">true</span></span><span class="line"><span style="color:#22863A">  deploy-aliyun</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy to Aliyun (${<span></span>{ matrix.certificate-name }})</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    needs</span><span style="color:#24292E">: [</span><span style="color:#032F62">issue-push</span><span style="color:#24292E">, </span><span style="color:#032F62">deployment-config</span><span style="color:#24292E">]</span></span><span class="line"><span style="color:#22863A">    if</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).aliyun }}</span></span><span class="line"><span style="color:#22863A">    strategy</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      fail-fast</span><span style="color:#24292E">: </span><span style="color:#005CC5">false</span></span><span class="line"><span style="color:#22863A">      matrix</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        include</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).aliyun }}</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout output branch</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-${<span></span>{ env.TARGET }}</span></span><span class="line"><span style="color:#22863A">        path</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-aliyun@main</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        access-key-id</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.ALIYUN_ACCESS_KEY_ID }}</span></span><span class="line"><span style="color:#22863A">        access-key-secret</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.ALIYUN_ACCESS_KEY_SECRET }}</span></span><span class="line"><span style="color:#22863A">        fullchain-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_FULLCHAIN }}</span></span><span class="line"><span style="color:#22863A">        key-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_KEY }}</span></span><span class="line"><span style="color:#22863A">        certificate-name</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ matrix.certificate-name }}</span></span><span class="line"><span style="color:#22863A">        cdn-domains</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ join(matrix.cdn-domains, ' ') }}</span></span><span class="line"><span style="color:#22863A">  deploy-upyun</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">    name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy to Upyun (${<span></span>{ matrix.name }})</span></span><span class="line"><span style="color:#22863A">    runs-on</span><span style="color:#24292E">: </span><span style="color:#032F62">ubuntu-latest</span></span><span class="line"><span style="color:#22863A">    needs</span><span style="color:#24292E">: [</span><span style="color:#032F62">issue-push</span><span style="color:#24292E">, </span><span style="color:#032F62">deployment-config</span><span style="color:#24292E">]</span></span><span class="line"><span style="color:#22863A">    if</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).upyun }}</span></span><span class="line"><span style="color:#22863A">    strategy</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">      fail-fast</span><span style="color:#24292E">: </span><span style="color:#005CC5">false</span></span><span class="line"><span style="color:#22863A">      matrix</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        include</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ fromJson(needs.deployment-config.outputs.config).upyun }}</span></span><span class="line"><span style="color:#22863A">    steps</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Checkout output branch</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">actions/checkout@v2</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        ref</span><span style="color:#24292E">: </span><span style="color:#032F62">certs-${<span></span>{ env.TARGET }}</span></span><span class="line"><span style="color:#22863A">        path</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}</span></span><span class="line"><span style="color:#24292E">    - </span><span style="color:#22863A">name</span><span style="color:#24292E">: </span><span style="color:#032F62">Deploy certificate</span></span><span class="line"><span style="color:#22863A">      uses</span><span style="color:#24292E">: </span><span style="color:#032F62">Menci/deploy-certificate-to-upyun@main</span></span><span class="line"><span style="color:#22863A">      with</span><span style="color:#24292E">:</span></span><span class="line"><span style="color:#22863A">        subaccount-username</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.UPYUN_SUBACCOUNT_USERNAME }}</span></span><span class="line"><span style="color:#22863A">        subaccount-password</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ secrets.UPYUN_SUBACCOUNT_PASSWORD }}</span></span><span class="line"><span style="color:#22863A">        fullchain-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_FULLCHAIN }}</span></span><span class="line"><span style="color:#22863A">        key-file</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ env.CERTS_OUTPUT_DIRECTORY }}/${<span></span>{ env.FILE_KEY }}</span></span><span class="line"><span style="color:#22863A">        domains</span><span style="color:#24292E">: </span><span style="color:#032F62">${<span></span>{ join(matrix.domains, ' ') }}</span></span><span class="line"><span style="color:#22863A">        delete-unused-certificates</span><span style="color:#24292E">: </span><span style="color:#005CC5">true</span></span><span class="line"></span></code></pre></div><p>部署配置（<code class="punctuation-r punctuation-l">main/deploy.json</code>）的格式：</p><div class="flex-wrapper"><pre><code class="language-json"><span class="line"><span style="color:#24292E">{</span></span><span class="line"><span style="color:#005CC5">  "azure-keyvault"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#24292E">    {</span></span><span class="line"><span style="color:#005CC5">      "subscription"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "vault-name"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "certificate-name"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span></span><span class="line"><span style="color:#24292E">    }</span></span><span class="line"><span style="color:#24292E">  ],</span></span><span class="line"><span style="color:#005CC5">  "azure-webapp"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#24292E">    {</span></span><span class="line"><span style="color:#005CC5">      "name"</span><span style="color:#24292E">: </span><span style="color:#032F62">"&#x3C;显示名称>"</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "subscription"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "resource-group"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "webapp-name"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span></span><span class="line"><span style="color:#24292E">    }</span></span><span class="line"><span style="color:#24292E">  ],</span></span><span class="line"><span style="color:#005CC5">  "aliyun"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#24292E">    {</span></span><span class="line"><span style="color:#005CC5">      "certificate-name"</span><span style="color:#24292E">: </span><span style="color:#032F62">""</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "cdn-domains"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#032F62">        "example.com"</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#032F62">        "example.net"</span></span><span class="line"><span style="color:#24292E">      ]</span></span><span class="line"><span style="color:#24292E">    }</span></span><span class="line"><span style="color:#24292E">  ],</span></span><span class="line"><span style="color:#005CC5">  "upyun"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#24292E">    {</span></span><span class="line"><span style="color:#005CC5">      "name"</span><span style="color:#24292E">: </span><span style="color:#032F62">"&#x3C;显示名称>"</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#005CC5">      "domains"</span><span style="color:#24292E">: [</span></span><span class="line"><span style="color:#032F62">        "example.com"</span><span style="color:#24292E">,</span></span><span class="line"><span style="color:#032F62">        "example.net"</span></span><span class="line"><span style="color:#24292E">      ]</span></span><span class="line"><span style="color:#24292E">    }</span></span><span class="line"><span style="color:#24292E">  ]</span></span><span class="line"><span style="color:#24292E">}</span></span><span class="line"></span></code></pre></div><h1 id="%E5%85%B3%E4%BA%8E-gts-%E8%AF%81%E4%B9%A6" tabindex="-1">关于 GTS 证书 <a class="headerlink" href="#%E5%85%B3%E4%BA%8E-gts-%E8%AF%81%E4%B9%A6"></a></h1><p>最近 Google Cloud 推出了基于 Google Trust Service（GTS）的 SSL 证书服务，可参考<a href="https://www.julydate.com/post/1888545210/">此文章</a>（<a href="https://archive.is/EgPat">存档</a>）进行申请。acme.sh 也在第一时间<a href="https://github.com/acmesh-official/acme.sh/commit/fb5091a388c6cb4280cd095ab74056697be21a54">添加了</a>对 GTS 的支持。</p><p>GTS 证书的亮点有：</p><ol><li>使用与 <a href="https://www.google.com">Google.com</a> 相同的根证书 GTS Root R1，交叉签名了有效期从 1998 至 2028 的 GlobalSign Root CA，兼容性较好。而 Let's Encrypt 的根证书 ISRG Root X1 所交叉签名的 DST Root CA X3 已过期，仅有的 ISRG Root X1 在一些旧设备和未更新的系统上未被信任。</li><li>支持自定义证书有效期，可以设置有效期 1 天到 90 天。</li><li>其 OCSP 服务在中国大陆设有节点，国内查询速度较快。</li></ol><p>而 GTS 相较于 Let's Encrypt 的不足之处有：</p><ol><li>不支持使用 Punycode 编码的域名（即含有中文、Emoji 等字符的域名）。</li><li>由于其根证书 GTS Root R1 和中间证书 GTS CA 1P5 均为 RSA 证书，GTS 无法提供全链 ECC 证书。而 Let's Encrypt 可以通过 <a href="https://letsencrypt.org/2020/09/17/new-root-and-intermediates.html">ISRG Root X2</a> 提供。</li></ol><p>由于 Firefox <a href="https://wiki.mozilla.org/CA/Revocation_Checking_in_Firefox#Short-Lived_Certificates">不会检验</a>有效期在 10 天内的证书的 OCSP 状态（而 Chrome 默认对任何证书均不检查），所以，申请 10 天以内的证书可能能够提升网站的访问速度（特别是在无法使用 <a href="https://en.wikipedia.org/wiki/OCSP_stapling">OCSP stapling</a> 时）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于将 Web 服务部署在多个服务器与云服务的人来说，如何方便地申请并管理 SSL 证书，是一个值得思考的问题。我使用 GitHub Actions 来自动申请/续期 ACME SSL 证书，部署到各个云平台上，并在自己管理的服务器上定期拉取证书。&lt;/p&gt;</summary>
    
    
    
    
    <category term="SRE" scheme="https://blog.men.ci/tags/SRE/"/>
    
    <category term="云计算" scheme="https://blog.men.ci/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="CI / CD" scheme="https://blog.men.ci/tags/CI-CD/"/>
    
    <category term="SSL" scheme="https://blog.men.ci/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>在 x86 中实现用户态与系统调用</title>
    <link href="https://blog.men.ci/x86-userland-and-syscall/"/>
    <id>https://blog.men.ci/x86-userland-and-syscall/</id>
    <published>2022-02-14T20:22:00.000Z</published>
    <updated>2024-12-03T06:23:58.001Z</updated>
    
    <content type="html"><![CDATA[<p>在现代操作系统中，应用程序的代码与内核代码的运行环境是隔离的，这被称为用户态与内核态。一般来说，用户态应用程序只能在进程内执行算法逻辑，无法直接访问内核态的数据，也无法执行操作硬件所需的特权指令，而是需要通过系统调用来与内核态交互，来执行各种对系统或硬件的操作。这样的设计保证操作系统可以对应用程序的行为有完全的控制，保障了系统的安全性与稳定性。</p><span id="more"></span><h1 id="%E9%97%AE%E9%A2%98" tabindex="-1">问题 <a class="headerlink" href="#%E9%97%AE%E9%A2%98"></a></h1><h2 id="%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" tabindex="-1">进程的生命周期 <a class="headerlink" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"></a></h2><p>在开始之前，我们先梳理一下，在不考虑特权级切换时，每个用户态进程的生命周期：</p><ul><li>在被创建时，为其分配虚拟地址空间（页目录与页表），为其堆/栈内存，并将参数写入；</li><li>在第一次被调度时，执行其主函数；</li><li>若进程运行时发生中断（或异常，下略），由 CPU 跳转回内核，内核保存状态并处理中断；<ul><li>如果中断中没有发生重调度，则完成中断处理并返回到用户态；</li><li>如果中断中发生了重调度（常发生在时钟中断），则保存状态并进行上下文切换，在下次切换回该进程时从中断返回到用户代码；</li></ul></li><li>进程运行时，调用内核来完成各种任务，并从内核返回结果；<ul><li>同样地，进程在运行完成后，调用内核来结束自身。</li></ul></li></ul><p>所以，从内核态进入用户态的情况有：<strong>首次调度进程时</strong>、<strong>处理中断完成后返回时</strong>和<strong>系统调用返回时</strong>。<br>相对地，从用户态进入内核态的情况有：<strong>发生中断时</strong>和<strong>进行系统调用时</strong>。</p><h2 id="%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88" tabindex="-1">用户栈与内核栈 <a class="headerlink" href="#%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88"></a></h2><p>在 x86 平台的通常约定中，我们使用 <code>SP</code> 来保存指向栈顶的指针，在入栈/出栈时修改 <code>SP</code> 并写入/读取其所指向的内存。使用栈的代码需要自行保证栈指针的正确维护，当 <code>SP</code> 指向无效内存时，对栈的操作将产生异常。</p><p>在引入特权级之前，每个进程有自己的一块栈空间，由于应用程序和内核的代码时单纯的函数调用的关系，所以它们都使用同样的栈空间。这就引入了一些问题：</p><ul><li>如果应用程序代码设置 <code>SP</code> 指向无效内存地址，则会导致内核代码运行时产生异常。</li><li>如果应用程序代码设置 <code>SP</code> 指向存放其他数据的内存地址，则可能导致内核信息泄露或关键数据被覆写。</li><li>如果应用程序在系统调用/中断处理完成后，读取比栈顶更低地址处的数据，则会导致内核信息泄露。</li></ul><p>引入特权级之后，为了让用户态代码能够正常使用栈，栈空间必须设为用户态可访问，所以以上影响内核安全性与稳定性的问题仍然存在。为了解决这些问题，我们引入<strong>用户栈</strong>与<strong>内核栈</strong>的隔离。</p><ul><li>每个进程有两个栈，内核栈仅内核态可访问，用户栈在用户态也可访问。</li><li>在每个进程中执行用户态代码时，使用该进程的用户栈；执行内核态代码时，使用该进程的内核栈。</li></ul><p>在用户态下，当<strong>进行系统调用</strong>与<strong>发生中断</strong>时，即需要从用户态切换到内核态时，我们将 <code>SP</code> 指针切换为当前进程内核栈的栈底（最高地址），并保存切换前的 <code>SP</code> 指针，以便在返回用户态时恢复。</p><p><strong>注</strong>：在内核态下发生中断时，因为我们已经在使用内核栈，所以不能也不需要切换栈。</p><div class="flex-wrapper"><blockquote><p><strong>为什么每个进程有独立的内核栈（而不是整个系统使用同一个内核栈）？</strong></p><p>每个进程在上下文切换到另一进程前，即被挂起前，均处于内核态（发生中断或 <code>sleep</code> / <code>wait</code> 等系统调用），所以每个被挂起的进程都在占用内核栈，所以一个内核栈无法满足多个进程的需要，必须为每个进程独立分配一个内核栈。</p></blockquote></div><h2 id="%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" tabindex="-1">系统调用 <a class="headerlink" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"></a></h2><p>因为从用户态陷入内核态的方式是有限的，且内核态被调用的位置是固定的（为安全起见，由内核态实现设为固定值），所以我们往往在内核态中实现一个分发系统调用的函数，并通过寄存器或栈将调用行为（被调用的系统调用 ID、参数数量、参数列表、返回值传递地址）从用户态传递到该函数中，由该函数去调用目标的系统调用处理函数。</p><p>为了系统调用能够顺利返回，我们还需要告知内核，返回的位置和返回后的栈指针 <code>SP</code> 值（因为系统调用会切换到内核栈）。</p><p>为了防止信息泄露，我们需要在从内核态返回用户态之前将寄存器中的状态清除，所以我们需要在处理系统调用之前（在进入内核之前/之后均可）保存现场，在完成系统调用处理后恢复。</p><p>在每个进程<strong>首次进入用户态</strong>时，我们可以用与<strong>从系统调用返回</strong>相同的方式来实现内核态到用户态的切换，只需要「返回」到进程入口函数即可。</p><h1 id="x86-%E5%AE%9E%E7%8E%B0" tabindex="-1">x86 实现 <a class="headerlink" href="#x86-%E5%AE%9E%E7%8E%B0"></a></h1><h2 id="%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8" tabindex="-1">特权级与描述符表 <a class="headerlink" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"></a></h2><p>在 x86 架构的保护模式下，我们有四个可以使用的特权级：从 Ring 0 到 Ring 3。其中 Ring 0 为最高特权级，我们在 Ring 0 上运行内核代码，并在最低的 Ring 3 上运行用户代码。其余的两个 Ring 是不需要的。</p><p>我们需要关注以下三个不同的特权级概念：</p><ul><li><strong>CPL</strong>：<code class="punctuation-l">CS</code> 段寄存器，即代码段寄存器的低 2 位，描述了 CPL（Current Privilege Level，当前特权级），即正在哪个特权级上执行当前的指令<ul><li><code>CS</code> 不能作为 <code>MOV</code> 的目标，所以不能通过 <code>MOV</code> 改变特权级</li><li>当发生跳转改变 <code>CS</code> 时，CPL 不会改变，即特权级不会随着跳转类指令（<code class="punctuation-r punctuation-l">JMP</code>、<code class="punctuation-l">CALL</code> 和 <code>RET</code> 等）改变</li></ul></li><li><strong>RPL</strong>：每个数据段寄存器（如 <code class="punctuation-r">SS</code>、<code class="punctuation-l">DS</code> 和 <code>FS</code> 等）的低 2 位，描述了<strong>使用该段寄存器访问内存时</strong>的 RPL（Requested Privilege Level，请求特权级），即在高特权级下使用<strong>低特权级</strong>的权限去访问内存<ul><li>RPL 可以通过使用 <code>MOV</code> 指令改变段寄存器的方式来改变</li><li>一般保持 RPL 与 CPL 相等即可，即总是使用当前的特权级来访问内存</li></ul></li><li><strong>DPL</strong>：描述符表中的每个段拥有一个 DPL（Descriptor Privilege Level，描述符特权级）属性，代表<strong>访问这个段所需</strong>的特权级<ul><li>如果是代码段，则表示<strong>读或执行</strong>该段所需的特权级；如果是数据段，则表示<strong>读或写</strong>该段所需的特权级</li><li><strong>所需</strong>的特权级是指，CPL 与 RPL 中的较小值（低特权级请求高特权级没有意义），必须小于（更高权限）目标段的 DPL</li></ul></li></ul><p>然而在平坦内存模型中，我们并不需要利用如此复杂的机制：</p><ul><li><strong>忽略 DPL</strong>：为内核态和用户态分别设置两个段（代码段和数据段），均指向整个内存</li><li><strong>忽略 RPL</strong>：在内核态与用户态中直接使用 CPL（或者直接使用 0）作为 RPL</li></ul><p>所以，在 GDT（Global Descriptor Table，全局描述符表）中，我们把 1、2 号描述符作为内核代码/数据段，3、4 号描述符作为用户代码/数据段。</p><h2 id="%E4%B8%AD%E6%96%AD%E4%B8%8E-tss" tabindex="-1">中断与 TSS <a class="headerlink" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E-tss"></a></h2><p>我们刚刚提到，当用户态下发生中断时，我们需要切换栈到内核态。而在 x86 中，中断由 CPU 以一种特殊<strong>函数调用</strong>的形式通知到内核，所以需要进入中断处理函数前切换到内核栈，所以在 x86 中这个切换的过程只能由 CPU 来完成。</p><p>x86 使用 TSS（Task Status Segment，任务状态段）来描述当前正在运行的任务的信息，并基于此提供了硬件多任务（上下文切换）的功能。我们并不需要硬件多任务，只需要关注 TSS 中的 <code>ESP0</code> 属性（意为 ESP for Ring 0，即用于内核态的栈指针）即可。当在非 0 特权级发生中断时，CPU 会从当前任务的 TSS 中读取 <code>ESP0</code> 属性，并赋值给 <code class="punctuation-r">ESP</code>，随后调用中断处理函数。</p><p>由于不需要硬件多任务，我们只需要一个 TSS 实例。将 TSS 存储到共享内存区域（在每个进程的地址空间中均被映射）中，并在每次上下文切换前将它的 <code>ESP0</code> 更新为新进程的内核栈地址即可。</p><p>使用 TSS 的方式是，在 GDT 中加入一个描述符，指向 TSS 结构，并使用 <code>LTR</code> 指令加载这个段，即可设置当前 CPU 所使用的 TSS。</p><div class="flex-wrapper"><blockquote><p>由于中断是一种特殊的函数调用，所以通过 <code>IRET</code> 返回时，将由 CPU 来负责返回后继续执行之前的任务，即切换回 Ring 3，切换回用户栈，并回到发生中断前的 <code class="punctuation-r">EIP</code>。</p></blockquote></div><h2 id="%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1" tabindex="-1">系统调用 <a class="headerlink" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"></a></h2><p>在 x86 中从用户态（Ring 0）进入内核态（Ring 3）有多种方式，如软中断、异常、调用门和 <code>SYSENTER/SYSCALL</code> 指令等，其中后两种也可以用于从内核态进入用户态。在此我们使用 <code>SYSENTER</code> 指令（仅 x86 可用，x64 中由 <code>SYSCALL</code> 指令取代）。</p><div class="flex-wrapper"><blockquote><p>在 Pentium II 引入 <code>SYSENTER</code> 之前，触发<strong>无效指令异常</strong>曾是 80386 上最快进入内核态的方式，这在当时<a href="https://devblogs.microsoft.com/oldnewthing/?p=37003">被用于 Windows 中</a>。</p></blockquote></div><p><code>SYSENTER</code> 要求我们在内核态中提前告知 CPU，返回内核时需要设置的 <code class="punctuation-r">CS</code>、<code class="punctuation-l">EIP</code> 和 <code>ESP</code> 值（考虑到唯一需要手动从用户态进入内核态的场景是进行系统调用，这里所需的即是<strong>系统调用分发函数</strong>的入口与当前进程<strong>内核栈</strong>的栈底），在执行时仅做特权级切换、栈切换和跳转三件事，具体地：</p><ul><li>在进入用户态前，内核需要将参数写入以下 MSR（Model Specific Register，模型特定寄存器）<ul><li><strong><code>IA32_SYSENTER_CS  = 0x174</code></strong>: 内核态 <code>CS</code> 寄存器的值</li><li><strong><code>IA32_SYSENTER_ESP = 0x175</code></strong>: 进入内核态时要设置的 <code>ESP</code> 寄存器的值（即内核栈的地址）</li><li><strong><code>IA32_SYSENTER_EIP = 0x176</code></strong>: 进入内核态时要设置的 <code>EIP</code> 寄存器的值（即系统调用分发函数的入口地址）</li></ul></li><li>当在用户态执行 <code>SYSENTER</code> 指令时，CPU 会<ul><li>将 <code>CS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值</li><li>将 <code>SS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 8（也就是说，期望<strong>内核数据段</strong>是<strong>内核代码段</strong>的下一个）</li><li>不会从 GDT 中加载对应段的信息，而是默认此时 <code>CS</code> 与 <code>SS</code> 段是遵从扁平内存模型的代码段（可读可执行）与数据段（可读可写），且 DPL 为 0（无需关心）</li><li>将 <code>ESP</code> 设为 <code>IA32_SYSENTER_ESP</code> 的值</li><li>将 <code>EIP</code> 设为 <code>IA32_SYSENTER_EIP</code> 的值</li><li>寄存器状态被保留</li><li>切换到 Ring 0，从设置后的 <code>CS:EIP</code> 开始执行</li></ul></li><li>当在内核态执行 <code>SYSEXIT</code> 指令时，CPU 会<ul><li>将 <code>CS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 16（也就是说，期望<strong>用户代码段</strong>是<strong>内核数据段</strong>的下一个）</li><li>将 <code>SS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 24（也就是说，期望<strong>用户数据段</strong>是<strong>用户代码段</strong>的下一个）</li><li>不会从 GDT 中加载对应段的信息，而是默认此时 <code>CS</code> 与 <code>SS</code> 段是遵从扁平内存模型的代码段（可读可执行）与数据段（可读可写），且 DPL 为 0（无需关心）</li><li>将 <code>ESP</code> 设为 <code>ECX</code> 的值（应在系统调用时由用户态告知）</li><li>将 <code>EIP</code> 设为 <code>EDX</code> 的值（应在系统调用时由用户态告知）</li><li>寄存器状态被保留</li><li>切换到 Ring 3，从设置后的 <code>CS:EIP</code> 开始执行</li></ul></li></ul><p>所以，<code class="punctuation-l">SYSENTER</code> 与 <code>SYSEXIT</code> 所需要的段排列顺序为：</p><ol><li>内核代码段</li><li>内核数据段</li><li>用户代码段</li><li>用户数据段</li></ol><p>我们只需要以上四个段，将 GDT 的第 5 项设为上文中提到的 <a href="#%E4%B8%AD%E6%96%AD%E4%B8%8E-tss">TSS</a> 即可。</p><div class="flex-wrapper"><blockquote><p>由于系统调用进入内核态后会进行函数调用，会破坏上下文，所以建议在进入内核态前保存上下文。</p><p>由于 <code>ECX</code> 与 <code>EDX</code> 将用于为 <code>SYSEXIT</code> 系统调用传参，所以不能使用这两个寄存器来存放返回值。</p></blockquote></div><h2 id="%E9%A1%B5%E6%9D%83%E9%99%90" tabindex="-1">页权限 <a class="headerlink" href="#%E9%A1%B5%E6%9D%83%E9%99%90"></a></h2><p>页目录项与页表项中有一个 User/Supervisor 位，将该字段被设为 1 时，表示对应的页面（或范围内的页面）<strong>可在用户态（非 Ring 0）访问</strong>，否则当该字段被设为 0 时，<strong>仅可在内核态（Ring 0）访问</strong>。</p><p>当页表项与其所属页表的页目录项中 User/Supervisor 位的值不同时，取较严格的一项限制，即仅当两处设置均为 1 时，该页可在用户态访问。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在现代操作系统中，应用程序的代码与内核代码的运行环境是隔离的，这被称为用户态与内核态。一般来说，用户态应用程序只能在进程内执行算法逻辑，无法直接访问内核态的数据，也无法执行操作硬件所需的特权指令，而是需要通过系统调用来与内核态交互，来执行各种对系统或硬件的操作。这样的设计保证操作系统可以对应用程序的行为有完全的控制，保障了系统的安全性与稳定性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="x86" scheme="https://blog.men.ci/tags/x86/"/>
    
    <category term="内核" scheme="https://blog.men.ci/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Android 与 iOS 安全机制对比</title>
    <link href="https://blog.men.ci/mobile-security-compare/"/>
    <id>https://blog.men.ci/mobile-security-compare/</id>
    <published>2022-02-02T13:21:00.000Z</published>
    <updated>2024-12-03T06:23:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>本文曾为本人一门课程的期末报告，其中有些内容可能不够准确与全面，欢迎大家指正。</p><p>作为现代移动操作系统，Android 和 iOS 都有较为完善的安全机制。本文将从若干个方面分析对比其安全机制的异同。</p><span id="more"></span><h1 id="%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85" tabindex="-1">应用程序安装 <a class="headerlink" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85"></a></h1><p>在 Android 设备上，应用程序往往以 <code>apk</code> 安装包（另有 <code>obb</code> 数据包与整体打包的 <code>xapk</code> 等格式，但核心仍是 <code class="punctuation-r">apk</code>）的形式发布。每个应用程序有其包名（通常是倒序分隔的域名，如 <code class="punctuation-r">org.mozilla.firefox</code>）和版本号，应用程序在发布前需要由发布者使用其 RSA 私钥进行<a href="https://source.android.google.cn/security/apksigning?hl=zh_cn">数字签名</a>。当安装与已存在的包名相同的包时，Android 系统会使用拒绝<strong>签名公钥不一致</strong>或<strong>版本号更低</strong>的应用程序覆盖原有的应用程序。</p><p>基于 Android 系统的软件包安装机制，一个常见的攻击手段是重打包攻击：对软件包进行解包，加入恶意代码（比如窃取用户在该软件中登录所用的凭据）后重新打包并签名，并诱使用户安装。如果包名没有修改，且原软件包已安装，则 Android 系统会拒绝安装签名公钥不一致的新软件包，但攻击者可以修改包名并诱导用户安装看似一致的新安装包。开发者常使用签名验证的方式来防止重打包攻击，但攻击者也可通过逆向分析与 Hook 等手段绕过验证。Google 官方的 Play Store 也提供软件包分发服务，其能避免一部分威胁，但其对软件包内容<strong>审核较为宽松</strong>，导致一些名称相似的恶意软件能够在 Play Store 上发布。另一方面，Android 允许用户自行安装 <code>apk</code> 包，所以很多用户常常通过其他途径获得软件包并安装。所以，<strong>重打包攻击</strong>仍然是 Android 生态中的一大威胁。</p><p>在 iOS 设备上，软件包的格式为 <code class="punctuation-r">ipa</code>。但 <code>ipa</code> 的安装需要经过 Apple 的验证，iOS 仅接受被 Apple 允许在当前设备上安装的 <code>ipa</code> 软件包。且 iOS 有强制的代码签名检查机制，所有的可执行文件都必须具有<strong>可被 Apple 接受的签名</strong>，这在一定程度可以缓解了一些应用程序漏洞产生的影响。iOS 上软件分发的方式分为两大类：</p><p>一是通过 Apple 官方的渠道进行发布（App Store 和 TestFlight，后者一般仅用于发布测试版软件，且安装受到限制），这种情况下，设备需要登录 Apple ID，在软件包时会向 Apple 请求该软件包，并由 Apple 认证后发回带有针对该 Apple ID 的签名的软件包，iOS 会进行检验并安装。由于必须经过 Apple 的认证，通过该途径安装应用一般不会遭到重打包攻击（前提是 Apple 的审核不出漏洞，不会为带有恶意代码的重打包软件过审）。从一些第三方「应用商店」（如爱思助手）安装也是这种途径，第三方工具会<strong>重放</strong>它们提前获得的带有 Apple 签名的 <code>ipa</code> 进行安装，这样安装软件也不会带来安全隐患。</p><p>二是通过 Apple 签发的个人证书、开发者证书或企业证书进行签名。每个个人 Apple ID 都可以向 Apple 申请一个证书，单次为应用程序签名的有效期为 7 天（可续签），但 Apple 限定每台设备只能同时安装<strong>三个</strong>通过个人证书签名的使用。开发者证书可以付费购买，并可用于在已在该开发者账户上注册的设备上长期安装多个应用。企业证书的有效期和允许的软件包数量更大，并且可以向任意 iOS 设备分发。这三种方式均可在不经过 Apple 审核的情况下安装应用，但 iOS 在第一次运行前会警告用户其开发者未经验证，并引导用户在设置中选择信任。</p><div class="images"><div class="image"><a href="ios-trust-developer@2x.png" title="使用个人证书签名安装软件包，并在设置中选择信任" data-fancybox><img src="ios-trust-developer@2x.png" alt="iOS 信任开发者" title="使用个人证书签名安装软件包，并在设置中选择信任" srcset="ios-trust-developer@2x.png 2x"></a><p class="image-caption">使用个人证书签名安装软件包，并在设置中选择信任</p></div></div><p>这种私人发布的软件包，虽然签名过程仍然需要请求 Apple，但其安全性未经过 Apple 的审核，可能面临重打包攻击的威胁，然而由于其实施成本过高（个人证书有效期短且需要连接 PC 安装，开发者证书需要注册，企业证书价格贵且难以申请），所以实际应用较少。但不可否认的是，重打包攻击在 iOS 上仍然有一定可行性，在访问网页等操作时遇到不明的安装应用请求时也需要小心。</p><h1 id="%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E7%A7%81" tabindex="-1">权限与隐私 <a class="headerlink" href="#%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E7%A7%81"></a></h1><p>在 Android 6.0 之前，Android 应用程序在<strong>安装时</strong>请求所有权限。从 Android 6.0 开始，应用程序需要在运行时获取权限。大部分商业应用程序都会请求 <a href="https://developer.android.com/reference/android/Manifest.permission#READ_PHONE_STATE"><code>READ_PHONE_STATE</code></a> 权限，用于读取设备的 IMEI，作为用户的标识符，用于广告推送等用途。这使得用户极容易被跟踪。</p><p>值得一提的是，Android 提供了一个特权接口 <a href="https://developer.android.com/reference/android/app/AppOpsManager"><code>AppOpsManager</code></a>，可以用来对应用程序的权限进行高级管理。例如，在某个拥有 <code>READ_PHONE_STATE</code> 权限的应用程序读取 IMEI 时，为其<strong>返回无效数据</strong>（而不是产生异常使程序无法运行），以在应用程序正常工作的前提下保护隐私。访问该接口需要 <code>appop</code> 权限，该权限无法通过一般方式获取，只能通过 <code>pm grant</code> 授予（而调用 <code>pm grant</code> 需要 ADB Shell 或 root 的权限）。可能是出于广告相关的商业利益考量，Google 没有提供对应的用户界面，市面上有一些调用该接口管理其他应用程序权限的应用程序，但由于操作较为复杂，且大部分用户并不关心隐私，所以使用者非常少。</p><div class="images"><div class="image"><a href="android-appops@2x.png" title="通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据" data-fancybox><img src="android-appops@2x.png" alt="AppOps 权限管理" title="通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据" srcset="android-appops@2x.png 2x"></a><p class="image-caption">通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据</p></div></div><p>一些第三方 Android 发行版拥有更强的权限管理，如 <a href="https://lineageos.org/">LineageOS</a> 可在应用程序每次尝试调用需要敏感权限（如定位）的接口时询问用户，或进行记录。使得用户可以察觉应用程序未经预料的访问敏感数据，或过于频繁地访问隐私数据的行为。</p><p>Android 可向应用程序提供较高的权限，如修改系统设置、连接 Wi-Fi 网络等。另外，Android 中存在一个特殊权限 —— Accessibility，该权限需要应用程序进行申请，并由用户在系统设置中手动选择启用，启用时系统还会进行警告。拥有该权限的应用程序可<strong>拦截/模拟用户的输入操作</strong>，以实现无障碍访问等辅助功能。但若恶意应用程序诱使用户授予该权限，则可以在一定程度上控制整个设备的行为，对设备安全产生极大的威胁。</p><p>iOS 的权限管理模型与 6.0 之后的 Android 类似 —— 应用程序在运行时向用户申请权限。在 iOS 下，应用程序可以申请的权限较少，一方面这提升了系统的安全性，但另一方面也使得某些功能无法实现。严格的权限限制是一把双刃剑，Apple 选择了收紧权限，并由系统软件提供这部分功能。</p><p>与 Android 下可直接获取不同，较新版本的 iOS 不允许应用程序获取几乎所有的设备标识符（包括但不限于 IMEI、Wi-Fi MAC 地址，蓝牙 MAC 地址等），并要求应用程序使用 Apple 专门提供的<strong>广告 ID</strong> 进行追踪。且该 ID 可被用户禁用或重置。这在一定程度上保护了用户隐私。</p><div class="images"><div class="image"><a href="ios-ad-id@2x.png" title="在 iOS 系统设置中配置广告 ID" data-fancybox><img src="ios-ad-id@2x.png" alt="iOS 广告 ID" title="在 iOS 系统设置中配置广告 ID" srcset="ios-ad-id@2x.png 2x"></a><p class="image-caption">在 iOS 系统设置中配置广告 ID</p></div></div><p>相对于获取设备标识符，定位权限往往是用户更为担忧的。iOS 14 提供了限制应用程序获得的位置信息精度的功能，应用程序在请求定位权限时，用户可将「精确」设为关闭，以使得应用程序仅获得<strong>大致的位置信息</strong>。该位置信息能够帮助应用程序定位用户所在的城市，但无法进行精确地追踪。</p><div class="images"><div class="image"><a href="ios-location-precise@2x.png" title="在某第三方应用请求权限时，选择为其提供不精确的位置信息" data-fancybox><img src="ios-location-precise@2x.png" alt="iOS 关闭精确定位" title="在某第三方应用请求权限时，选择为其提供不精确的位置信息" srcset="ios-location-precise@2x.png 2x"></a><p class="image-caption">在某第三方应用请求权限时，选择为其提供不精确的位置信息</p></div></div><h1 id="%E6%B2%99%E7%9B%92" tabindex="-1">沙盒 <a class="headerlink" href="#%E6%B2%99%E7%9B%92"></a></h1><p>在 Android 和 iOS 下，一般的应用软件都运行在沙盒中。</p><p>Android 的沙盒机制基于 Linux 内核提供的多用户功能。每个应用程序在安装时被分配一个用户 ID（UID），其数据目录被标记为仅该 UID 可访问。并使用用户组（groups）机制来为应用程序授予访问系统资源的权限（如，对应用户拥有 <code>sdcard_rw</code> 组的应用程序，可以访问 <code>/sdcard</code> 路径）。该机制较为简单，并且受益于 Linux 内核的可靠性，其对于基本的安全性有很大的保障。</p><p>在很多时候，Android 的沙盒机制并没有将不同的应用程序进行隔离，应用程序仍然可以通过系统提供的途径相互通信。例如，应用程序之间可以通过 Intent 来相互传递消息，可以以此唤起另一个应用程序的 Activity 等。其中较为不安全的一点是，应用程序可以将数据写入到 <code>/sdcard</code> 路径中，以便其他任何应用程序访问。很多应用程序将敏感数据放置在该路径下，这可能会导致<strong>隐私追踪</strong>和<strong>数据泄露</strong>的问题。自 Android 10 起，Google 已经不鼓励，甚至<a href="https://source.android.google.cn/devices/storage?hl=zh-cn">将要禁止</a>应用程序使用 <code>/sdcard</code> 共享数据。</p><p>较新版本的 Android 还<a href="https://source.android.google.cn/security/selinux?hl=zh_cn">通过 SELinux</a> 实现了系统组件的 DAC（强制访问控制），对系统特权进程进行更严格的权限控制，尽量仅授予必需系统资源的访问权限，以进一步更加系统的安全性，防止一些高权限系统组件在受到漏洞攻击时泄露过大的权限。</p><p>相比之下，iOS 的沙盒机制更为复杂，也更为严格。与 Android 相同，iOS 的应用程序的文件系统访问也被限制在其私有的数据目录下。但与 Android 基于 UNIX 用户的隔离不同，iOS 下所有的第三方应用程序均运行在 <code>mobile</code> 用户下，该用户本身拥有访问绝大多数系统资源的权限，但 iOS 对系统调用进行了限制：iOS 根据应用程序所拥有的权限，为其维护一个<strong>沙盒配置文件</strong>（Sandbox Profile），并在内核中系统调用的关键路径上增加了一个 <strong>MAC 层</strong>，以检查应用程序是否有权限进行当前的系统调用，仅当有权限才会继续执行。这种限制方式与 Linux 下的 <code>ptrace</code> / <code>seccamp</code> 类似。</p><p>iOS 应用之间的隔离更为严格 —— 首先，由于后台机制的不同，iOS 的应用程序没有期望常驻后台的 Service 组件，难以在后台保持运行，所以，自然地，一个应用程序也不被期望直接向另一个运行中的应用程序发送消息（使用共享目录中的 UNIX Socket 可能是一种可行的方案，但意义不大）。iOS 系统提供以下几种应用间通信的方式：</p><ul><li>当需要调用另一个应用程序提供的功能供用户临时进行操作（如调用移动支付软件进行付款）时，往往使用系统提供的 URL Scheme 功能 —— 应用程序可以定义其接受的 URL 前缀（如 Alipay 定义了 <code>alipay://</code> 前缀），并由欲调用的应用程序通知系统进行调用，系统会启动目标应用程序，将 URL 传递过去，由目标应用程序进行解析并处理。</li><li>当需要调用另一个应用程序来发送/打开特定的文件时，可以使用 Share Sheet 功能。该功能被调用后，系统会弹出一个菜单，要求用户选择要调用的应用程序，用户选择后，iOS 系统会将文件复制到目标应用的沙盒中，并启动目标应用，将调用信息告知。</li><li>当需要与另一个（或一些）特定的应用程序共享<strong>凭据</strong>（如 Gmail 与 Chrome 可共享 Google 账号的登录信息），可以使用 Keychain 接口，该接口仅提供跨应用程序的数据存储，没有传递消息的功能。</li></ul><p>可见，iOS 的应用间通信接口被高度特化，且难以在用户<strong>无感知</strong>的情况下调用另一个应用程序。这在一定程度上避免了串谋权限攻击和一些隐私泄露问题。</p><h1 id="%E5%BC%95%E5%AF%BC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7" tabindex="-1">引导与系统完整性 <a class="headerlink" href="#%E5%BC%95%E5%AF%BC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7"></a></h1><p>现代 Android 设备采用了 Verified Boot 技术来保证系统引导的安全性。设备在出厂时附带<strong>厂商的公钥</strong>，作为信任根（Root of Trust），在设备启动时，引导加载程序（固化在 ROM 中）会对操作系统的完整性进行检验。被检验的数据包括 <code>boot</code> 分区（Linux 内核和引导所需文件）、<code class="punctuation-l">system</code> 分区（Android 系统）和 <code>vendor</code> 分区（设备厂商提供的系统文件）等。对于 <code class="punctuation-r">boot</code>、<code class="punctuation-l">vendor</code> 等较小的分区，引导加载程序会在引导时进行验证，对于较大的 <code>system</code> 分区，系统会保存其<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E6%A0%91">默克尔树（Merkle Tree）</a>，在使用时动态的验证被访问到的部分，如果验证不通过则产生 I/O 错误。</p><p>Android <a href="https://source.android.google.cn/security/verifiedboot/device-state?hl=zh_cn">引导加载程序</a>往往是被锁定（LOCKED）的。位于锁定状态下的引导加载程序仅接受厂商在 ROM 中内置的信任根，而拒绝加载未经厂商验证的操作系统，这使得攻击者即使获得物理访问或者 root 权限，也无法对系统进行持久化的修改，因为任何修改都会使得自底向上<strong>信任链失效</strong>，进而使设备拒绝引导/工作。</p><p>另一方面，Android 引导加载程序往往允许用户进行解锁。位于解锁（UNLOCKED）状态下的引导加载程序允许用户自定义被加载的操作系统。一些实现允许用户将自己的公钥作为信任根，并安装自行签名的操作系统；用户也可完全关闭引导验证功能，让引导加载程序加载任何操作系统。攻击者在拥有设备的物理访问后，可通过解锁引导加载程序来修改操作系统，进而完全控制设备并窃取用户数据，考虑到这一安全隐患，引导加载程序在解锁时会<strong>清空所有用户数据</strong>。同时，为了避免用户的设备在不知情的情况下被解锁并植入恶意软件，已解锁的引导加载程序会在设备启动时显示<strong>警告信息</strong>，告知用户其设备正在加载自定义操作系统。</p><p>Android 设备往往使用 <a href="https://source.android.google.cn/devices/bootloader/recovery-image?hl=zh-cn">Recovery</a> 环境更进行系统更新与还原，该模式位于 <code>recovery</code> 分区中，包含一个由厂商预先写入的小型操作系统，同时，该分区同样受 Verified Boot 的保护。Recovery 模式往往仅接受由厂商验证过的操作系统。为了防止降级以利用旧版本的安全漏洞，有些厂商也会拒绝安装比现有版本更低的操作系统。在解锁引导加载程序后，用户也可替换原有的 Recovery 环境，方便进行自定义操作系统的安装与维护。</p><div class="images"><div class="image"><a href="android-unlocked-bootloader.png" title="Android 引导加载程序解锁后的警告" data-fancybox><img src="android-unlocked-bootloader.png" alt="Android 引导加载程序解锁后的警告"></a><p class="image-caption">Android 引导加载程序解锁后的警告</p></div><div class="image"><a href="android-custom-recovery.png" title="Android 自定义 Recovery" data-fancybox><img src="android-custom-recovery.png" alt="Android 自定义 Recovery"></a><p class="image-caption">Android 自定义 Recovery</p></div></div><p>iOS 也采用了信任链的方式来保证系统引导的安全性。iOS 设备启动时首先加载被固化到硬件中的安全引导程序 <a href="https://www.theiphonewiki.com/wiki/Bootrom">SecureROM</a>，该程序正常情况下会验证并加载闪存中的引导加载程序 iBoot，并由 iBoot 对 Darwin 内核进行验证并加载。Darwin 内核在加载用户态的可执行程序时，会验证其数字签名，如果系统的可执行文件没有 Apple 的签名，则拒绝执行。同样，即使攻击者在 iOS 系统中获得了 root 权限，也无法通过对系统产生持久化的影响。</p><p>SecureROM 的另一个功能是 <a href="https://www.theiphonewiki.com/wiki/DFU_Mode">DFU（Device Firmware Upgrade）</a> 模式。在 iOS 系统损坏时，可进入 DFU 模式以通过 USB 连接到计算机，并重新安装操作系统。在 iOS 设备上，操作系统的安装需要 Apple 的签名，且该签名与每次安装有关（被签名随机数由 SecureROM 在安装操作系统时生成，并被持久存储以在每次引导时验证），以避免设备安装被修改过的操作系统，或已被 Apple 禁止安装的 iOS 版本。在已取得 root 权限的情况下，可通过重放曾被成功签名的随机数的方式安装旧版本系统，但在（下文中提到的）SEP 未被攻破的前提下，SEP OS 无法降级，将可能导致兼容性问题。</p><p>值得一提的是，SecureROM 在加载后，会<strong>禁用</strong> SecureROM 所在存储区域的<strong>读权限</strong>，使得在 iOS 中，即使获得了高权限，也无法读取 SecureROM 的代码，给安全人员的分析带来了极大的困难。但安全人员仍然发现了其中 DFU 模式下的一个 use-after-free 漏洞（checkm8，意为「checkmate」，即象棋中的「绝杀无解」，寓意漏洞在 ROM 中不可修复），并通过该漏洞实现了任意代码执行。<a href="https://checkra.in">checkra1n</a> 是一个利用该漏洞的工具，其利用该漏洞来控制 DFU 模式下设备的引导，并在进入 iOS 后安装一个向用户提供 root 权限的系统应用程序。</p><div class="images"><div class="image"><a href="ios-checkra1n-cli@2x.png" title="使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备" data-fancybox><img src="ios-checkra1n-cli@2x.png" alt="checkra1n 工具运行" title="使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备" srcset="ios-checkra1n-cli@2x.png 2x"></a><p class="image-caption">使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备</p></div><div class="image"><a href="ios-checkra1n-boot.png" title="被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）" data-fancybox><img src="ios-checkra1n-boot.png" alt="checkra1n 攻击成功" title="被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）"></a><p class="image-caption">被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）</p></div></div><p>在设备丢失或被盗时，非法持有者无法解开设备的密码锁，可能会通过重新安装操作系统的方式使用设备。iOS 设备在用户登录 Apple ID 后，会将设备记录到 Apple 的服务器上（即「Find My iPhone」功能，也就是通常所说的「ID 锁」），当该设备重新安装操作系统后，Apple 会要求用户再次登录该 Apple ID 以激活设备。这使得非法持有者无法使用设备。Android 也有类似的机制，但在引导加载程序解锁后不再有效。所以，为了保证安全，Android 设备对引导加载程序的解锁，往往需要用户在系统内和引导加载程序中进行两次确认。</p><h1 id="%E5%8A%A0%E5%AF%86" tabindex="-1">加密 <a class="headerlink" href="#%E5%8A%A0%E5%AF%86"></a></h1><p>Android 和 iOS 都具有加密文件系统以保护用户数据的功能。</p><p>Android 的加密分为两种：<a href="https://source.android.google.cn/security/encryption/full-disk?hl=zh-cn">全盘加密（Full Disk Encryption）</a>和<a href="https://source.android.google.cn/security/encryption/file-based?hl=zh-cn">文件级加密（File-Based Encryption）</a>。</p><p><a href="https://source.android.google.cn/security/encryption/full-disk?hl=zh-cn">全盘加密</a>引入于 Android 4.4，在 Android 10 中去除。其原理是，系统在初始化时随机生成一个 128 位的主密钥，并使用此密钥与 AES 算法将数据分区（<code class="punctuation-r punctuation-l">data</code>）加密。当用户设置密码时，主密钥被使用用户设置的密码加密后储存起来（根据设备支持情况，储存在闪存或硬件安全存储中）。当用户修改密码时，主密钥不会改变，所以数据不需要被重新加密。全盘加密有一个缺点 —— 由于应用程序依赖于数据分区，而在设备启动后，用户第一次输入密码前，设备的数据分区是未被解密的，所以用户<strong>无法使用</strong>包括闹钟、电话在内的<strong>任何功能</strong>。</p><p>为了解决解锁前无法使用任何设备功能的问题，Android 7.0 引入了<a href="https://source.android.google.cn/security/encryption/file-based?hl=zh-cn">文件级加密</a>。文件级加密可对每个文件单独进行加密，并且支持对不同文件使用不同的密钥加密。一般来说，文件级加密体系中有 CE（Credential Encrypted，凭据加密）和 DE（Device Encrypted，设备加密）两个密钥，前者用于加密用户的<strong>大部分数据</strong>，后者用于加密需要在<strong>解锁设备前访问</strong>的数据。CE 所用的密钥被以类似于全盘加密主密钥的形式加密存储，DE 所用的密钥被直接存储。应用程序可以选择其存储的特定数据使用 CE 还是 DE 进行加密 —— 如闹钟应用程序可将设定的闹钟列表存储在 DE 中，在设备启动后解锁前即可工作。而安全敏感的数据，如 Google 账户凭据则存放在 CE 中，仅在用户解锁设备后可访问。</p><p>iOS 的加密与 Android 的文件级加密类似，同样是对每个文件分别加密。此外，为了防止物理攻击，每台 iOS 设备的 TPM 模块（被称为 Secure Enclave Processor，SEP）中会内置一个独一无二的主密钥，文件加密的密钥均由该密钥派生而来，且无法在可信的操作系统之外获得，这使得攻击者无法卸下闪存芯片并使用其他设备对用户密码进行<strong>暴力破解</strong>。搭载了类似的硬件安全密钥存储模块的 Android 设备也能够达到同样的安全性。</p><div class="images"><div class="image"><a href="ios-key-management.svg" title="iOS 使用 SEP 管理密钥" data-fancybox><img src="ios-key-management.svg" alt="iOS 的密钥管理" title="iOS 使用 SEP 管理密钥"></a><p class="image-caption">iOS 使用 SEP 管理密钥</p></div></div><p>相对于 Android 的文件夹机密，iOS 增加了一个更强的文件加密级别：对于极度敏感的数据（如用户的电子邮件），系统会在用户解锁时（使用用户密码和 TPM 中的密钥）对其密钥进行解锁，并在设备锁定时将解锁后的文件密钥<strong>从内存中删除</strong>，使得一些情况下，即使攻击者获得了较高权限，也无法在未解锁时读取敏感数据。</p><p>Android 和 iOS 都具有密码尝试次数过多后清除用户数据的功能，其实现方式是将被加密的密钥从闪存 / TPM 中清除，使得现有的数据<strong>无法再被解密</strong>。</p><h1 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结 <a class="headerlink" href="#%E6%80%BB%E7%BB%93"></a></h1><p>总的来说，Android 的安全体系较为<strong>开放</strong>，偏向于使用较为简单的安全策略来达到足够的安全性；而 iOS 的安全体系较为<strong>严格</strong>，偏向于使用多层次的安全策略，与硬件级的安全模块相结合，并强制加入 Apple 的控制，来将威胁降至最低。Android 的安全策略很大程度上受厂商定制的影响，一些厂商定制的 Android 设备可能具有更高或更低的安全性。</p><p>Android 的绝大多数安全功能依赖于 Linux 内核的安全性，而 Linux 内核少有可利用的漏洞。相比之下，iOS 的 Darwin 内核被爆出过更多的高危漏洞，安全性低于 Linux。较新版本的 iOS 加入了内核完整性保护（Kernel Integrity Protection）的功能，禁止一些敏感内存区域（如中断向量表）被修改，一定程度上降低了内核漏洞的危害。</p><p>在应用程序方面，早期的 Android 更加开放，表现的更加信任开发者。而 iOS 则尽可能少授予应用程序权限，以保证用户的隐私。较新版本的 Android 也有<strong>收紧权限控制</strong>的趋势。在系统底层，Android 与 iOS 都使用引导信任链来保证系统的完整性，并使用加密来保护用户数据。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文曾为本人一门课程的期末报告，其中有些内容可能不够准确与全面，欢迎大家指正。&lt;/p&gt;
&lt;p&gt;作为现代移动操作系统，Android 和 iOS 都有较为完善的安全机制。本文将从若干个方面分析对比其安全机制的异同。&lt;/p&gt;</summary>
    
    
    
    
    <category term="安全" scheme="https://blog.men.ci/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="Android" scheme="https://blog.men.ci/tags/Android/"/>
    
    <category term="iOS" scheme="https://blog.men.ci/tags/iOS/"/>
    
  </entry>
  
</feed>
