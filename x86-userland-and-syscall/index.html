<!doctype html><html lang=zh-CN><head><title>在 x86 中实现用户态与系统调用 - Menci&#39;s Blog</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=author content=Menci><meta name=description content=在现代操作系统中，应用程序的代码与内核代码的运行环境是隔离的，这被称为用户态与内核态。一般来说，用户态应用程序只能...><meta name=keywords content=""><link rel=alternate type=application/atom+xml title="ATOM 1.0" href=/atom.xml><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content=webkit><meta name=theme-color content=#ffffff><link rel="shortcut icon" type=image/x-icon href=//static.cdn.menci.xyz/menci-blog/avatar.6e993e78.png crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/KaTeX/0.15.2/katex.min.css crossorigin=anonymous><link rel=stylesheet href=//static.cdn.menci.xyz/menci-blog/css/journal.b205a034.css crossorigin=anonymous><link rel=stylesheet href="//cdn.menci.xyz/fonts/css2?family=Noto+Sans+SC:wght@300%3B400%3B600&family=Source+Sans+Pro:wght@400%3B600&family=Lato:wght@400%3B500&family=Hind+Vadodara:wght@300%3B400&family=Montserrat&family=Fira+Code&family=Material+Icons&display=block" crossorigin=anonymous><script async data-domain=blog.men.ci src=//stat.u.sb/js/plausible.js></script><meta name=generator content="Hexo 7.3.0"></head><body><div id=top></div><div id=app><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block false drawer-menu-item" href=https://blog.men.ci>首页 </a><a class="a-block false drawer-menu-item" href=/archives/ >归档 </a><a class="a-block false drawer-menu-item" href=/tags/ >标签 </a><a class="a-block false drawer-menu-item" href=/friends/ >朋友们 </a><a class="a-block false drawer-menu-item" href=/about-me/ >关于我</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar navbar-light single-column-nav-container sticky-top"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer><i class=material-icons>menu</i></button> <a ref=navTitle class=navbar-brand href=/ >Menci&#39;s Blog</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/ ><div class=single-column-header-title>Menci's Blog</div><div class=single-column-header-subtitle>念念不忘，必有回响</div></a></div><div ref=sideContainer class=side-container><a class="a-block false nav-head" href=/ ><div class=nav-title>Menci's Blog</div><div class=nav-subtitle>念念不忘，必有回响</div></a><div class=nav-link-list><a class="a-block false nav-link-item" href=/archives/ >归档 </a><a class="a-block false nav-link-item" href=/tags/ >标签 </a><a class="a-block false nav-link-item" href=/friends/ >朋友们 </a><a class="a-block false nav-link-item" href=/about-me/ >关于我</a></div><div class=nav-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="animated-visibility pagination-action" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image: url('')"><div class=post-title>在 x86 中实现用户态与系统调用<div class=post-meta><time datetime=2022-02-14T20:22:00.000Z itemprop=datePublished>2022-02-15 </time>&nbsp; <i class=material-icons style="">label</i> <a href=/tags/x86/ >x86</a>, <a href=/tags/内核/ >内核</a></div></div></div><div class=post-body-wrapper><div class=post-body><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#%E9%97%AE%E9%A2%98><span class=toc-number>1.</span> <span class=toc-text>问题</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F><span class=toc-number>1.1.</span> <span class=toc-text>进程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88><span class=toc-number>1.2.</span> <span class=toc-text>用户栈与内核栈</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8><span class=toc-number>1.3.</span> <span class=toc-text>系统调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class=toc-link href=#x86-%E5%AE%9E%E7%8E%B0><span class=toc-number>2.</span> <span class=toc-text>x86 实现</span></a><ol class=toc-child><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8><span class=toc-number>2.1.</span> <span class=toc-text>特权级与描述符表</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E4%B8%AD%E6%96%AD%E4%B8%8E-tss><span class=toc-number>2.2.</span> <span class=toc-text>中断与 TSS</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1><span class=toc-number>2.3.</span> <span class=toc-text>系统调用</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E9%A1%B5%E6%9D%83%E9%99%90><span class=toc-number>2.4.</span> <span class=toc-text>页权限</span></a></li></ol></li></ol><p>在现代操作系统中，应用程序的代码与内核代码的运行环境是隔离的，这被称为用户态与内核态。一般来说，用户态应用程序只能在进程内执行算法逻辑，无法直接访问内核态的数据，也无法执行操作硬件所需的特权指令，而是需要通过系统调用来与内核态交互，来执行各种对系统或硬件的操作。这样的设计保证操作系统可以对应用程序的行为有完全的控制，保障了系统的安全性与稳定性。</p><span id=more></span><h1 id=%E9%97%AE%E9%A2%98 tabindex=-1>问题 <a class=headerlink href=#%E9%97%AE%E9%A2%98></a></h1><h2 id=%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F tabindex=-1>进程的生命周期 <a class=headerlink href=#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F></a></h2><p>在开始之前，我们先梳理一下，在不考虑特权级切换时，每个用户态进程的生命周期：</p><ul><li>在被创建时，为其分配虚拟地址空间（页目录与页表），为其堆/栈内存，并将参数写入；</li><li>在第一次被调度时，执行其主函数；</li><li>若进程运行时发生中断（或异常，下略），由 CPU 跳转回内核，内核保存状态并处理中断；<ul><li>如果中断中没有发生重调度，则完成中断处理并返回到用户态；</li><li>如果中断中发生了重调度（常发生在时钟中断），则保存状态并进行上下文切换，在下次切换回该进程时从中断返回到用户代码；</li></ul></li><li>进程运行时，调用内核来完成各种任务，并从内核返回结果；<ul><li>同样地，进程在运行完成后，调用内核来结束自身。</li></ul></li></ul><p>所以，从内核态进入用户态的情况有：<strong>首次调度进程时</strong>、<strong>处理中断完成后返回时</strong>和<strong>系统调用返回时</strong>。<br>相对地，从用户态进入内核态的情况有：<strong>发生中断时</strong>和<strong>进行系统调用时</strong>。</p><h2 id=%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88 tabindex=-1>用户栈与内核栈 <a class=headerlink href=#%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88></a></h2><p>在 x86 平台的通常约定中，我们使用 <code>SP</code> 来保存指向栈顶的指针，在入栈/出栈时修改 <code>SP</code> 并写入/读取其所指向的内存。使用栈的代码需要自行保证栈指针的正确维护，当 <code>SP</code> 指向无效内存时，对栈的操作将产生异常。</p><p>在引入特权级之前，每个进程有自己的一块栈空间，由于应用程序和内核的代码时单纯的函数调用的关系，所以它们都使用同样的栈空间。这就引入了一些问题：</p><ul><li>如果应用程序代码设置 <code>SP</code> 指向无效内存地址，则会导致内核代码运行时产生异常。</li><li>如果应用程序代码设置 <code>SP</code> 指向存放其他数据的内存地址，则可能导致内核信息泄露或关键数据被覆写。</li><li>如果应用程序在系统调用/中断处理完成后，读取比栈顶更低地址处的数据，则会导致内核信息泄露。</li></ul><p>引入特权级之后，为了让用户态代码能够正常使用栈，栈空间必须设为用户态可访问，所以以上影响内核安全性与稳定性的问题仍然存在。为了解决这些问题，我们引入<strong>用户栈</strong>与<strong>内核栈</strong>的隔离。</p><ul><li>每个进程有两个栈，内核栈仅内核态可访问，用户栈在用户态也可访问。</li><li>在每个进程中执行用户态代码时，使用该进程的用户栈；执行内核态代码时，使用该进程的内核栈。</li></ul><p>在用户态下，当<strong>进行系统调用</strong>与<strong>发生中断</strong>时，即需要从用户态切换到内核态时，我们将 <code>SP</code> 指针切换为当前进程内核栈的栈底（最高地址），并保存切换前的 <code>SP</code> 指针，以便在返回用户态时恢复。</p><p><strong>注</strong>：在内核态下发生中断时，因为我们已经在使用内核栈，所以不能也不需要切换栈。</p><div class=flex-wrapper><blockquote><p><strong>为什么每个进程有独立的内核栈（而不是整个系统使用同一个内核栈）？</strong></p><p>每个进程在上下文切换到另一进程前，即被挂起前，均处于内核态（发生中断或 <code>sleep</code> / <code>wait</code> 等系统调用），所以每个被挂起的进程都在占用内核栈，所以一个内核栈无法满足多个进程的需要，必须为每个进程独立分配一个内核栈。</p></blockquote></div><h2 id=%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8 tabindex=-1>系统调用 <a class=headerlink href=#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8></a></h2><p>因为从用户态陷入内核态的方式是有限的，且内核态被调用的位置是固定的（为安全起见，由内核态实现设为固定值），所以我们往往在内核态中实现一个分发系统调用的函数，并通过寄存器或栈将调用行为（被调用的系统调用 ID、参数数量、参数列表、返回值传递地址）从用户态传递到该函数中，由该函数去调用目标的系统调用处理函数。</p><p>为了系统调用能够顺利返回，我们还需要告知内核，返回的位置和返回后的栈指针 <code>SP</code> 值（因为系统调用会切换到内核栈）。</p><p>为了防止信息泄露，我们需要在从内核态返回用户态之前将寄存器中的状态清除，所以我们需要在处理系统调用之前（在进入内核之前/之后均可）保存现场，在完成系统调用处理后恢复。</p><p>在每个进程<strong>首次进入用户态</strong>时，我们可以用与<strong>从系统调用返回</strong>相同的方式来实现内核态到用户态的切换，只需要「返回」到进程入口函数即可。</p><h1 id=x86-%E5%AE%9E%E7%8E%B0 tabindex=-1>x86 实现 <a class=headerlink href=#x86-%E5%AE%9E%E7%8E%B0></a></h1><h2 id=%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8 tabindex=-1>特权级与描述符表 <a class=headerlink href=#%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8></a></h2><p>在 x86 架构的保护模式下，我们有四个可以使用的特权级：从 Ring 0 到 Ring 3。其中 Ring 0 为最高特权级，我们在 Ring 0 上运行内核代码，并在最低的 Ring 3 上运行用户代码。其余的两个 Ring 是不需要的。</p><p>我们需要关注以下三个不同的特权级概念：</p><ul><li><strong>CPL</strong>：<code class=punctuation-l>CS</code> 段寄存器，即代码段寄存器的低 2 位，描述了 CPL（Current Privilege Level，当前特权级），即正在哪个特权级上执行当前的指令<ul><li><code>CS</code> 不能作为 <code>MOV</code> 的目标，所以不能通过 <code>MOV</code> 改变特权级</li><li>当发生跳转改变 <code>CS</code> 时，CPL 不会改变，即特权级不会随着跳转类指令（<code class="punctuation-l punctuation-r">JMP</code>、<code class=punctuation-l>CALL</code> 和 <code>RET</code> 等）改变</li></ul></li><li><strong>RPL</strong>：每个数据段寄存器（如 <code class=punctuation-r>SS</code>、<code class=punctuation-l>DS</code> 和 <code>FS</code> 等）的低 2 位，描述了<strong>使用该段寄存器访问内存时</strong>的 RPL（Requested Privilege Level，请求特权级），即在高特权级下使用<strong>低特权级</strong>的权限去访问内存<ul><li>RPL 可以通过使用 <code>MOV</code> 指令改变段寄存器的方式来改变</li><li>一般保持 RPL 与 CPL 相等即可，即总是使用当前的特权级来访问内存</li></ul></li><li><strong>DPL</strong>：描述符表中的每个段拥有一个 DPL（Descriptor Privilege Level，描述符特权级）属性，代表<strong>访问这个段所需</strong>的特权级<ul><li>如果是代码段，则表示<strong>读或执行</strong>该段所需的特权级；如果是数据段，则表示<strong>读或写</strong>该段所需的特权级</li><li><strong>所需</strong>的特权级是指，CPL 与 RPL 中的较小值（低特权级请求高特权级没有意义），必须小于（更高权限）目标段的 DPL</li></ul></li></ul><p>然而在平坦内存模型中，我们并不需要利用如此复杂的机制：</p><ul><li><strong>忽略 DPL</strong>：为内核态和用户态分别设置两个段（代码段和数据段），均指向整个内存</li><li><strong>忽略 RPL</strong>：在内核态与用户态中直接使用 CPL（或者直接使用 0）作为 RPL</li></ul><p>所以，在 GDT（Global Descriptor Table，全局描述符表）中，我们把 1、2 号描述符作为内核代码/数据段，3、4 号描述符作为用户代码/数据段。</p><h2 id=%E4%B8%AD%E6%96%AD%E4%B8%8E-tss tabindex=-1>中断与 TSS <a class=headerlink href=#%E4%B8%AD%E6%96%AD%E4%B8%8E-tss></a></h2><p>我们刚刚提到，当用户态下发生中断时，我们需要切换栈到内核态。而在 x86 中，中断由 CPU 以一种特殊<strong>函数调用</strong>的形式通知到内核，所以需要进入中断处理函数前切换到内核栈，所以在 x86 中这个切换的过程只能由 CPU 来完成。</p><p>x86 使用 TSS（Task Status Segment，任务状态段）来描述当前正在运行的任务的信息，并基于此提供了硬件多任务（上下文切换）的功能。我们并不需要硬件多任务，只需要关注 TSS 中的 <code>ESP0</code> 属性（意为 ESP for Ring 0，即用于内核态的栈指针）即可。当在非 0 特权级发生中断时，CPU 会从当前任务的 TSS 中读取 <code>ESP0</code> 属性，并赋值给 <code class=punctuation-r>ESP</code>，随后调用中断处理函数。</p><p>由于不需要硬件多任务，我们只需要一个 TSS 实例。将 TSS 存储到共享内存区域（在每个进程的地址空间中均被映射）中，并在每次上下文切换前将它的 <code>ESP0</code> 更新为新进程的内核栈地址即可。</p><p>使用 TSS 的方式是，在 GDT 中加入一个描述符，指向 TSS 结构，并使用 <code>LTR</code> 指令加载这个段，即可设置当前 CPU 所使用的 TSS。</p><div class=flex-wrapper><blockquote><p>由于中断是一种特殊的函数调用，所以通过 <code>IRET</code> 返回时，将由 CPU 来负责返回后继续执行之前的任务，即切换回 Ring 3，切换回用户栈，并回到发生中断前的 <code class=punctuation-r>EIP</code>。</p></blockquote></div><h2 id=%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1 tabindex=-1>系统调用 <a class=headerlink href=#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1></a></h2><p>在 x86 中从用户态（Ring 0）进入内核态（Ring 3）有多种方式，如软中断、异常、调用门和 <code>SYSENTER/SYSCALL</code> 指令等，其中后两种也可以用于从内核态进入用户态。在此我们使用 <code>SYSENTER</code> 指令（仅 x86 可用，x64 中由 <code>SYSCALL</code> 指令取代）。</p><div class=flex-wrapper><blockquote><p>在 Pentium II 引入 <code>SYSENTER</code> 之前，触发<strong>无效指令异常</strong>曾是 80386 上最快进入内核态的方式，这在当时<a target=_blank rel=noopener href="https://devblogs.microsoft.com/oldnewthing/?p=37003">被用于 Windows 中</a>。</p></blockquote></div><p><code>SYSENTER</code> 要求我们在内核态中提前告知 CPU，返回内核时需要设置的 <code class=punctuation-r>CS</code>、<code class=punctuation-l>EIP</code> 和 <code>ESP</code> 值（考虑到唯一需要手动从用户态进入内核态的场景是进行系统调用，这里所需的即是<strong>系统调用分发函数</strong>的入口与当前进程<strong>内核栈</strong>的栈底），在执行时仅做特权级切换、栈切换和跳转三件事，具体地：</p><ul><li>在进入用户态前，内核需要将参数写入以下 MSR（Model Specific Register，模型特定寄存器）<ul><li><strong><code>IA32_SYSENTER_CS = 0x174</code></strong>: 内核态 <code>CS</code> 寄存器的值</li><li><strong><code>IA32_SYSENTER_ESP = 0x175</code></strong>: 进入内核态时要设置的 <code>ESP</code> 寄存器的值（即内核栈的地址）</li><li><strong><code>IA32_SYSENTER_EIP = 0x176</code></strong>: 进入内核态时要设置的 <code>EIP</code> 寄存器的值（即系统调用分发函数的入口地址）</li></ul></li><li>当在用户态执行 <code>SYSENTER</code> 指令时，CPU 会<ul><li>将 <code>CS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值</li><li>将 <code>SS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 8（也就是说，期望<strong>内核数据段</strong>是<strong>内核代码段</strong>的下一个）</li><li>不会从 GDT 中加载对应段的信息，而是默认此时 <code>CS</code> 与 <code>SS</code> 段是遵从扁平内存模型的代码段（可读可执行）与数据段（可读可写），且 DPL 为 0（无需关心）</li><li>将 <code>ESP</code> 设为 <code>IA32_SYSENTER_ESP</code> 的值</li><li>将 <code>EIP</code> 设为 <code>IA32_SYSENTER_EIP</code> 的值</li><li>寄存器状态被保留</li><li>切换到 Ring 0，从设置后的 <code>CS:EIP</code> 开始执行</li></ul></li><li>当在内核态执行 <code>SYSEXIT</code> 指令时，CPU 会<ul><li>将 <code>CS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 16（也就是说，期望<strong>用户代码段</strong>是<strong>内核数据段</strong>的下一个）</li><li>将 <code>SS</code> 设为 <code>IA32_SYSENTER_CS</code> 的值加 24（也就是说，期望<strong>用户数据段</strong>是<strong>用户代码段</strong>的下一个）</li><li>不会从 GDT 中加载对应段的信息，而是默认此时 <code>CS</code> 与 <code>SS</code> 段是遵从扁平内存模型的代码段（可读可执行）与数据段（可读可写），且 DPL 为 0（无需关心）</li><li>将 <code>ESP</code> 设为 <code>ECX</code> 的值（应在系统调用时由用户态告知）</li><li>将 <code>EIP</code> 设为 <code>EDX</code> 的值（应在系统调用时由用户态告知）</li><li>寄存器状态被保留</li><li>切换到 Ring 3，从设置后的 <code>CS:EIP</code> 开始执行</li></ul></li></ul><p>所以，<code class=punctuation-l>SYSENTER</code> 与 <code>SYSEXIT</code> 所需要的段排列顺序为：</p><ol><li>内核代码段</li><li>内核数据段</li><li>用户代码段</li><li>用户数据段</li></ol><p>我们只需要以上四个段，将 GDT 的第 5 项设为上文中提到的 <a href=#%E4%B8%AD%E6%96%AD%E4%B8%8E-tss>TSS</a> 即可。</p><div class=flex-wrapper><blockquote><p>由于系统调用进入内核态后会进行函数调用，会破坏上下文，所以建议在进入内核态前保存上下文。</p><p>由于 <code>ECX</code> 与 <code>EDX</code> 将用于为 <code>SYSEXIT</code> 系统调用传参，所以不能使用这两个寄存器来存放返回值。</p></blockquote></div><h2 id=%E9%A1%B5%E6%9D%83%E9%99%90 tabindex=-1>页权限 <a class=headerlink href=#%E9%A1%B5%E6%9D%83%E9%99%90></a></h2><p>页目录项与页表项中有一个 User/Supervisor 位，将该字段被设为 1 时，表示对应的页面（或范围内的页面）<strong>可在用户态（非 Ring 0）访问</strong>，否则当该字段被设为 0 时，<strong>仅可在内核态（Ring 0）访问</strong>。</p><p>当页表项与其所属页表的页目录项中 User/Supervisor 位的值不同时，取较严格的一项限制，即仅当两处设置均为 1 时，该页可在用户态访问。</p></div></div><nav class=post-pagination><a class=newer-posts href=../ssl-with-github-actions/ >上一篇<br>使用 GitHub Actions 自动申请与部署 ACME SSL 证书 </a><span class=page-number></span> <a class=older-posts href=../mobile-security-compare/ >下一篇<br>Android 与 iOS 安全机制对比</a></nav><div class=post-comment-wrapper-giscus><div class=giscus></div></div></div></div><div class=single-column-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div></div><script src=//cdnjs.baoshuo.ren/ajax/libs/jquery/3.3.1/jquery.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/popper.js/1.14.4/umd/popper.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/vue/2.5.17/vue.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/smooth-scroll/14.2.1/smooth-scroll.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js crossorigin=anonymous></script><script src=//static.cdn.menci.xyz/menci-blog/js/journal.bde01167.min.js crossorigin=anonymous></script><script src=//giscus.api.menci.xyz/client.js data-repo=Menci/blog data-repo-id=R_kgDOGsK5nA data-category=Comments data-category-id=DIC_kwDOGsK5nM4CAulO data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=menci-blog data-lang=zh-CN async></script><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js?t=https%3A%2F%2Fstatic.cdn.menci.xyz%2Fmenci-blog%2F")}));</script></body></html>