<!doctype html><html lang=zh-CN><head><title>Android 与 iOS 安全机制对比 - Menci&#39;s Blog</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=author content=Menci><meta name=description content="本文曾为本人一门课程的期末报告，其中有些内容可能不够准确与全面，欢迎大家指正。
作为现代移动操作系统，Androi..."><meta name=keywords content=""><link rel=alternate type=application/atom+xml title="ATOM 1.0" href=/atom.xml><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=renderer content=webkit><meta name=theme-color content=#ffffff><link rel="shortcut icon" type=image/x-icon href=//static.cdn.menci.xyz/menci-blog/avatar.6e993e78.png crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css crossorigin=anonymous><link rel=stylesheet href=//cdnjs.baoshuo.ren/ajax/libs/KaTeX/0.15.2/katex.min.css crossorigin=anonymous><link rel=stylesheet href=//static.cdn.menci.xyz/menci-blog/css/journal.b205a034.css crossorigin=anonymous><link rel=stylesheet href="//cdn.menci.xyz/fonts/css2?family=Noto+Sans+SC:wght@300%3B400%3B600&family=Source+Sans+Pro:wght@400%3B600&family=Lato:wght@400%3B500&family=Hind+Vadodara:wght@300%3B400&family=Montserrat&family=Fira+Code&family=Material+Icons&display=block" crossorigin=anonymous><script async data-domain=blog.men.ci src=//stat.u.sb/js/plausible.js></script><meta name=generator content="Hexo 7.3.0"></head><body><div id=top></div><div id=app><div class=single-column-drawer-container ref=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block false drawer-menu-item" href=https://blog.men.ci>首页 </a><a class="a-block false drawer-menu-item" href=/archives/ >归档 </a><a class="a-block false drawer-menu-item" href=/tags/ >标签 </a><a class="a-block false drawer-menu-item" href=/friends/ >朋友们 </a><a class="a-block false drawer-menu-item" href=/about-me/ >关于我</a></div></div></div><transition name=fade><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav ref=navBar class="navbar navbar-light single-column-nav-container sticky-top"><div ref=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer><i class=material-icons>menu</i></button> <a ref=navTitle class=navbar-brand href=/ >Menci&#39;s Blog</a></div></nav><div class=single-column-header-container ref=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=/ ><div class=single-column-header-title>Menci's Blog</div><div class=single-column-header-subtitle>念念不忘，必有回响</div></a></div><div ref=sideContainer class=side-container><a class="a-block false nav-head" href=/ ><div class=nav-title>Menci's Blog</div><div class=nav-subtitle>念念不忘，必有回响</div></a><div class=nav-link-list><a class="a-block false nav-link-item" href=/archives/ >归档 </a><a class="a-block false nav-link-item" href=/tags/ >标签 </a><a class="a-block false nav-link-item" href=/friends/ >朋友们 </a><a class="a-block false nav-link-item" href=/about-me/ >关于我</a></div><div class=nav-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div><div ref=extraContainer class=extra-container><div class=pagination><a id=globalBackToTop class="animated-visibility pagination-action" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div ref=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only style="background-image: url('')"><div class=post-title>Android 与 iOS 安全机制对比<div class=post-meta><time datetime=2022-02-02T13:21:00.000Z itemprop=datePublished>2022-02-02 </time>&nbsp; <i class=material-icons style="">label</i> <a href=/tags/安全/ >安全</a>, <a href=/tags/Android/ >Android</a>, <a href=/tags/iOS/ >iOS</a></div></div></div><div class=post-body-wrapper><div class=post-body><ol class=toc><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85><span class=toc-number>1.</span> <span class=toc-text>应用程序安装</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E7%A7%81><span class=toc-number>2.</span> <span class=toc-text>权限与隐私</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E6%B2%99%E7%9B%92><span class=toc-number>3.</span> <span class=toc-text>沙盒</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%BC%95%E5%AF%BC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7><span class=toc-number>4.</span> <span class=toc-text>引导与系统完整性</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E5%8A%A0%E5%AF%86><span class=toc-number>5.</span> <span class=toc-text>加密</span></a></li><li class="toc-item toc-level-1"><a class=toc-link href=#%E6%80%BB%E7%BB%93><span class=toc-number>6.</span> <span class=toc-text>总结</span></a></li></ol><p>本文曾为本人一门课程的期末报告，其中有些内容可能不够准确与全面，欢迎大家指正。</p><p>作为现代移动操作系统，Android 和 iOS 都有较为完善的安全机制。本文将从若干个方面分析对比其安全机制的异同。</p><span id=more></span><h1 id=%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85 tabindex=-1>应用程序安装 <a class=headerlink href=#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85></a></h1><p>在 Android 设备上，应用程序往往以 <code>apk</code> 安装包（另有 <code>obb</code> 数据包与整体打包的 <code>xapk</code> 等格式，但核心仍是 <code class=punctuation-r>apk</code>）的形式发布。每个应用程序有其包名（通常是倒序分隔的域名，如 <code class=punctuation-r>org.mozilla.firefox</code>）和版本号，应用程序在发布前需要由发布者使用其 RSA 私钥进行<a target=_blank rel=noopener href="https://source.android.google.cn/security/apksigning?hl=zh_cn">数字签名</a>。当安装与已存在的包名相同的包时，Android 系统会使用拒绝<strong>签名公钥不一致</strong>或<strong>版本号更低</strong>的应用程序覆盖原有的应用程序。</p><p>基于 Android 系统的软件包安装机制，一个常见的攻击手段是重打包攻击：对软件包进行解包，加入恶意代码（比如窃取用户在该软件中登录所用的凭据）后重新打包并签名，并诱使用户安装。如果包名没有修改，且原软件包已安装，则 Android 系统会拒绝安装签名公钥不一致的新软件包，但攻击者可以修改包名并诱导用户安装看似一致的新安装包。开发者常使用签名验证的方式来防止重打包攻击，但攻击者也可通过逆向分析与 Hook 等手段绕过验证。Google 官方的 Play Store 也提供软件包分发服务，其能避免一部分威胁，但其对软件包内容<strong>审核较为宽松</strong>，导致一些名称相似的恶意软件能够在 Play Store 上发布。另一方面，Android 允许用户自行安装 <code>apk</code> 包，所以很多用户常常通过其他途径获得软件包并安装。所以，<strong>重打包攻击</strong>仍然是 Android 生态中的一大威胁。</p><p>在 iOS 设备上，软件包的格式为 <code class=punctuation-r>ipa</code>。但 <code>ipa</code> 的安装需要经过 Apple 的验证，iOS 仅接受被 Apple 允许在当前设备上安装的 <code>ipa</code> 软件包。且 iOS 有强制的代码签名检查机制，所有的可执行文件都必须具有<strong>可被 Apple 接受的签名</strong>，这在一定程度可以缓解了一些应用程序漏洞产生的影响。iOS 上软件分发的方式分为两大类：</p><p>一是通过 Apple 官方的渠道进行发布（App Store 和 TestFlight，后者一般仅用于发布测试版软件，且安装受到限制），这种情况下，设备需要登录 Apple ID，在软件包时会向 Apple 请求该软件包，并由 Apple 认证后发回带有针对该 Apple ID 的签名的软件包，iOS 会进行检验并安装。由于必须经过 Apple 的认证，通过该途径安装应用一般不会遭到重打包攻击（前提是 Apple 的审核不出漏洞，不会为带有恶意代码的重打包软件过审）。从一些第三方「应用商店」（如爱思助手）安装也是这种途径，第三方工具会<strong>重放</strong>它们提前获得的带有 Apple 签名的 <code>ipa</code> 进行安装，这样安装软件也不会带来安全隐患。</p><p>二是通过 Apple 签发的个人证书、开发者证书或企业证书进行签名。每个个人 Apple ID 都可以向 Apple 申请一个证书，单次为应用程序签名的有效期为 7 天（可续签），但 Apple 限定每台设备只能同时安装<strong>三个</strong>通过个人证书签名的使用。开发者证书可以付费购买，并可用于在已在该开发者账户上注册的设备上长期安装多个应用。企业证书的有效期和允许的软件包数量更大，并且可以向任意 iOS 设备分发。这三种方式均可在不经过 Apple 审核的情况下安装应用，但 iOS 在第一次运行前会警告用户其开发者未经验证，并引导用户在设置中选择信任。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-trust-developer@2x.0cf769c1.png title=使用个人证书签名安装软件包，并在设置中选择信任 data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-trust-developer@2x.0cf769c1.png alt="iOS 信任开发者" title=使用个人证书签名安装软件包，并在设置中选择信任 srcset="//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-trust-developer@2x.0cf769c1.png 2x" crossorigin=anonymous></a><p class=image-caption>使用个人证书签名安装软件包，并在设置中选择信任</p></div></div><p>这种私人发布的软件包，虽然签名过程仍然需要请求 Apple，但其安全性未经过 Apple 的审核，可能面临重打包攻击的威胁，然而由于其实施成本过高（个人证书有效期短且需要连接 PC 安装，开发者证书需要注册，企业证书价格贵且难以申请），所以实际应用较少。但不可否认的是，重打包攻击在 iOS 上仍然有一定可行性，在访问网页等操作时遇到不明的安装应用请求时也需要小心。</p><h1 id=%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E7%A7%81 tabindex=-1>权限与隐私 <a class=headerlink href=#%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E7%A7%81></a></h1><p>在 Android 6.0 之前，Android 应用程序在<strong>安装时</strong>请求所有权限。从 Android 6.0 开始，应用程序需要在运行时获取权限。大部分商业应用程序都会请求 <a target=_blank rel=noopener href=https://developer.android.com/reference/android/Manifest.permission#READ_PHONE_STATE><code>READ_PHONE_STATE</code></a> 权限，用于读取设备的 IMEI，作为用户的标识符，用于广告推送等用途。这使得用户极容易被跟踪。</p><p>值得一提的是，Android 提供了一个特权接口 <a target=_blank rel=noopener href=https://developer.android.com/reference/android/app/AppOpsManager><code>AppOpsManager</code></a>，可以用来对应用程序的权限进行高级管理。例如，在某个拥有 <code>READ_PHONE_STATE</code> 权限的应用程序读取 IMEI 时，为其<strong>返回无效数据</strong>（而不是产生异常使程序无法运行），以在应用程序正常工作的前提下保护隐私。访问该接口需要 <code>appop</code> 权限，该权限无法通过一般方式获取，只能通过 <code>pm grant</code> 授予（而调用 <code>pm grant</code> 需要 ADB Shell 或 root 的权限）。可能是出于广告相关的商业利益考量，Google 没有提供对应的用户界面，市面上有一些调用该接口管理其他应用程序权限的应用程序，但由于操作较为复杂，且大部分用户并不关心隐私，所以使用者非常少。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-appops@2x.cc3949af.png title="通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-appops@2x.cc3949af.png alt="AppOps 权限管理" title="通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据" srcset="//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-appops@2x.cc3949af.png 2x" crossorigin=anonymous></a><p class=image-caption>通过 AppOpsManager 接口，设置某第三方应用读取 IMEI 时返回空数据</p></div></div><p>一些第三方 Android 发行版拥有更强的权限管理，如 <a target=_blank rel=noopener href=https://lineageos.org/ >LineageOS</a> 可在应用程序每次尝试调用需要敏感权限（如定位）的接口时询问用户，或进行记录。使得用户可以察觉应用程序未经预料的访问敏感数据，或过于频繁地访问隐私数据的行为。</p><p>Android 可向应用程序提供较高的权限，如修改系统设置、连接 Wi-Fi 网络等。另外，Android 中存在一个特殊权限 —— Accessibility，该权限需要应用程序进行申请，并由用户在系统设置中手动选择启用，启用时系统还会进行警告。拥有该权限的应用程序可<strong>拦截/模拟用户的输入操作</strong>，以实现无障碍访问等辅助功能。但若恶意应用程序诱使用户授予该权限，则可以在一定程度上控制整个设备的行为，对设备安全产生极大的威胁。</p><p>iOS 的权限管理模型与 6.0 之后的 Android 类似 —— 应用程序在运行时向用户申请权限。在 iOS 下，应用程序可以申请的权限较少，一方面这提升了系统的安全性，但另一方面也使得某些功能无法实现。严格的权限限制是一把双刃剑，Apple 选择了收紧权限，并由系统软件提供这部分功能。</p><p>与 Android 下可直接获取不同，较新版本的 iOS 不允许应用程序获取几乎所有的设备标识符（包括但不限于 IMEI、Wi-Fi MAC 地址，蓝牙 MAC 地址等），并要求应用程序使用 Apple 专门提供的<strong>广告 ID</strong> 进行追踪。且该 ID 可被用户禁用或重置。这在一定程度上保护了用户隐私。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-ad-id@2x.3c26a0d1.png title="在 iOS 系统设置中配置广告 ID" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-ad-id@2x.3c26a0d1.png alt="iOS 广告 ID" title="在 iOS 系统设置中配置广告 ID" srcset="//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-ad-id@2x.3c26a0d1.png 2x" crossorigin=anonymous></a><p class=image-caption>在 iOS 系统设置中配置广告 ID</p></div></div><p>相对于获取设备标识符，定位权限往往是用户更为担忧的。iOS 14 提供了限制应用程序获得的位置信息精度的功能，应用程序在请求定位权限时，用户可将「精确」设为关闭，以使得应用程序仅获得<strong>大致的位置信息</strong>。该位置信息能够帮助应用程序定位用户所在的城市，但无法进行精确地追踪。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-location-precise@2x.e158f959.png title=在某第三方应用请求权限时，选择为其提供不精确的位置信息 data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-location-precise@2x.e158f959.png alt="iOS 关闭精确定位" title=在某第三方应用请求权限时，选择为其提供不精确的位置信息 srcset="//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-location-precise@2x.e158f959.png 2x" crossorigin=anonymous></a><p class=image-caption>在某第三方应用请求权限时，选择为其提供不精确的位置信息</p></div></div><h1 id=%E6%B2%99%E7%9B%92 tabindex=-1>沙盒 <a class=headerlink href=#%E6%B2%99%E7%9B%92></a></h1><p>在 Android 和 iOS 下，一般的应用软件都运行在沙盒中。</p><p>Android 的沙盒机制基于 Linux 内核提供的多用户功能。每个应用程序在安装时被分配一个用户 ID（UID），其数据目录被标记为仅该 UID 可访问。并使用用户组（groups）机制来为应用程序授予访问系统资源的权限（如，对应用户拥有 <code>sdcard_rw</code> 组的应用程序，可以访问 <code>/sdcard</code> 路径）。该机制较为简单，并且受益于 Linux 内核的可靠性，其对于基本的安全性有很大的保障。</p><p>在很多时候，Android 的沙盒机制并没有将不同的应用程序进行隔离，应用程序仍然可以通过系统提供的途径相互通信。例如，应用程序之间可以通过 Intent 来相互传递消息，可以以此唤起另一个应用程序的 Activity 等。其中较为不安全的一点是，应用程序可以将数据写入到 <code>/sdcard</code> 路径中，以便其他任何应用程序访问。很多应用程序将敏感数据放置在该路径下，这可能会导致<strong>隐私追踪</strong>和<strong>数据泄露</strong>的问题。自 Android 10 起，Google 已经不鼓励，甚至<a target=_blank rel=noopener href="https://source.android.google.cn/devices/storage?hl=zh-cn">将要禁止</a>应用程序使用 <code>/sdcard</code> 共享数据。</p><p>较新版本的 Android 还<a target=_blank rel=noopener href="https://source.android.google.cn/security/selinux?hl=zh_cn">通过 SELinux</a> 实现了系统组件的 DAC（强制访问控制），对系统特权进程进行更严格的权限控制，尽量仅授予必需系统资源的访问权限，以进一步更加系统的安全性，防止一些高权限系统组件在受到漏洞攻击时泄露过大的权限。</p><p>相比之下，iOS 的沙盒机制更为复杂，也更为严格。与 Android 相同，iOS 的应用程序的文件系统访问也被限制在其私有的数据目录下。但与 Android 基于 UNIX 用户的隔离不同，iOS 下所有的第三方应用程序均运行在 <code>mobile</code> 用户下，该用户本身拥有访问绝大多数系统资源的权限，但 iOS 对系统调用进行了限制：iOS 根据应用程序所拥有的权限，为其维护一个<strong>沙盒配置文件</strong>（Sandbox Profile），并在内核中系统调用的关键路径上增加了一个 <strong>MAC 层</strong>，以检查应用程序是否有权限进行当前的系统调用，仅当有权限才会继续执行。这种限制方式与 Linux 下的 <code>ptrace</code> / <code>seccamp</code> 类似。</p><p>iOS 应用之间的隔离更为严格 —— 首先，由于后台机制的不同，iOS 的应用程序没有期望常驻后台的 Service 组件，难以在后台保持运行，所以，自然地，一个应用程序也不被期望直接向另一个运行中的应用程序发送消息（使用共享目录中的 UNIX Socket 可能是一种可行的方案，但意义不大）。iOS 系统提供以下几种应用间通信的方式：</p><ul><li>当需要调用另一个应用程序提供的功能供用户临时进行操作（如调用移动支付软件进行付款）时，往往使用系统提供的 URL Scheme 功能 —— 应用程序可以定义其接受的 URL 前缀（如 Alipay 定义了 <code>alipay://</code> 前缀），并由欲调用的应用程序通知系统进行调用，系统会启动目标应用程序，将 URL 传递过去，由目标应用程序进行解析并处理。</li><li>当需要调用另一个应用程序来发送/打开特定的文件时，可以使用 Share Sheet 功能。该功能被调用后，系统会弹出一个菜单，要求用户选择要调用的应用程序，用户选择后，iOS 系统会将文件复制到目标应用的沙盒中，并启动目标应用，将调用信息告知。</li><li>当需要与另一个（或一些）特定的应用程序共享<strong>凭据</strong>（如 Gmail 与 Chrome 可共享 Google 账号的登录信息），可以使用 Keychain 接口，该接口仅提供跨应用程序的数据存储，没有传递消息的功能。</li></ul><p>可见，iOS 的应用间通信接口被高度特化，且难以在用户<strong>无感知</strong>的情况下调用另一个应用程序。这在一定程度上避免了串谋权限攻击和一些隐私泄露问题。</p><h1 id=%E5%BC%95%E5%AF%BC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7 tabindex=-1>引导与系统完整性 <a class=headerlink href=#%E5%BC%95%E5%AF%BC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%95%B4%E6%80%A7></a></h1><p>现代 Android 设备采用了 Verified Boot 技术来保证系统引导的安全性。设备在出厂时附带<strong>厂商的公钥</strong>，作为信任根（Root of Trust），在设备启动时，引导加载程序（固化在 ROM 中）会对操作系统的完整性进行检验。被检验的数据包括 <code>boot</code> 分区（Linux 内核和引导所需文件）、<code class=punctuation-l>system</code> 分区（Android 系统）和 <code>vendor</code> 分区（设备厂商提供的系统文件）等。对于 <code class=punctuation-r>boot</code>、<code class=punctuation-l>vendor</code> 等较小的分区，引导加载程序会在引导时进行验证，对于较大的 <code>system</code> 分区，系统会保存其<a target=_blank rel=noopener href=https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E6%A0%91>默克尔树（Merkle Tree）</a>，在使用时动态的验证被访问到的部分，如果验证不通过则产生 I/O 错误。</p><p>Android <a target=_blank rel=noopener href="https://source.android.google.cn/security/verifiedboot/device-state?hl=zh_cn">引导加载程序</a>往往是被锁定（LOCKED）的。位于锁定状态下的引导加载程序仅接受厂商在 ROM 中内置的信任根，而拒绝加载未经厂商验证的操作系统，这使得攻击者即使获得物理访问或者 root 权限，也无法对系统进行持久化的修改，因为任何修改都会使得自底向上<strong>信任链失效</strong>，进而使设备拒绝引导/工作。</p><p>另一方面，Android 引导加载程序往往允许用户进行解锁。位于解锁（UNLOCKED）状态下的引导加载程序允许用户自定义被加载的操作系统。一些实现允许用户将自己的公钥作为信任根，并安装自行签名的操作系统；用户也可完全关闭引导验证功能，让引导加载程序加载任何操作系统。攻击者在拥有设备的物理访问后，可通过解锁引导加载程序来修改操作系统，进而完全控制设备并窃取用户数据，考虑到这一安全隐患，引导加载程序在解锁时会<strong>清空所有用户数据</strong>。同时，为了避免用户的设备在不知情的情况下被解锁并植入恶意软件，已解锁的引导加载程序会在设备启动时显示<strong>警告信息</strong>，告知用户其设备正在加载自定义操作系统。</p><p>Android 设备往往使用 <a target=_blank rel=noopener href="https://source.android.google.cn/devices/bootloader/recovery-image?hl=zh-cn">Recovery</a> 环境更进行系统更新与还原，该模式位于 <code>recovery</code> 分区中，包含一个由厂商预先写入的小型操作系统，同时，该分区同样受 Verified Boot 的保护。Recovery 模式往往仅接受由厂商验证过的操作系统。为了防止降级以利用旧版本的安全漏洞，有些厂商也会拒绝安装比现有版本更低的操作系统。在解锁引导加载程序后，用户也可替换原有的 Recovery 环境，方便进行自定义操作系统的安装与维护。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-unlocked-bootloader.ccfd39d6.png title="Android 引导加载程序解锁后的警告" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-unlocked-bootloader.ccfd39d6.png alt="Android 引导加载程序解锁后的警告" crossorigin=anonymous></a><p class=image-caption>Android 引导加载程序解锁后的警告</p></div><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-custom-recovery.7a647bb5.png title="Android 自定义 Recovery" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/android-custom-recovery.7a647bb5.png alt="Android 自定义 Recovery" crossorigin=anonymous></a><p class=image-caption>Android 自定义 Recovery</p></div></div><p>iOS 也采用了信任链的方式来保证系统引导的安全性。iOS 设备启动时首先加载被固化到硬件中的安全引导程序 <a target=_blank rel=noopener href=https://www.theiphonewiki.com/wiki/Bootrom>SecureROM</a>，该程序正常情况下会验证并加载闪存中的引导加载程序 iBoot，并由 iBoot 对 Darwin 内核进行验证并加载。Darwin 内核在加载用户态的可执行程序时，会验证其数字签名，如果系统的可执行文件没有 Apple 的签名，则拒绝执行。同样，即使攻击者在 iOS 系统中获得了 root 权限，也无法通过对系统产生持久化的影响。</p><p>SecureROM 的另一个功能是 <a target=_blank rel=noopener href=https://www.theiphonewiki.com/wiki/DFU_Mode>DFU（Device Firmware Upgrade）</a> 模式。在 iOS 系统损坏时，可进入 DFU 模式以通过 USB 连接到计算机，并重新安装操作系统。在 iOS 设备上，操作系统的安装需要 Apple 的签名，且该签名与每次安装有关（被签名随机数由 SecureROM 在安装操作系统时生成，并被持久存储以在每次引导时验证），以避免设备安装被修改过的操作系统，或已被 Apple 禁止安装的 iOS 版本。在已取得 root 权限的情况下，可通过重放曾被成功签名的随机数的方式安装旧版本系统，但在（下文中提到的）SEP 未被攻破的前提下，SEP OS 无法降级，将可能导致兼容性问题。</p><p>值得一提的是，SecureROM 在加载后，会<strong>禁用</strong> SecureROM 所在存储区域的<strong>读权限</strong>，使得在 iOS 中，即使获得了高权限，也无法读取 SecureROM 的代码，给安全人员的分析带来了极大的困难。但安全人员仍然发现了其中 DFU 模式下的一个 use-after-free 漏洞（checkm8，意为「checkmate」，即象棋中的「绝杀无解」，寓意漏洞在 ROM 中不可修复），并通过该漏洞实现了任意代码执行。<a target=_blank rel=noopener href=https://checkra.in>checkra1n</a> 是一个利用该漏洞的工具，其利用该漏洞来控制 DFU 模式下设备的引导，并在进入 iOS 后安装一个向用户提供 root 权限的系统应用程序。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-checkra1n-cli@2x.167b5f03.png title="使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-checkra1n-cli@2x.167b5f03.png alt="checkra1n 工具运行" title="使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备" srcset="//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-checkra1n-cli@2x.167b5f03.png 2x" crossorigin=anonymous></a><p class=image-caption>使用 checkra1n 工具攻击处于 DFU 模式的 iOS 设备</p></div><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-checkra1n-boot.1722efc3.png title="被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-checkra1n-boot.1722efc3.png alt="checkra1n 攻击成功" title="被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）" crossorigin=anonymous></a><p class=image-caption>被 checkra1n 工具所控制的 iOS 设备引导（verbose 模式）</p></div></div><p>在设备丢失或被盗时，非法持有者无法解开设备的密码锁，可能会通过重新安装操作系统的方式使用设备。iOS 设备在用户登录 Apple ID 后，会将设备记录到 Apple 的服务器上（即「Find My iPhone」功能，也就是通常所说的「ID 锁」），当该设备重新安装操作系统后，Apple 会要求用户再次登录该 Apple ID 以激活设备。这使得非法持有者无法使用设备。Android 也有类似的机制，但在引导加载程序解锁后不再有效。所以，为了保证安全，Android 设备对引导加载程序的解锁，往往需要用户在系统内和引导加载程序中进行两次确认。</p><h1 id=%E5%8A%A0%E5%AF%86 tabindex=-1>加密 <a class=headerlink href=#%E5%8A%A0%E5%AF%86></a></h1><p>Android 和 iOS 都具有加密文件系统以保护用户数据的功能。</p><p>Android 的加密分为两种：<a target=_blank rel=noopener href="https://source.android.google.cn/security/encryption/full-disk?hl=zh-cn">全盘加密（Full Disk Encryption）</a>和<a target=_blank rel=noopener href="https://source.android.google.cn/security/encryption/file-based?hl=zh-cn">文件级加密（File-Based Encryption）</a>。</p><p><a target=_blank rel=noopener href="https://source.android.google.cn/security/encryption/full-disk?hl=zh-cn">全盘加密</a>引入于 Android 4.4，在 Android 10 中去除。其原理是，系统在初始化时随机生成一个 128 位的主密钥，并使用此密钥与 AES 算法将数据分区（<code class="punctuation-r punctuation-l">data</code>）加密。当用户设置密码时，主密钥被使用用户设置的密码加密后储存起来（根据设备支持情况，储存在闪存或硬件安全存储中）。当用户修改密码时，主密钥不会改变，所以数据不需要被重新加密。全盘加密有一个缺点 —— 由于应用程序依赖于数据分区，而在设备启动后，用户第一次输入密码前，设备的数据分区是未被解密的，所以用户<strong>无法使用</strong>包括闹钟、电话在内的<strong>任何功能</strong>。</p><p>为了解决解锁前无法使用任何设备功能的问题，Android 7.0 引入了<a target=_blank rel=noopener href="https://source.android.google.cn/security/encryption/file-based?hl=zh-cn">文件级加密</a>。文件级加密可对每个文件单独进行加密，并且支持对不同文件使用不同的密钥加密。一般来说，文件级加密体系中有 CE（Credential Encrypted，凭据加密）和 DE（Device Encrypted，设备加密）两个密钥，前者用于加密用户的<strong>大部分数据</strong>，后者用于加密需要在<strong>解锁设备前访问</strong>的数据。CE 所用的密钥被以类似于全盘加密主密钥的形式加密存储，DE 所用的密钥被直接存储。应用程序可以选择其存储的特定数据使用 CE 还是 DE 进行加密 —— 如闹钟应用程序可将设定的闹钟列表存储在 DE 中，在设备启动后解锁前即可工作。而安全敏感的数据，如 Google 账户凭据则存放在 CE 中，仅在用户解锁设备后可访问。</p><p>iOS 的加密与 Android 的文件级加密类似，同样是对每个文件分别加密。此外，为了防止物理攻击，每台 iOS 设备的 TPM 模块（被称为 Secure Enclave Processor，SEP）中会内置一个独一无二的主密钥，文件加密的密钥均由该密钥派生而来，且无法在可信的操作系统之外获得，这使得攻击者无法卸下闪存芯片并使用其他设备对用户密码进行<strong>暴力破解</strong>。搭载了类似的硬件安全密钥存储模块的 Android 设备也能够达到同样的安全性。</p><div class=images><div class=image><a href=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-key-management.7231ddd5.svg title="iOS 使用 SEP 管理密钥" data-fancybox><img src=//static.cdn.menci.xyz/menci-blog/mobile-security-compare/ios-key-management.7231ddd5.svg alt="iOS 的密钥管理" title="iOS 使用 SEP 管理密钥" crossorigin=anonymous></a><p class=image-caption>iOS 使用 SEP 管理密钥</p></div></div><p>相对于 Android 的文件夹机密，iOS 增加了一个更强的文件加密级别：对于极度敏感的数据（如用户的电子邮件），系统会在用户解锁时（使用用户密码和 TPM 中的密钥）对其密钥进行解锁，并在设备锁定时将解锁后的文件密钥<strong>从内存中删除</strong>，使得一些情况下，即使攻击者获得了较高权限，也无法在未解锁时读取敏感数据。</p><p>Android 和 iOS 都具有密码尝试次数过多后清除用户数据的功能，其实现方式是将被加密的密钥从闪存 / TPM 中清除，使得现有的数据<strong>无法再被解密</strong>。</p><h1 id=%E6%80%BB%E7%BB%93 tabindex=-1>总结 <a class=headerlink href=#%E6%80%BB%E7%BB%93></a></h1><p>总的来说，Android 的安全体系较为<strong>开放</strong>，偏向于使用较为简单的安全策略来达到足够的安全性；而 iOS 的安全体系较为<strong>严格</strong>，偏向于使用多层次的安全策略，与硬件级的安全模块相结合，并强制加入 Apple 的控制，来将威胁降至最低。Android 的安全策略很大程度上受厂商定制的影响，一些厂商定制的 Android 设备可能具有更高或更低的安全性。</p><p>Android 的绝大多数安全功能依赖于 Linux 内核的安全性，而 Linux 内核少有可利用的漏洞。相比之下，iOS 的 Darwin 内核被爆出过更多的高危漏洞，安全性低于 Linux。较新版本的 iOS 加入了内核完整性保护（Kernel Integrity Protection）的功能，禁止一些敏感内存区域（如中断向量表）被修改，一定程度上降低了内核漏洞的危害。</p><p>在应用程序方面，早期的 Android 更加开放，表现的更加信任开发者。而 iOS 则尽可能少授予应用程序权限，以保证用户的隐私。较新版本的 Android 也有<strong>收紧权限控制</strong>的趋势。在系统底层，Android 与 iOS 都使用引导信任链来保证系统的完整性，并使用加密来保护用户数据。</p></div></div><nav class=post-pagination><a class=newer-posts href=../x86-userland-and-syscall/ >上一篇<br>在 x86 中实现用户态与系统调用 </a><span class=page-number></span></nav><div class=post-comment-wrapper-giscus><div class=giscus></div></div></div></div><div class=single-column-footer>Powered by <a href=https://hexo.io/ target=_blank rel="noreferrer noopener">Hexo</a><br>Theme <a href=https://github.com/Menci/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal</a> by <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a><br>&copy; 2024 <a href=https://blog.men.ci>Menci<i class=material-icons>favorite</i></a></div></div></div><script src=//cdnjs.baoshuo.ren/ajax/libs/jquery/3.3.1/jquery.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/popper.js/1.14.4/umd/popper.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/vue/2.5.17/vue.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/smooth-scroll/14.2.1/smooth-scroll.min.js crossorigin=anonymous></script><script src=//cdnjs.baoshuo.ren/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js crossorigin=anonymous></script><script src=//static.cdn.menci.xyz/menci-blog/js/journal.bde01167.min.js crossorigin=anonymous></script><script src=//giscus.api.menci.xyz/client.js data-repo=Menci/blog data-repo-id=R_kgDOGsK5nA data-category=Comments data-category-id=DIC_kwDOGsK5nM4CAulO data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=menci-blog data-lang=zh-CN async></script><script>"serviceWorker"in navigator&&window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js?t=https%3A%2F%2Fstatic.cdn.menci.xyz%2Fmenci-blog%2F")}));</script></body></html>